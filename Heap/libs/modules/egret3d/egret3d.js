var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var egret3d;
(function (egret3d) {
    var reflect;
    (function (reflect) {
        function regType(target, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            target["__gdmeta__"]["class"]["typename"] = name;
            if (document["__gdmeta__"] == null) {
                document["__gdmeta__"] = {};
            }
            document["__gdmeta__"][name] = target;
            if (target["__gdmeta__"]["class"]["custom"] == null) {
                target["__gdmeta__"]["class"]["custom"] = {};
            }
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        function regField(target, fieldName, customInfo) {
            if (target["__gdmeta__"] == undefined) {
                target["__gdmeta__"] = {};
            }
            if (target["__gdmeta__"][fieldName] == null) {
                target["__gdmeta__"][fieldName] = {};
            }
            target["__gdmeta__"][fieldName]["type"] = "field";
            if (target["__gdmeta__"][fieldName]["custom"] == null) {
                target["__gdmeta__"][fieldName]["custom"] = {};
            }
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        function getPrototypes() {
            return document["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        function getPrototype(name) {
            return document["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        function createInstance(prototype, matchTag) {
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        function attr_Class(constructorObj) {
            regType(constructorObj.prototype, null);
        }
        reflect.attr_Class = attr_Class;
        function attr_Field(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        function userCode(constructorObj) {
            regType(constructorObj.prototype, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        function editorCode(constructorObj) {
            regType(constructorObj.prototype, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        function selfClone(constructorObj) {
            regType(constructorObj.prototype, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        function nodeComponent(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        function nodeRender(constructorObj) {
            regType(constructorObj.prototype, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        function nodeCamera(constructorObj) {
            regType(constructorObj.prototype, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        function nodeLight(constructorObj) {
            regType(constructorObj.prototype, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj.prototype, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj.prototype, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj.prototype, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj.prototype, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj.prototype, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        function node2DComponent(constructorObj) {
            regType(constructorObj.prototype, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        function pluginMenuItem(constructorObj) {
            regType(constructorObj.prototype, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        function pluginWindow(constructorObj) {
            regType(constructorObj.prototype, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        function pluginExt(constructorObj) {
            regType(constructorObj.prototype, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        function compValue(integer, defvalue, min, max) {
            if (integer === void 0) { integer = false; }
            if (defvalue === void 0) { defvalue = 0; }
            if (min === void 0) { min = Number.MIN_VALUE; }
            if (max === void 0) { max = Number.MAX_VALUE; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        function SerializeType(constructorObj) {
            regType(constructorObj.prototype, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        function Field(valueType, defaultValue, enumRealType) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            if (enumRealType === void 0) { enumRealType = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
            };
        }
        reflect.Field = Field;
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        var FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum";
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = egret3d.reflect || (egret3d.reflect = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this._eventMap = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, listener, thisObject) {
                var list = this._eventMap[type];
                if (!list) {
                    list = this._eventMap[type] = [];
                }
                list.push({ listener: listener, thisObject: thisObject || this });
            };
            EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
                var list = this._eventMap[type];
                if (!list) {
                    return;
                }
                for (var i = 0, len = list.length; i < len; i++) {
                    var bin = list[i];
                    if (bin.listener == listener && bin.thisObject == (thisObject || this)) {
                        list.splice(i, 1);
                        break;
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                event.target = this;
                this.notifyListener(event);
            };
            EventDispatcher.prototype.notifyListener = function (event) {
                var list = this._eventMap[event.type || event];
                if (!list) {
                    return;
                }
                for (var i = 0, len = list.length; i < len; i++) {
                    var bin = list[i];
                    bin.listener.call(bin.thisObject, event);
                }
            };
            return EventDispatcher;
        }());
        framework.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "egret3d.framework.EventDispatcher");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        var Vector2 = (function () {
            function Vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x;
                this.y = y;
            }
            Vector2.prototype.toString = function () {
                return this.x + "," + this.y;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector2.prototype, "x", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector2.prototype, "y", void 0);
            Vector2 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number])
            ], Vector2);
            return Vector2;
        }());
        math.Vector2 = Vector2;
        __reflect(Vector2.prototype, "egret3d.math.Vector2");
        var Rect = (function () {
            function Rect(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            Rect.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.w + "," + this.h;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Rect.prototype, "x", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Rect.prototype, "y", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Rect.prototype, "w", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Rect.prototype, "h", void 0);
            Rect = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], Rect);
            return Rect;
        }());
        math.Rect = Rect;
        __reflect(Rect.prototype, "egret3d.math.Rect");
        var Border = (function () {
            function Border(l, t, r, b) {
                if (l === void 0) { l = 0; }
                if (t === void 0) { t = 0; }
                if (r === void 0) { r = 0; }
                if (b === void 0) { b = 0; }
                this.l = l;
                this.t = t;
                this.r = r;
                this.b = b;
            }
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Border.prototype, "l", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Border.prototype, "t", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Border.prototype, "r", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Border.prototype, "b", void 0);
            Border = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], Border);
            return Border;
        }());
        math.Border = Border;
        __reflect(Border.prototype, "egret3d.math.Border");
        var Color = (function () {
            function Color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }
            Color.prototype.toString = function () {
                return this.r + "," + this.g + "," + this.b + "," + this.a;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Color.prototype, "r", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Color.prototype, "g", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Color.prototype, "b", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Color.prototype, "a", void 0);
            Color = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], Color);
            return Color;
        }());
        math.Color = Color;
        __reflect(Color.prototype, "egret3d.math.Color");
        var Vector3 = (function () {
            function Vector3(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
            }
            Vector3.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector3.prototype, "x", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector3.prototype, "y", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector3.prototype, "z", void 0);
            Vector3 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number])
            ], Vector3);
            return Vector3;
        }());
        math.Vector3 = Vector3;
        __reflect(Vector3.prototype, "egret3d.math.Vector3");
        var Vector4 = (function () {
            function Vector4(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            Vector4.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector4.prototype, "x", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector4.prototype, "y", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector4.prototype, "z", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Vector4.prototype, "w", void 0);
            Vector4 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], Vector4);
            return Vector4;
        }());
        math.Vector4 = Vector4;
        __reflect(Vector4.prototype, "egret3d.math.Vector4");
        var Quaternion = (function () {
            function Quaternion(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            Quaternion.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Quaternion.prototype, "x", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Quaternion.prototype, "y", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Quaternion.prototype, "z", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Quaternion.prototype, "w", void 0);
            Quaternion = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], Quaternion);
            return Quaternion;
        }());
        math.Quaternion = Quaternion;
        __reflect(Quaternion.prototype, "egret3d.math.Quaternion");
        var Matrix = (function () {
            function Matrix(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            Matrix.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            };
            return Matrix;
        }());
        math.Matrix = Matrix;
        __reflect(Matrix.prototype, "egret3d.math.Matrix");
        var Matrix3x2 = (function () {
            function Matrix3x2(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 1, 0]);
            }
            Matrix3x2.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            };
            return Matrix3x2;
        }());
        math.Matrix3x2 = Matrix3x2;
        __reflect(Matrix3x2.prototype, "egret3d.math.Matrix3x2");
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Asset = (function () {
            function Asset(name, defaultPrefix) {
                if (name === void 0) { name = undefined; }
                this.defaultAsset = false;
                this._name = "";
                this._guid = Asset.IDCount++;
                if (!name) {
                    name = defaultPrefix + "_" + this.getGUID();
                }
                this._name = name;
            }
            Asset.prototype.getName = function () {
                return this._name;
            };
            Asset.prototype.getGUID = function () {
                return this._guid;
            };
            Asset.prototype.use = function () {
            };
            Asset.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
            };
            Asset.IDCount = 1;
            return Asset;
        }());
        framework.Asset = Asset;
        __reflect(Asset.prototype, "egret3d.framework.Asset");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var sound;
    (function (sound) {
        var WebAudioChannel2D = (function () {
            function WebAudioChannel2D() {
                this._init();
            }
            WebAudioChannel2D.prototype._init = function () {
                var context = sound.WebAudio.instance.audioContext;
                this.source = context.createBufferSource();
                this.gain = context.createGain();
                this.source.connect(this.gain);
                this.gain.connect(context.destination);
            };
            Object.defineProperty(WebAudioChannel2D.prototype, "buffer", {
                set: function (buffer) {
                    this.source.buffer = buffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudioChannel2D.prototype, "volume", {
                get: function () {
                    return this.gain.gain.value;
                },
                set: function (value) {
                    value = Math.max(Math.min(value, 1), -0.999);
                    this.gain.gain.value = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudioChannel2D.prototype, "loop", {
                get: function () {
                    return this.source.loop;
                },
                set: function (value) {
                    this.source.loop = value;
                },
                enumerable: true,
                configurable: true
            });
            WebAudioChannel2D.prototype.start = function (offset) {
                this.source.start(undefined, offset || undefined);
            };
            WebAudioChannel2D.prototype.stop = function () {
                this.source.stop();
            };
            WebAudioChannel2D.prototype.dispose = function () {
                this.source.buffer = null;
            };
            return WebAudioChannel2D;
        }());
        sound.WebAudioChannel2D = WebAudioChannel2D;
        __reflect(WebAudioChannel2D.prototype, "egret3d.sound.WebAudioChannel2D");
    })(sound = egret3d.sound || (egret3d.sound = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Application = (function (_super) {
            __extends(Application, _super);
            function Application() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.version = "v1.0.0";
                _this.build = "b000000";
                _this._resizeDirty = true;
                _this._aspectRatio = 0;
                _this._pixelRatio = 1;
                _this.limitFrame = true;
                _this._tar = -1;
                _this._standDeltaTime = -1;
                _this.be2dstate = false;
                _this.curcameraindex = -1;
                _this._bePlay = false;
                _this._bePause = false;
                _this._beStepForward = false;
                _this.beStepNumber = 0;
                _this._userCode = [];
                _this._userCodeNew = [];
                _this._editorCode = [];
                _this._editorCodeNew = [];
                return _this;
            }
            Object.defineProperty(Application.prototype, "height", {
                get: function () {
                    return this._height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "width", {
                get: function () {
                    return this._width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "aspectRatio", {
                get: function () {
                    return this._aspectRatio;
                },
                set: function (value) {
                    this._aspectRatio = value;
                    this._resizeDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "pixelRatio", {
                get: function () {
                    return this._pixelRatio;
                },
                set: function (value) {
                    this._pixelRatio = value;
                    this._resizeDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "timeScale", {
                get: function () {
                    return this._timeScale;
                },
                set: function (val) {
                    this._timeScale = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "targetFrame", {
                get: function () {
                    return this._tar;
                },
                set: function (val) {
                    if (val == 0)
                        val = -1;
                    this._tar = val;
                    this._standDeltaTime = 1 / this._tar;
                },
                enumerable: true,
                configurable: true
            });
            Application.prototype.getScene = function () {
                return this._scene;
            };
            Object.defineProperty(Application.prototype, "inputManager", {
                get: function () {
                    return this._inputManager;
                },
                enumerable: true,
                configurable: true
            });
            Application.prototype.start = function (div, options) {
                var _this = this;
                if (options === void 0) { options = { antialias: false }; }
                console.log("version: " + this.version + ",  build: " + this.build);
                var canvas = document.createElement("canvas");
                div.appendChild(canvas);
                this.container = div;
                this.webgl = canvas.getContext('webgl', options) ||
                    canvas.getContext("experimental-webgl", options);
                egret3d.render.Webglkit.initConst(this.webgl);
                this._scene = new framework.Scene(this);
                framework.DefaultMeshes.init(this.webgl);
                framework.DefaultTextures.init(this.webgl);
                framework.DefaultShaders.init(this.webgl);
                this._inputManager = new framework.InputManager(this);
                this._timeScale = 1;
                this.beginTimer = this.lastTimer = this.pretimer = Date.now() / 1000;
                this.loop();
                egret3d.io.ReferenceInfo.regDefaultType();
                window.addEventListener("resize", function () { _this._resizeDirty = true; }, false);
            };
            Application.prototype.checkFilter = function (trans) {
                if (trans instanceof egret3d.framework.Transform) {
                    if (trans.gameObject.hideFlags & egret3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof egret3d.framework.Transform2D) {
                    if (trans.hideFlags & egret3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            };
            Application.prototype.showFps = function () {
                if (this.stats == null) {
                    this.stats = new Stats.Stats(this);
                    this.stats.container.style.position = 'absolute';
                    this.stats.container.style.left = '0px';
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            };
            Application.prototype.closeFps = function () {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            };
            Application.prototype.update = function (delta) {
                if (this._resizeDirty) {
                    this._resize();
                    this._resizeDirty = false;
                }
                if (this.bePlay) {
                    if (this.bePause) {
                        if (this.beStepForward && this.beStepNumber > 0) {
                            this.beStepNumber--;
                            this.updateUserCode(delta);
                        }
                    }
                    else {
                        this.updateUserCode(delta);
                    }
                }
                this.updateEditorCode(delta);
                this.dispatchEvent("beforeRender");
                if (this._scene != null) {
                    this._scene.update(delta);
                }
                this.dispatchEvent("afterRender");
                this._inputManager.update(delta);
            };
            Application.prototype._resize = function () {
                var screenWidth = window.innerWidth;
                var screenHeight = window.innerHeight;
                var x, y, width, height;
                if (this.aspectRatio > 0) {
                    var ratio = screenWidth / screenHeight;
                    if (ratio > this.aspectRatio) {
                        width = screenHeight * this.aspectRatio;
                        height = screenHeight;
                        x = (screenWidth - width) / 2;
                        y = 0;
                    }
                    else {
                        width = screenWidth;
                        height = screenWidth / this.aspectRatio;
                        x = 0;
                        y = (screenHeight - height) / 2;
                    }
                }
                else {
                    width = screenWidth;
                    height = screenHeight;
                    x = 0;
                    y = 0;
                }
                this.webgl.canvas.width = width * this._pixelRatio;
                this.webgl.canvas.height = height * this._pixelRatio;
                this.webgl.canvas.style.width = width + "px";
                this.webgl.canvas.style.height = height + "px";
                this.webgl.canvas.style.position = "absolute";
                this.webgl.canvas.style.left = x + "px";
                this.webgl.canvas.style.top = y + "px";
                this._width = width * this.pixelRatio;
                this._height = height * this.pixelRatio;
                this._inputManager.touch.updateOffsetAndScale(x, y, this._pixelRatio);
                this._inputManager.mouse.updateOffsetAndScale(x, y, this._pixelRatio);
                console.log("canvas resize -> width: " + width + ", height: " + height);
            };
            Application.prototype.getTotalTime = function () {
                return this.totalTime;
            };
            Object.defineProperty(Application.prototype, "deltaTime", {
                get: function () {
                    return this._deltaTime * this._timeScale;
                },
                enumerable: true,
                configurable: true
            });
            Application.prototype.getUpdateTimer = function () {
                return this.updateTimer;
            };
            Application.prototype.getUserUpdateTimer = function () {
                return 0;
            };
            Application.prototype.loop = function () {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.updateTimer = now - this.pretimer;
                if (this._deltaTime < this._standDeltaTime) {
                    var _this_1 = this;
                    var del = this._standDeltaTime - this._deltaTime;
                    setTimeout(function () {
                        var _now = Date.now() / 1000;
                        _this_1.lastTimer = _now;
                        _this_1.pretimer = _now;
                        _this_1.update(_this_1._standDeltaTime);
                        if (_this_1.stats != null)
                            _this_1.stats.update();
                        _this_1.loop();
                    }, del * 1000);
                }
                else {
                    this.update(this.deltaTime);
                    if (this.stats != null)
                        this.stats.update();
                    this.lastTimer = now;
                    this.pretimer = now;
                    if (this.limitFrame) {
                        requestAnimationFrame(this.loop.bind(this));
                    }
                    else {
                        setTimeout(this.loop.bind(this), 1);
                    }
                }
            };
            Object.defineProperty(Application.prototype, "bePlay", {
                get: function () {
                    return this._bePlay;
                },
                set: function (value) {
                    this._bePlay = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "bePause", {
                get: function () {
                    return this._bePause;
                },
                set: function (value) {
                    this._bePause = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Application.prototype, "beStepForward", {
                get: function () {
                    return this._beStepForward;
                },
                set: function (value) {
                    this._beStepForward = value;
                },
                enumerable: true,
                configurable: true
            });
            Application.prototype.addUserCodeDirect = function (program) {
                this._userCodeNew.push(program);
            };
            Application.prototype.addUserCode = function (classname) {
                var prototype = egret3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = egret3d.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            };
            Application.prototype.updateUserCode = function (delta) {
                for (var i = this._userCodeNew.length - 1; i >= 0; i--) {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++) {
                    var c = this._userCode[i];
                    if (c.isClosed() == false) {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0) {
                        closeindex = i;
                    }
                }
                if (closeindex >= 0) {
                    this._userCode.splice(closeindex, 1);
                }
            };
            Application.prototype.addEditorCode = function (classname) {
                var prototype = egret3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = egret3d.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            };
            Application.prototype.addEditorCodeDirect = function (program) {
                this._editorCodeNew.push(program);
            };
            Application.prototype.updateEditorCode = function (delta) {
                for (var i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    var c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = this._editorCode.length - 1; i >= 0; i--) {
                    var c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            };
            return Application;
        }(framework.EventDispatcher));
        framework.Application = Application;
        __reflect(Application.prototype, "egret3d.framework.Application");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    egret3d.licence = "xxxxxxx";
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var Stats = (function () {
        function Stats(app) {
            var _this = this;
            this.mode = 0;
            this.app = app;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.ratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            this.userratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            this.beginTime = this.end();
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        Stats.prototype.begin = function () {
            this.beginTime = (performance || Date).now();
        };
        Stats.prototype.end = function () {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                var fps = (this.frames * 1000) / (time - this.prevTime);
                this.fpsPanel.update(fps, 100);
                this.ratePanel.update(this.app.getUpdateTimer() * this.frames / 10, 100);
                this.userratePanel.update(this.app.getUserUpdateTimer() * this.frames / 10, 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        };
        return Stats;
    }());
    Stats_1.Stats = Stats;
    __reflect(Stats.prototype, "Stats.Stats");
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Canvas = (function () {
            function Canvas() {
                this.is2dUI = true;
                this.pointDown = false;
                this.pointSelect = null;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.pixelWidth = 640;
                this.pixelHeight = 480;
                this.rootNode = new framework.Transform2D();
                this.rootNode.canvas = this;
            }
            Canvas.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            Canvas.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            Canvas.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            Canvas.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            Canvas.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            Canvas.prototype.update = function (delta, touch, XOnScreenSpace, YOnScreenSpace) {
                var asp = this.pixelWidth / this.pixelHeight;
                this.rootNode.localScale.x = 2 / this.pixelWidth;
                this.rootNode.localScale.y = -2 / this.pixelHeight;
                this.rootNode.localTranslate.y = 1;
                this.rootNode.localTranslate.x = -1;
                this.rootNode.width = this.pixelWidth;
                this.rootNode.height = this.pixelHeight;
                this.rootNode.pivot.x = 0;
                this.rootNode.pivot.y = 0;
                this.rootNode.updateTran(false);
                this.pointEvent.eated = false;
                this.pointEvent.x = XOnScreenSpace;
                this.pointEvent.y = YOnScreenSpace;
                this.pointEvent.selected = this.pointSelect;
                var skip = false;
                if (this.pointDown == false && touch == false) {
                    skip = true;
                }
                else if (this.pointDown == false && touch == true) {
                    this.pointEvent.type = framework.PointEventEnum.PointDown;
                }
                else if (this.pointDown == true && touch == true) {
                    this.pointEvent.type = framework.PointEventEnum.PointHold;
                    if (this.pointX == this.pointEvent.x && this.pointY == this.pointEvent.y) {
                        skip = true;
                    }
                }
                else if (this.pointDown == true && touch == false) {
                    this.pointEvent.type = framework.PointEventEnum.PointUp;
                }
                if (!skip) {
                    this.rootNode.onCapturePointEvent(this, this.pointEvent);
                    this.rootNode.onPointEvent(this, this.pointEvent);
                    this.pointSelect = this.pointEvent.selected;
                    this.pointDown = touch;
                    this.pointX = this.pointEvent.x;
                    this.pointY = this.pointEvent.y;
                }
                this.rootNode.update(delta);
            };
            Canvas.prototype.render = function (context) {
                this.context = context;
                this.lastMat = null;
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new framework.Batcher2D();
                    var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0 | egret3d.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, egret3d.render.DrawModeEnum.VboTri);
                }
                this.drawScene(this.rootNode, context);
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            };
            Canvas.prototype.pushRawData = function (mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    var pass = this.lastMat.getShader().passes["base"][this.is2dUI ? 0 : 1];
                    var program = pass.program;
                    var force = pass.use(this.webgl);
                    program.uploadUniforms(mat, this.context, force);
                    this.batcher.begin(this.webgl, pass);
                }
                this.batcher.push(this.webgl, data, null);
            };
            Canvas.prototype.drawScene = function (node, context) {
                if (node.renderer != null) {
                    node.renderer.render(this);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context);
                    }
                }
            };
            Canvas.prototype.getRoot = function () {
                if (this.rootNode == null) {
                    this.rootNode = new framework.Transform2D();
                    this.rootNode.canvas = this;
                }
                return this.rootNode;
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Canvas.prototype, "pixelWidth", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Canvas.prototype, "pixelHeight", void 0);
            __decorate([
                egret3d.reflect.Field("Transform2D"),
                __metadata("design:type", framework.Transform2D)
            ], Canvas.prototype, "rootNode", void 0);
            Canvas = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Canvas);
            return Canvas;
        }());
        framework.Canvas = Canvas;
        __reflect(Canvas.prototype, "egret3d.framework.Canvas");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Batcher2D = (function () {
            function Batcher2D() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            Batcher2D.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new egret3d.render.GlMesh();
                this.mesh.initBuffer(webgl, vf, 128, egret3d.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == egret3d.render.DrawModeEnum.EboLine || drawMode == egret3d.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            Batcher2D.prototype.begin = function (webgl, pass) {
                if (this.vboCount > 0) {
                    this.end(webgl);
                }
                this.curPass = pass;
            };
            Batcher2D.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048 || (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == egret3d.render.DrawModeEnum.VboLine || this.drawMode == egret3d.render.DrawModeEnum.VboTri) {
                    return;
                }
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            Batcher2D.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexSubData(webgl, this.dataForVbo.slice(0, this.vboCount), 0);
                if (this.eboCount > 0) {
                    this.mesh.uploadIndexSubData(webgl, 0, this.dataForEbo.slice(0, this.eboCount), 0);
                }
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                var bindEbo = (this.drawMode == egret3d.render.DrawModeEnum.EboLine || this.drawMode == egret3d.render.DrawModeEnum.EboTri) ? 0 : -1;
                this.curPass.program.bindAttributes(this.mesh, bindEbo, true);
                if (this.drawMode == egret3d.render.DrawModeEnum.EboLine) {
                    egret3d.render.Webglkit.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == egret3d.render.DrawModeEnum.EboTri) {
                    egret3d.render.Webglkit.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == egret3d.render.DrawModeEnum.VboLine) {
                    egret3d.render.Webglkit.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == egret3d.render.DrawModeEnum.VboTri) {
                    egret3d.render.Webglkit.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return Batcher2D;
        }());
        framework.Batcher2D = Batcher2D;
        __reflect(Batcher2D.prototype, "egret3d.framework.Batcher2D");
        var CanvasRenderer = (function () {
            function CanvasRenderer() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.UI;
                this.renderLayer = framework.CullingMask.Default;
                this.queue = 0;
                this.canvas = new framework.Canvas();
                this.canvas.is2dUI = false;
            }
            CanvasRenderer.prototype.getBound = function () {
                return null;
            };
            CanvasRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            CanvasRenderer.prototype.setSize = function (width, height) {
                this.canvas.pixelWidth = width;
                this.canvas.pixelHeight = height;
            };
            CanvasRenderer.prototype.start = function () {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
            };
            CanvasRenderer.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            CanvasRenderer.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            CanvasRenderer.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            CanvasRenderer.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            CanvasRenderer.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            CanvasRenderer.prototype.update = function (delta) {
                var asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                var scale = this.gameObject.transform.getLocalScale();
                this.gameObject.transform.setLocalScale(scale.y * asp, scale.y, scale.z);
                if (this.cameraTouch != null) {
                    var scene = this.gameObject.getScene();
                    var inputManager = scene.app.inputManager;
                    var touchPoint = inputManager.getTouchPoint();
                    var ray = this.cameraTouch.creatRayByScreen(touchPoint, scene.app);
                    var pinfo = scene.pick(ray);
                    if (pinfo != null && pinfo.pickedtran == this.gameObject.transform) {
                        var mat = this.gameObject.transform.getWorldMatrix();
                        var matinv = new egret3d.math.Matrix();
                        egret3d.math.matrixInverse(mat, matinv);
                        var outv = new egret3d.math.Vector3();
                        egret3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                        this.canvas.update(delta, inputManager.isPressed() || inputManager.wasPressed(), outv.x, outv.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            };
            CanvasRenderer.prototype.pick2d = function (ray) {
                var pinfo = ray.intersectPlaneTransform(this.gameObject.transform);
                if (pinfo != null) {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = egret3d.math.Pool.new_matrix();
                    egret3d.math.matrixInverse(mat, matinv);
                    var outv = egret3d.math.Pool.new_vector3();
                    egret3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                    var outv2 = egret3d.math.Pool.new_vector2();
                    outv2.x = outv.x;
                    outv2.y = outv.y;
                    var root = this.canvas.getRoot();
                    return this.dopick2d(outv2, root);
                }
                return null;
            };
            CanvasRenderer.prototype.dopick2d = function (outv, tran) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            CanvasRenderer.prototype.render = function (context, camera) {
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context);
            };
            CanvasRenderer.prototype.jsonToAttribute = function (json) {
            };
            CanvasRenderer.prototype.remove = function () {
            };
            CanvasRenderer.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("Canvas"),
                __metadata("design:type", framework.Canvas)
            ], CanvasRenderer.prototype, "canvas", void 0);
            CanvasRenderer = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeCanvasRendererCollider,
                __metadata("design:paramtypes", [])
            ], CanvasRenderer);
            return CanvasRenderer;
        }());
        framework.CanvasRenderer = CanvasRenderer;
        __reflect(CanvasRenderer.prototype, "egret3d.framework.CanvasRenderer", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent", "egret3d.framework.ICollider"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointNothing"] = 0] = "PointNothing";
            PointEventEnum[PointEventEnum["PointDown"] = 1] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 2] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 3] = "PointUp";
        })(PointEventEnum = framework.PointEventEnum || (framework.PointEventEnum = {}));
        var PointEvent = (function () {
            function PointEvent() {
            }
            return PointEvent;
        }());
        framework.PointEvent = PointEvent;
        __reflect(PointEvent.prototype, "egret3d.framework.PointEvent");
        var UIEvent = (function () {
            function UIEvent() {
                this.funcs = [];
            }
            UIEvent.prototype.addListener = function (func) {
                this.funcs.push(func);
            };
            UIEvent.prototype.excute = function () {
                for (var key in this.funcs) {
                    this.funcs[key]();
                }
            };
            UIEvent.prototype.clear = function () {
                this.funcs.length = 0;
            };
            return UIEvent;
        }());
        framework.UIEvent = UIEvent;
        __reflect(UIEvent.prototype, "egret3d.framework.UIEvent");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret;
(function (egret) {
    var web;
    (function (web) {
        var Renderer = (function () {
            function Renderer(context, app) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance();
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities.$renderMode = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                app.addEventListener("beforeRender", function () {
                    egret.ticker.update();
                }, this);
            }
            Renderer.getInstance = function (context, app) {
                if (!this._instance) {
                    this._instance = new Renderer(context, app);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                gl.activeTexture(gl.TEXTURE0);
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    offset = this.drawData(data, offset);
                    if (data.type == 6) {
                        this.activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 || data.type == 1 || data.type == 2) {
                        if (this.activatedBuffer && this.activatedBuffer.$computeDrawCall) {
                            this.activatedBuffer.$drawCalls++;
                        }
                    }
                }
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3:
                        this.setBlendMode(data.value);
                        break;
                    case 4:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5:
                        if (this.activatedBuffer) {
                            var target = this.activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6:
                        this.activateBuffer(data.buffer);
                        break;
                    case 7:
                        var buffer = this.activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8:
                        buffer = this.activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                gl.useProgram(program.id);
                var attribute = program.attributes;
                for (var key in attribute) {
                    if (key === "aVertexPosition") {
                        gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 5 * 4, 0);
                        gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                    }
                    else if (key === "aTextureCoord") {
                        gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.FLOAT, false, 5 * 4, 2 * 4);
                        gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                    }
                    else if (key === "aColor") {
                        gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 5 * 4, 4 * 4);
                        gl.enableVertexAttribArray(attribute["aColor"].location);
                    }
                }
                this.currentProgram = program;
            };
            Renderer.prototype.syncUniforms = function (program, filter, textureWidth, textureHeight) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: textureWidth, y: textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                        }
                    }
                }
            };
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                gl.bindTexture(gl.TEXTURE_2D, data.texture);
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            Renderer.prototype.activateBuffer = function (buffer) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(buffer.width, buffer.height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT);
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil();
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var tempRect = new egret3d.math.Rect();
        var SCREEN_MATCH_MODE;
        (function (SCREEN_MATCH_MODE) {
            SCREEN_MATCH_MODE[SCREEN_MATCH_MODE["CONSTANT"] = 0] = "CONSTANT";
            SCREEN_MATCH_MODE[SCREEN_MATCH_MODE["SHRINK"] = 1] = "SHRINK";
            SCREEN_MATCH_MODE[SCREEN_MATCH_MODE["EXPAND"] = 2] = "EXPAND";
        })(SCREEN_MATCH_MODE = framework.SCREEN_MATCH_MODE || (framework.SCREEN_MATCH_MODE = {}));
        var Overlay2D = (function () {
            function Overlay2D() {
                this.init = false;
                this._screenAdaptDirty = true;
                this._scaleFactor = 1;
                this._resolution = new egret3d.math.Vector2(300, 400);
                this._screenMatchMode = SCREEN_MATCH_MODE.CONSTANT;
                this._renderViewport = new egret3d.math.Rect();
                this._viewport = new egret3d.math.Vector4();
                this.autoAsp = true;
                this.canvas = new framework.Canvas();
            }
            Object.defineProperty(Overlay2D.prototype, "scaleFactor", {
                get: function () {
                    return this._scaleFactor;
                },
                set: function (value) {
                    if (this._scaleFactor != value) {
                        this._scaleFactor = value;
                        this._screenAdaptDirty = true;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Overlay2D.prototype.setResolutionSize = function (width, height) {
                if (this._resolution.x != width || this._resolution.y != height) {
                    this._resolution.x = width;
                    this._resolution.y = height;
                    this._screenAdaptDirty = true;
                }
            };
            Overlay2D.prototype.setScreenMatchMode = function (value) {
                if (this._screenMatchMode != value) {
                    this._screenMatchMode = value;
                    this._screenAdaptDirty = true;
                }
            };
            Overlay2D.prototype.setRenderViewport = function (x, y, width, height) {
                if (this._renderViewport.x != x || this._renderViewport.y != y || this._renderViewport.w != width || this._renderViewport.h != height) {
                    this._renderViewport.x = x;
                    this._renderViewport.y = y;
                    this._renderViewport.w = width;
                    this._renderViewport.h = height;
                    this._screenAdaptDirty = true;
                }
            };
            Overlay2D.prototype._calculateScreenAdapt = function () {
                switch (this._screenMatchMode) {
                    case SCREEN_MATCH_MODE.CONSTANT: {
                        this.canvas.pixelWidth = this._renderViewport.w / this._scaleFactor;
                        this.canvas.pixelHeight = this._renderViewport.h / this._scaleFactor;
                        this._viewport.x = this._renderViewport.x;
                        this._viewport.y = this._renderViewport.y;
                        this._viewport.z = this._renderViewport.w;
                        this._viewport.w = this._renderViewport.h;
                        break;
                    }
                    case SCREEN_MATCH_MODE.SHRINK: {
                        var renderViewport = this._renderViewport;
                        var curViewX = renderViewport.x;
                        var curViewY = renderViewport.y;
                        var curViewW = renderViewport.w;
                        var curViewH = renderViewport.h;
                        var resolutionSize = this._resolution;
                        var screenRate = (curViewW - curViewX) / (curViewH - curViewY);
                        var resolutionRate = resolutionSize.x / resolutionSize.y;
                        var widthBigger = resolutionRate > screenRate;
                        var resultX = void 0, resultY = void 0, resultW = void 0, resultH = void 0;
                        if (widthBigger) {
                            resultW = curViewW;
                            resultH = Math.floor(resultW / resolutionRate);
                        }
                        else {
                            resultH = curViewH;
                            resultW = Math.floor(resultH * resolutionRate);
                        }
                        resultX = Math.floor((curViewW - resultW) / 2) + curViewX;
                        resultY = Math.floor((curViewH - resultH) / 2) + curViewY;
                        this._viewport.x = resultX;
                        this._viewport.y = resultY;
                        this._viewport.z = resultW;
                        this._viewport.w = resultH;
                        this.canvas.pixelWidth = resolutionSize.x;
                        this.canvas.pixelHeight = resolutionSize.y;
                        break;
                    }
                    case SCREEN_MATCH_MODE.EXPAND: {
                        var renderViewport = this._renderViewport;
                        var curViewX = renderViewport.x;
                        var curViewY = renderViewport.y;
                        var curViewW = renderViewport.w;
                        var curViewH = renderViewport.h;
                        var resolutionSize = this._resolution;
                        var screenRate = (curViewW - curViewX) / (curViewH - curViewY);
                        var resolutionRate = resolutionSize.x / resolutionSize.y;
                        var widthBigger = resolutionRate > screenRate;
                        var resultX = void 0, resultY = void 0, resultW = void 0, resultH = void 0;
                        if (widthBigger) {
                            resultH = curViewH;
                            resultW = Math.floor(resultH * resolutionRate);
                        }
                        else {
                            resultW = curViewW;
                            resultH = Math.floor(resultW / resolutionRate);
                        }
                        resultX = Math.floor((curViewW - resultW) / 2) + curViewX;
                        resultY = Math.floor((curViewH - resultH) / 2) + curViewY;
                        this._viewport.x = resultX;
                        this._viewport.y = resultY;
                        this._viewport.z = resultW;
                        this._viewport.w = resultH;
                        this.canvas.pixelWidth = resolutionSize.x;
                        this.canvas.pixelHeight = resolutionSize.y;
                        break;
                    }
                }
                this._screenAdaptDirty = false;
            };
            Overlay2D.prototype.start = function (camera) {
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                this.canvas.scene = camera.gameObject.getScene();
            };
            Overlay2D.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            Overlay2D.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            Overlay2D.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            Overlay2D.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            Overlay2D.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            Overlay2D.prototype.render = function (context, camera) {
                if (!this.canvas.getRoot().visible)
                    return;
                if (this.camera == null || this.camera == undefined) {
                    return;
                }
                context.updateOverlay();
                context.webgl.viewport(this._viewport.x, this._viewport.y, this._viewport.z, this._viewport.w);
                this.canvas.render(context);
            };
            Overlay2D.prototype.update = function (delta) {
                var inputManager = this.app.inputManager;
                var touchPoint = inputManager.getTouchPoint();
                this.camera.calcViewPortPixel(this.app, tempRect);
                this.setRenderViewport(tempRect.x, tempRect.y, tempRect.w, tempRect.h);
                if (this._screenAdaptDirty) {
                    this._calculateScreenAdapt();
                    this.canvas.getRoot().markDirty();
                }
                var sx = ((touchPoint.x - this._viewport.x) / this._viewport.z) * 2 - 1;
                var sy = ((touchPoint.y - this._viewport.y) / this._viewport.w) * -2 + 1;
                this.canvas.update(delta, inputManager.isPressed() || inputManager.wasPressed(), sx, sy);
            };
            Overlay2D.prototype.pick2d = function (mx, my) {
                if (this.camera == null)
                    return null;
                var vp = new egret3d.math.Rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (mx / vp.w) * 2 - 1;
                var sy = (my / vp.h) * -2 + 1;
                var outv2 = egret3d.math.Pool.new_vector2();
                outv2.x = sx;
                outv2.y = sy;
                var root = this.canvas.getRoot();
                return this.dopick2d(outv2, root);
            };
            Overlay2D.prototype.dopick2d = function (outv, tran) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            Overlay2D.prototype.calScreenPosToCanvasPos = function (mousePos, canvasPos) {
                var vp = new egret3d.math.Rect();
                this.camera.calcViewPortPixel(this.app, vp);
                var temt = egret3d.math.Pool.new_vector2();
                temt.x = (mousePos.x / vp.w) * 2 - 1;
                temt.y = (mousePos.y / vp.h) * -2 + 1;
                var mat = egret3d.math.Pool.new_matrix3x2();
                egret3d.math.matrix3x2Clone(this.canvas.getRoot().getWorldMatrix(), mat);
                egret3d.math.matrix3x2Inverse(mat, mat);
                egret3d.math.matrix3x2TransformVector2(mat, temt, canvasPos);
                egret3d.math.Pool.delete_vector2(temt);
            };
            __decorate([
                egret3d.reflect.Field("Canvas"),
                __metadata("design:type", framework.Canvas)
            ], Overlay2D.prototype, "canvas", void 0);
            __decorate([
                egret3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], Overlay2D.prototype, "autoAsp", void 0);
            Overlay2D = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Overlay2D);
            return Overlay2D;
        }());
        framework.Overlay2D = Overlay2D;
        __reflect(Overlay2D.prototype, "egret3d.framework.Overlay2D", ["egret3d.framework.IOverLay"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var C2DComponent = (function () {
            function C2DComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            __decorate([
                egret3d.reflect.Field("I2DComponent"),
                __metadata("design:type", Object)
            ], C2DComponent.prototype, "comp", void 0);
            C2DComponent = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], C2DComponent);
            return C2DComponent;
        }());
        framework.C2DComponent = C2DComponent;
        __reflect(C2DComponent.prototype, "egret3d.framework.C2DComponent");
        var Transform2D = (function () {
            function Transform2D() {
                this.name = "noname";
                this.pivot = new egret3d.math.Vector2(0, 0);
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                this.insId = new framework.InsID();
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localTranslate = new egret3d.math.Vector2(0, 0);
                this.localScale = new egret3d.math.Vector2(1, 1);
                this.localRotate = 0;
                this.localMatrix = new egret3d.math.Matrix3x2();
                this.worldMatrix = new egret3d.math.Matrix3x2();
                this.worldRotate = new egret3d.math.Angelref();
                this.worldTranslate = new egret3d.math.Vector2(0, 0);
                this.worldScale = new egret3d.math.Vector2(1, 1);
                this.components = [];
            }
            Object.defineProperty(Transform2D.prototype, "canvas", {
                get: function () {
                    if (this._canvas == null) {
                        if (this.parent == null) {
                            return null;
                        }
                        else {
                            return this.parent.canvas;
                        }
                    }
                    return this._canvas;
                },
                set: function (val) {
                    this._canvas = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform2D.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible) {
                        obj = obj.parent;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform2D.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform2D.prototype, "transform", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });
            Transform2D.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null) {
                    this.children = [];
                }
                this.children.push(node);
                node.parent = this;
                node.canvas = this.canvas;
            };
            Transform2D.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null) {
                    this.children = [];
                }
                this.children.splice(index, 0, node);
                node.canvas = this.canvas;
                node.parent = this;
            };
            Transform2D.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                }
            };
            Transform2D.prototype.removeAllChild = function () {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            Transform2D.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            Transform2D.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false) {
                    return;
                }
                if (this.dirty) {
                    egret3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.parent == null) {
                        egret3d.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        egret3d.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                    this.dirtyWorldDecompose = true;
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            };
            Transform2D.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty) {
                        dirtylist.push(p);
                    }
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            Transform2D.prototype.getWorldTranslate = function () {
                if (this.dirtyWorldDecompose) {
                    egret3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldTranslate;
            };
            Transform2D.prototype.getWorldScale = function () {
                if (this.dirtyWorldDecompose) {
                    egret3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldScale;
            };
            Transform2D.prototype.getWorldRotate = function () {
                if (this.dirtyWorldDecompose) {
                    egret3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldRotate;
            };
            Transform2D.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            Transform2D.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            Transform2D.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = egret3d.math.Pool.new_vector2();
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = egret3d.math.Pool.new_matrix3x2();
                if (this.parent != null) {
                    egret3d.math.matrix3x2Clone(this.parent.worldMatrix, pworld);
                }
                else {
                    egret3d.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = egret3d.math.Pool.new_matrix3x2();
                egret3d.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = egret3d.math.Pool.new_vector2();
                egret3d.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                egret3d.math.Pool.delete_matrix3x2(matinv);
                egret3d.math.Pool.delete_vector2(dir);
                egret3d.math.Pool.delete_vector2(dirinv);
            };
            Transform2D.prototype.dispose = function () {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
            };
            Transform2D.prototype.update = function (delta) {
                if (this.components != null) {
                    for (var i = 0; i < this.components.length; i++) {
                        if (this.components[i].init == false) {
                            this.components[i].comp.start();
                            this.components[i].init = true;
                        }
                        this.components[i].comp.update(delta);
                    }
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].update(delta);
                    }
                }
            };
            Transform2D.prototype.addComponent = function (type) {
                if (this.components == null) {
                    this.components = [];
                }
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("try to add a " + type + " component but already has one!");
                    }
                }
                var pp = egret3d.reflect.getPrototype(type);
                var comp = egret3d.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            };
            Transform2D.prototype.addComponentDirect = function (comp) {
                if (comp.transform != null) {
                    throw new Error("try to add a component which has added to another game object!");
                }
                comp.transform = this;
                if (this.components == null) {
                    this.components = [];
                }
                var _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                if (egret3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        throw new Error("cannot add more than one render component");
                    }
                }
                return comp;
            };
            Transform2D.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                        }
                        this.components.splice(i, 1);
                    }
                }
            };
            Transform2D.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (egret3d.reflect.getClassName(this.components[i].comp) == type) {
                        var p = this.components.splice(i, 1);
                        if (p[0].comp == this.renderer)
                            this.renderer = null;
                        return p[0];
                    }
                }
            };
            Transform2D.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.remove();
                    if (this.components[i].comp == this.renderer)
                        this.renderer = null;
                }
                this.components.length = 0;
            };
            Transform2D.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = egret3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            Transform2D.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            Transform2D.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            };
            Transform2D.prototype.getNodeCompoents = function (node, _type, comps) {
                for (var i in node.components) {
                    var cname = egret3d.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(this.components[i].comp);
                    }
                }
                if (node.children != null) {
                    for (var i in node.children) {
                        this.getNodeCompoents(node.children[i], _type, comps);
                    }
                }
            };
            Transform2D.prototype.onCapturePointEvent = function (canvas, ev) {
                if (this.components != null) {
                    for (var i = 0; i <= this.components.length; i++) {
                        if (ev.eated == false) {
                            var comp = this.components[i];
                            if (comp != null) {
                                if (comp.init) {
                                    comp.comp.onPointEvent(canvas, ev, true);
                                }
                            }
                        }
                    }
                }
                if (ev.eated == false) {
                    if (this.children != null) {
                        for (var i = 0; i <= this.children.length; i++) {
                            var c = this.children[i];
                            if (c != null) {
                                c.onCapturePointEvent(canvas, ev);
                            }
                        }
                    }
                }
            };
            Transform2D.prototype.ContainsCanvasPoint = function (pworld) {
                var mworld = this.getWorldMatrix();
                var mout = new egret3d.math.Matrix3x2();
                egret3d.math.matrix3x2Inverse(mworld, mout);
                var p2 = new egret3d.math.Vector2();
                egret3d.math.matrix3x2TransformVector2(mout, pworld, p2);
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                return p2.x >= 0 && p2.y >= 0 && p2.x < this.width && p2.y < this.height;
            };
            Transform2D.prototype.onPointEvent = function (canvas, ev) {
                if (this.children != null) {
                    for (var i = this.children.length - 1; i >= 0; i--) {
                        if (ev.eated == false) {
                            var c = this.children[i];
                            if (c != null) {
                                c.onPointEvent(canvas, ev);
                            }
                            if (ev.eated) {
                            }
                        }
                    }
                }
                if (ev.eated == false && this.components != null) {
                    for (var i = this.components.length - 1; i >= 0; i--) {
                        var comp = this.components[i];
                        if (comp != null) {
                            if (comp.init) {
                                comp.comp.onPointEvent(canvas, ev, false);
                            }
                        }
                    }
                }
            };
            __decorate([
                egret3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], Transform2D.prototype, "name", void 0);
            __decorate([
                egret3d.reflect.Field("Transform2D[]"),
                __metadata("design:type", Array)
            ], Transform2D.prototype, "children", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Transform2D.prototype, "width", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Transform2D.prototype, "height", void 0);
            __decorate([
                egret3d.reflect.Field("vector2"),
                __metadata("design:type", egret3d.math.Vector2)
            ], Transform2D.prototype, "pivot", void 0);
            __decorate([
                egret3d.reflect.Field("vector2"),
                __metadata("design:type", egret3d.math.Vector2)
            ], Transform2D.prototype, "localTranslate", void 0);
            __decorate([
                egret3d.reflect.Field("vector2"),
                __metadata("design:type", egret3d.math.Vector2)
            ], Transform2D.prototype, "localScale", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], Transform2D.prototype, "localRotate", void 0);
            __decorate([
                egret3d.reflect.Field("C2DComponent[]"),
                __metadata("design:type", Array)
            ], Transform2D.prototype, "components", void 0);
            Transform2D = __decorate([
                egret3d.reflect.SerializeType
            ], Transform2D);
            return Transform2D;
        }());
        framework.Transform2D = Transform2D;
        __reflect(Transform2D.prototype, "egret3d.framework.Transform2D");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        var Button = (function () {
            function Button() {
                this._transition = TransitionType.ColorTint;
                this._normalColor = new egret3d.math.Color(1, 1, 1, 1);
                this._pressedColor = new egret3d.math.Color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.onClick = new framework.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            Object.defineProperty(Button.prototype, "transition", {
                get: function () {
                    return this._transition;
                },
                set: function (transition) {
                    this._transition = transition;
                    if (this._targetImage != null) {
                        if (transition == TransitionType.ColorTint) {
                            this._targetImage.color = this.normalColor;
                        }
                        else {
                            this._targetImage.color = this._originalColor;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "targetImage", {
                get: function () {
                    return this._targetImage;
                },
                set: function (graphic) {
                    if (this._targetImage != null) {
                        this._targetImage.color = this._originalColor;
                    }
                    if (graphic != null) {
                        this._originalColor = graphic.color;
                        this._originalSprite = graphic.sprite;
                        if (this._transition = TransitionType.ColorTint) {
                            graphic.color = this.normalColor;
                        }
                    }
                    else {
                        this._originalColor = null;
                        this._originalSprite = null;
                    }
                    this._targetImage = graphic;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "pressedGraphic", {
                get: function () {
                    return this._pressedSprite;
                },
                set: function (sprite) {
                    this._pressedSprite = sprite;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "normalColor", {
                get: function () {
                    return this._normalColor;
                },
                set: function (color) {
                    this._normalColor = color;
                    if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                        this._targetImage.color = color;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "pressedColor", {
                get: function () {
                    return this._pressedColor;
                },
                set: function (color) {
                    this._pressedColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "fadeDuration", {
                get: function () {
                    return this._fadeDuration;
                },
                set: function (duration) {
                    this._fadeDuration = duration;
                },
                enumerable: true,
                configurable: true
            });
            Button.prototype.start = function () {
            };
            Button.prototype.update = function (delta) {
            };
            Button.prototype.remove = function () {
            };
            Button.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new egret3d.math.Vector2(ev.x, ev.y));
                    if (b) {
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                        }
                        else if (ev.type == framework.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            this.onClick.excute();
                        }
                    }
                    else {
                        if (ev.type == framework.PointEventEnum.PointUp) {
                            this._downInThis = false;
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                }
            };
            Button.prototype.showNormal = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    this.changeSprite(this._originalSprite);
                }
            };
            Button.prototype.showPress = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    this.changeSprite(this._pressedSprite);
                }
            };
            Button.prototype.changeColor = function (targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            };
            Button.prototype.changeSprite = function (sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            };
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], Button.prototype, "transition", null);
            __decorate([
                egret3d.reflect.Field("Color"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [egret3d.math.Color])
            ], Button.prototype, "normalColor", null);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], Button.prototype, "fadeDuration", null);
            Button = __decorate([
                egret3d.reflect.node2DComponent
            ], Button);
            return Button;
        }());
        framework.Button = Button;
        __reflect(Button.prototype, "egret3d.framework.Button", ["egret3d.framework.I2DComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled";
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        var FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
        var Image2D = (function () {
            function Image2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.color = new egret3d.math.Color(1.0, 1.0, 1.0, 1.0);
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                egret3d.io.EnumMgr.enumMap["ImageType"] = ImageType;
                egret3d.io.EnumMgr.enumMap["FillMethod"] = FillMethod;
            }
            Object.defineProperty(Image2D.prototype, "imageType", {
                get: function () {
                    return this._imageType;
                },
                set: function (type) {
                    this._imageType = type;
                    this.prepareData();
                    if (this.transform != null) {
                        this.transform.markDirty();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Image2D.prototype, "fillMethod", {
                get: function () {
                    return this._fillMethod;
                },
                set: function (method) {
                    this._fillMethod = method;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Image2D.prototype, "fillAmmount", {
                get: function () {
                    return this._fillAmmount;
                },
                set: function (ammount) {
                    this._fillAmmount = ammount;
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Image2D.prototype.setTexture = function (texture, border, rect) {
                var _sprite = new framework.Sprite();
                _sprite.texture = texture;
                if (border != null) {
                    _sprite.border = border;
                }
                else {
                    _sprite.border = new egret3d.math.Border(0, 0, 0, 0);
                }
                if (rect != null) {
                    _sprite.rect = rect;
                }
                else {
                    _sprite.rect = new egret3d.math.Rect(0, 0, texture.glTexture.width, texture.glTexture.height);
                }
                this.sprite = _sprite;
            };
            Object.defineProperty(Image2D.prototype, "sprite", {
                get: function () {
                    return this._sprite;
                },
                set: function (_sprite) {
                    if (this._sprite) {
                        this._sprite.unuse();
                    }
                    this._sprite = _sprite;
                    this._sprite.use();
                    this.prepareData();
                    if (this.transform != null) {
                        this.transform.markDirty();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Image2D.prototype.render = function (canvas) {
                if (this.mat == null) {
                    this.mat = new framework.Material();
                    this.mat.setShader(framework.DefaultShaders.UI);
                }
                var img = null;
                if (this._sprite != null && this._sprite.texture != null) {
                    img = this._sprite.texture;
                }
                this.mat.setTexture("_MainTex", img);
                canvas.pushRawData(this.mat, this.datar);
            };
            Image2D.prototype.start = function () {
            };
            Image2D.prototype.update = function (delta) {
            };
            Image2D.prototype.remove = function () {
                this._sprite.unuse(true);
                this.datar.length = 0;
            };
            Image2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            Image2D.prototype.prepareData = function () {
                if (this._sprite == null)
                    return;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [];
                        break;
                    case ImageType.Filled:
                        var halfu = urange.x + 0.5 * ulen;
                        var halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            };
            Image2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                var vertexCount = this.datar.length / 13;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            };
            Image2D.prototype.updateQuadData = function (x0, y0, x1, y1, x2, y2, x3, y3, quadIndex, mirror) {
                if (quadIndex === void 0) { quadIndex = 0; }
                if (mirror === void 0) { mirror = false; }
                var _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * 13] = x0;
                    this.datar[(_index + 0) * 13 + 1] = y0;
                    this.datar[(_index + 1) * 13] = x1;
                    this.datar[(_index + 1) * 13 + 1] = y1;
                    this.datar[(_index + 2) * 13] = x2;
                    this.datar[(_index + 2) * 13 + 1] = y2;
                    this.datar[(_index + 3) * 13] = x2;
                    this.datar[(_index + 3) * 13 + 1] = y2;
                    this.datar[(_index + 4) * 13] = x1;
                    this.datar[(_index + 4) * 13 + 1] = y1;
                    this.datar[(_index + 5) * 13] = x3;
                    this.datar[(_index + 5) * 13 + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * 13] = x0;
                    this.datar[(_index + 0) * 13 + 1] = y0;
                    this.datar[(_index + 1) * 13] = x1;
                    this.datar[(_index + 1) * 13 + 1] = y1;
                    this.datar[(_index + 2) * 13] = x3;
                    this.datar[(_index + 2) * 13 + 1] = y3;
                    this.datar[(_index + 3) * 13] = x0;
                    this.datar[(_index + 3) * 13 + 1] = y0;
                    this.datar[(_index + 4) * 13] = x3;
                    this.datar[(_index + 4) * 13 + 1] = y3;
                    this.datar[(_index + 5) * 13] = x2;
                    this.datar[(_index + 5) * 13 + 1] = y2;
                }
            };
            Image2D.prototype.updateSimpleData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            };
            Image2D.prototype.updateSlicedData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var border = this._sprite.border;
                var rect = this._sprite.rect;
                var r1c1 = egret3d.math.Pool.new_vector2();
                var r1c4 = egret3d.math.Pool.new_vector2();
                var r4c1 = egret3d.math.Pool.new_vector2();
                var r4c4 = egret3d.math.Pool.new_vector2();
                var r1c2 = egret3d.math.Pool.new_vector2();
                var r1c3 = egret3d.math.Pool.new_vector2();
                var r2c1 = egret3d.math.Pool.new_vector2();
                var r3c1 = egret3d.math.Pool.new_vector2();
                var r2c2 = egret3d.math.Pool.new_vector2();
                var r2c3 = egret3d.math.Pool.new_vector2();
                var r2c4 = egret3d.math.Pool.new_vector2();
                var r3c2 = egret3d.math.Pool.new_vector2();
                var r3c3 = egret3d.math.Pool.new_vector2();
                var r3c4 = egret3d.math.Pool.new_vector2();
                var r4c2 = egret3d.math.Pool.new_vector2();
                var r4c3 = egret3d.math.Pool.new_vector2();
                var r1c1_uv = egret3d.math.Pool.new_vector2();
                var r1c4_uv = egret3d.math.Pool.new_vector2();
                var r4c1_uv = egret3d.math.Pool.new_vector2();
                var r4c4_uv = egret3d.math.Pool.new_vector2();
                var r1c2_uv = egret3d.math.Pool.new_vector2();
                var r1c3_uv = egret3d.math.Pool.new_vector2();
                var r2c1_uv = egret3d.math.Pool.new_vector2();
                var r3c1_uv = egret3d.math.Pool.new_vector2();
                var r2c2_uv = egret3d.math.Pool.new_vector2();
                var r2c3_uv = egret3d.math.Pool.new_vector2();
                var r2c4_uv = egret3d.math.Pool.new_vector2();
                var r3c2_uv = egret3d.math.Pool.new_vector2();
                var r3c3_uv = egret3d.math.Pool.new_vector2();
                var r3c4_uv = egret3d.math.Pool.new_vector2();
                var r4c2_uv = egret3d.math.Pool.new_vector2();
                var r4c3_uv = egret3d.math.Pool.new_vector2();
                var help1 = egret3d.math.Pool.new_vector2();
                var help2 = egret3d.math.Pool.new_vector2();
                var help3 = egret3d.math.Pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                var width = egret3d.math.vec2Distance(r1c1, r1c4);
                var height = egret3d.math.vec2Distance(r1c1, r4c1);
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var l_vertex = (border.l) / this.transform.width;
                var r_vertex = (border.r) / this.transform.width;
                var t_vertex = (border.t) / this.transform.height;
                var b_vertex = (border.b) / this.transform.height;
                var l = (border.l) / rect.w * (urange.y - urange.x);
                var r = (border.r) / rect.w * (urange.y - urange.x);
                var t = (border.t) / rect.h * (vrange.y - vrange.x);
                var b = (border.b) / rect.h * (vrange.y - vrange.x);
                egret3d.math.vec2Subtract(r1c4, r1c1, r1c2);
                egret3d.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                egret3d.math.vec2Add(r1c2, r1c1, r1c2);
                egret3d.math.vec2Subtract(r1c1, r1c4, r1c3);
                egret3d.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                egret3d.math.vec2Add(r1c3, r1c4, r1c3);
                egret3d.math.vec2Subtract(r4c1, r1c1, r2c1);
                egret3d.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                egret3d.math.vec2Add(r2c1, r1c1, r2c1);
                egret3d.math.vec2Subtract(r1c1, r4c1, r3c1);
                egret3d.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                egret3d.math.vec2Add(r3c1, r4c1, r3c1);
                egret3d.math.vec2Subtract(r1c2, r1c1, help1);
                egret3d.math.vec2Subtract(r2c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r2c2);
                egret3d.math.vec2Subtract(r1c3, r1c1, help1);
                egret3d.math.vec2Subtract(r2c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r2c3);
                egret3d.math.vec2Subtract(r1c4, r1c1, help1);
                egret3d.math.vec2Subtract(r2c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r2c4);
                egret3d.math.vec2Subtract(r1c2, r1c1, help1);
                egret3d.math.vec2Subtract(r3c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r3c2);
                egret3d.math.vec2Subtract(r1c3, r1c1, help1);
                egret3d.math.vec2Subtract(r3c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r3c3);
                egret3d.math.vec2Subtract(r1c4, r1c1, help1);
                egret3d.math.vec2Subtract(r3c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r3c4);
                egret3d.math.vec2Subtract(r1c2, r1c1, help1);
                egret3d.math.vec2Subtract(r4c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r4c2);
                egret3d.math.vec2Subtract(r1c3, r1c1, help1);
                egret3d.math.vec2Subtract(r4c1, r1c1, help2);
                egret3d.math.vec2Add(help1, help2, help3);
                egret3d.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                var vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                var uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                var partVertexs;
                var partUVs;
                for (var i = 0; i < 9; i++) {
                    var r_1 = Math.floor(i / 3);
                    var c = i % 3;
                    partVertexs = [vertexs[0 + c + r_1 * 4], vertexs[1 + c + r_1 * 4], vertexs[4 + c + r_1 * 4], vertexs[5 + c + r_1 * 4]];
                    partUVs = [uvs[0 + c + r_1 * 4], uvs[1 + c + r_1 * 4], uvs[4 + c + r_1 * 4], uvs[5 + c + r_1 * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * 13 + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * 13 + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * 13 + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * 13 + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * 13 + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * 13 + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * 13 + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * 13 + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * 13 + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * 13 + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * 13 + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * 13 + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                egret3d.math.Pool.delete_vector2Array(vertexs);
                egret3d.math.Pool.delete_vector2Array(uvs);
                egret3d.math.Pool.delete_vector2Array([help1, help2, help3]);
            };
            Image2D.prototype.updateFilledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var halfu = urange.x + 0.5 * ulen;
                var halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                var _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * 13 + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * 13 + 8] = vrange.x;
                                this.datar[4 * 13 + 8] = vrange.x;
                            }
                            else {
                                var _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * 13 + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * 13 + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * 13 + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        var tx = (x0 + x1) / 2;
                        var ty = (y0 + y1) / 2;
                        var bx = (x2 + x3) / 2;
                        var by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            var _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * 13 + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * 13 + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * 13 + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * 13 + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else {
                            var _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * 13 + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * 13 + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        var t_x = (x0 + x1) / 2;
                        var t_y = (y0 + y1) / 2;
                        var l_x = (x0 + x2) / 2;
                        var l_y = (y0 + y2) / 2;
                        var b_x = (x2 + x3) / 2;
                        var b_y = (y2 + y3) / 2;
                        var r_x = (x1 + x3) / 2;
                        var r_y = (y1 + y3) / 2;
                        var c_x = (l_x + r_x) / 2;
                        var c_y = (l_y + r_y) / 2;
                        var b_x1 = b_x;
                        var b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            var _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * 13 + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * 13 + 8] = vrange.y;
                            this.datar[15 * 13 + 8] = vrange.y;
                            this.datar[5 * 13 + 8] = halfv;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            var _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * 13 + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * 13 + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * 13 + 8] = halfv;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            var _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * 13 + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * 13 + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * 13 + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            var _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * 13 + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * 13 + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * 13 + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            var _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * 13 + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else {
                            var _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * 13 + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * 13 + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            };
            Image2D.prototype.updateTiledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var rect = this._sprite.rect;
                var border = this._sprite.border;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var xlen = x1 - x0;
                var ylen = y2 - y0;
                var _ul = this.transform.width / rect.w;
                var _vl = this.transform.height / rect.h;
                var inv_ul = 1 / _ul;
                var inv_vl = 1 / _vl;
                var dindex = 0;
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        var tdata_1 = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata_1);
                        var tx0_1 = x0 + inv_ul * xlen * j;
                        var ty0_1 = y0 + inv_vl * ylen * i;
                        var tx1_1 = x0 + inv_ul * xlen * (j + 1);
                        var ty1_1 = y0 + inv_vl * ylen * i;
                        var tx2_1 = x0 + inv_ul * xlen * j;
                        var ty2_1 = y0 + inv_vl * ylen * (i + 1);
                        var tx3_1 = x0 + inv_ul * xlen * (j + 1);
                        var ty3_1 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0_1, ty0_1, tx1_1, ty1_1, tx2_1, ty2_1, tx3_1, ty3_1, dindex);
                        dindex++;
                    }
                }
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    var tdata_2 = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata_2);
                    var tx0_2 = x0 + inv_ul * xlen * j;
                    var ty0_2 = y0 + inv_vl * ylen * intvl;
                    var tx1_2 = x0 + inv_ul * xlen * (j + 1);
                    var ty1_2 = y0 + inv_vl * ylen * intvl;
                    var tx2_2 = x0 + inv_ul * xlen * j;
                    var ty2_2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3_2 = x0 + inv_ul * xlen * (j + 1);
                    var ty3_2 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0_2, ty0_2, tx1_2, ty1_2, tx2_2, ty2_2, tx3_2, ty3_2, dindex);
                    dindex++;
                }
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    var tdata_3 = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata_3);
                    var tx0_3 = x0 + inv_ul * xlen * intul;
                    var ty0_3 = y0 + inv_vl * ylen * i;
                    var tx1_3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1_3 = y0 + inv_vl * ylen * i;
                    var tx2_3 = x0 + inv_ul * xlen * intul;
                    var ty2_3 = y0 + inv_vl * ylen * (i + 1);
                    var tx3_3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3_3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0_3, ty0_3, tx1_3, ty1_3, tx2_3, ty2_3, tx3_3, ty3_3, dindex);
                    dindex++;
                }
                var tdata = [
                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                ];
                this.datar = this.datar.concat(tdata);
                var tx0 = x0 + inv_ul * xlen * intul;
                var ty0 = y0 + inv_vl * ylen * intvl;
                var tx1 = x0 + inv_ul * xlen * (intul + tul);
                var ty1 = y0 + inv_vl * ylen * intvl;
                var tx2 = x0 + inv_ul * xlen * intul;
                var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                var tx3 = x0 + inv_ul * xlen * (intul + tul);
                var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                dindex++;
            };
            __decorate([
                egret3d.reflect.Field("Color"),
                egret3d.reflect.UIStyle("vector4"),
                __metadata("design:type", egret3d.math.Color)
            ], Image2D.prototype, "color", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                egret3d.reflect.UIStyle("ImageType"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], Image2D.prototype, "imageType", null);
            __decorate([
                egret3d.reflect.Field("number"),
                egret3d.reflect.UIStyle("FillMethod"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], Image2D.prototype, "fillMethod", null);
            Image2D = __decorate([
                egret3d.reflect.node2DComponent,
                egret3d.reflect.nodeRender,
                __metadata("design:paramtypes", [])
            ], Image2D);
            return Image2D;
        }());
        framework.Image2D = Image2D;
        __reflect(Image2D.prototype, "egret3d.framework.Image2D", ["egret3d.framework.IRectRenderer", "egret3d.framework.I2DComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        var VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
        var Label = (function () {
            function Label() {
                this._fontsize = 14;
                this.linespace = 1;
                this.horizontalType = HorizontalType.Center;
                this.verticalType = VerticalType.Center;
                this.indexarr = [];
                this.remainarrx = [];
                this.data_begin = new egret3d.math.Vector2(0, 0);
                this.datar = [];
                this.color = new egret3d.math.Color(1, 1, 1, 1);
                this.color2 = new egret3d.math.Color(0, 0, 0.5, 0.5);
                this.dirtyData = true;
            }
            Object.defineProperty(Label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (text) {
                    this._text = text;
                    var cachelen = 6 * 13 * this._text.length;
                    this.datar.splice(0, this.datar.length);
                    while (this.datar.length < cachelen) {
                        this.datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                    }
                    while (this.datar.length < cachelen) {
                        this.datar.pop();
                    }
                    this.dirtyData = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Label.prototype, "font", {
                get: function () {
                    return this._font;
                },
                set: function (font) {
                    if (this._font) {
                        this._font.unuse();
                    }
                    this._font = font;
                    this._font.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Label.prototype, "fontsize", {
                get: function () {
                    return this._fontsize;
                },
                set: function (size) {
                    this._fontsize = size;
                },
                enumerable: true,
                configurable: true
            });
            Label.prototype.updateData = function (_font) {
                this.dirtyData = false;
                var rate = this._fontsize / _font.lineHeight;
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var txadd = 0;
                var tyadd = 0;
                this.indexarr = [];
                this.remainarrx = [];
                var remainy = 0;
                for (var i = 0; i < this._text.length; i++) {
                    var c = this._text.charAt(i);
                    var cinfo = _font.cmap[c];
                    if (cinfo == undefined) {
                        continue;
                    }
                    if (txadd + cinfo.xAddvance * rate > this.transform.width) {
                        if (tyadd + this._fontsize * this.linespace > this.transform.height) {
                            break;
                        }
                        else {
                            this.indexarr.push(i);
                            this.remainarrx.push(this.transform.width - txadd);
                            txadd = 0;
                            tyadd += this._fontsize * this.linespace;
                        }
                    }
                    txadd += cinfo.xAddvance * rate;
                }
                this.indexarr.push(i);
                this.remainarrx.push(this.transform.width - txadd);
                remainy = this.transform.height - tyadd;
                var i = 0;
                var xadd = 0;
                var yadd = 0;
                if (this.verticalType == VerticalType.Center) {
                    yadd += remainy / 2;
                }
                else if (this.verticalType == VerticalType.Boom) {
                    yadd += remainy;
                }
                for (var arri = 0; arri < this.indexarr.length; arri++) {
                    xadd = 0;
                    if (this.horizontalType == HorizontalType.Center) {
                        xadd += this.remainarrx[arri] / 2;
                    }
                    else if (this.horizontalType = HorizontalType.Right) {
                        xadd += this.remainarrx[arri];
                    }
                    for (; i < this.indexarr[arri]; i++) {
                        var c = this._text.charAt(i);
                        var cinfo = _font.cmap[c];
                        if (cinfo == undefined) {
                            continue;
                        }
                        var cx = xadd + cinfo.xOffset * rate;
                        var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
                        var ch = rate * cinfo.ySize;
                        var cw = rate * cinfo.xSize;
                        xadd += cinfo.xAddvance * rate;
                        var x1 = cx + cw;
                        var y1 = cy;
                        var x2 = cx;
                        var y2 = cy + ch;
                        var x3 = cx + cw;
                        var y3 = cy + ch;
                        this.datar[i * 6 * 13 + 0] = bx + cx * m11 + cy * m12;
                        this.datar[i * 6 * 13 + 1] = by + cx * m21 + cy * m22;
                        this.datar[i * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;
                        this.datar[i * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;
                        var u0 = cinfo.x;
                        var v0 = cinfo.y;
                        var u1 = cinfo.x + cinfo.w;
                        var v1 = cinfo.y;
                        var u2 = cinfo.x;
                        var v2 = cinfo.y + cinfo.h;
                        var u3 = cinfo.x + cinfo.w;
                        var v3 = cinfo.y + cinfo.h;
                        this.datar[i * 6 * 13 + 7] = u0;
                        this.datar[i * 6 * 13 + 8] = v0;
                        this.datar[i * 6 * 13 + 13 * 1 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 1 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 2 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 2 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 3 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 3 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 4 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 4 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 5 + 7] = u3;
                        this.datar[i * 6 * 13 + 13 * 5 + 8] = v3;
                        for (var j = 0; j < 6; j++) {
                            this.datar[i * 6 * 13 + 13 * j + 3] = this.color.r;
                            this.datar[i * 6 * 13 + 13 * j + 4] = this.color.g;
                            this.datar[i * 6 * 13 + 13 * j + 5] = this.color.b;
                            this.datar[i * 6 * 13 + 13 * j + 6] = this.color.a;
                            this.datar[i * 6 * 13 + 13 * j + 9] = this.color2.r;
                            this.datar[i * 6 * 13 + 13 * j + 10] = this.color2.g;
                            this.datar[i * 6 * 13 + 13 * j + 11] = this.color2.b;
                            this.datar[i * 6 * 13 + 13 * j + 12] = this.color2.a;
                        }
                    }
                    yadd += this._fontsize * this.linespace;
                }
            };
            Label.prototype.render = function (canvas) {
                if (this._font != null) {
                    if (this.dirtyData = true) {
                        this.updateData(this._font);
                        this.dirtyData = false;
                    }
                    if (this.mat == null) {
                        this.mat = new framework.Material();
                        this.mat.setShader(framework.DefaultShaders.UIFont);
                    }
                    var img;
                    if (this._font != null) {
                        img = this._font.texture;
                    }
                    if (img == null) {
                        var scene = this.transform.canvas.scene;
                        img = framework.DefaultTextures.Grid;
                    }
                    this.mat.setTexture("_MainTex", img);
                    if (this.datar.length != 0) {
                        canvas.pushRawData(this.mat, this.datar);
                    }
                }
            };
            Label.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                this.data_begin.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                this.data_begin.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
            };
            Label.prototype.start = function () {
            };
            Label.prototype.update = function (delta) {
            };
            Label.prototype.remove = function () {
                this._font.unuse(true);
                this.indexarr.length = 0;
                this.remainarrx.length = 0;
                this.datar.length = 0;
            };
            Label.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            __decorate([
                egret3d.reflect.Field("string"),
                __metadata("design:type", String),
                __metadata("design:paramtypes", [String])
            ], Label.prototype, "text", null);
            __decorate([
                egret3d.reflect.Field("Font"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.Font])
            ], Label.prototype, "font", null);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], Label.prototype, "fontsize", null);
            Label = __decorate([
                egret3d.reflect.node2DComponent,
                egret3d.reflect.nodeRender
            ], Label);
            return Label;
        }());
        framework.Label = Label;
        __reflect(Label.prototype, "egret3d.framework.Label", ["egret3d.framework.IRectRenderer", "egret3d.framework.I2DComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var RawImage2D = (function () {
            function RawImage2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.color = new egret3d.math.Color(1.0, 1.0, 1.0, 1.0);
            }
            Object.defineProperty(RawImage2D.prototype, "image", {
                get: function () {
                    return this._image;
                },
                set: function (_image) {
                    if (this._image) {
                        this._image.unuse();
                    }
                    this._image = _image;
                    this._image.use();
                },
                enumerable: true,
                configurable: true
            });
            RawImage2D.prototype.render = function (canvas) {
                if (this.mat == null) {
                    this.mat = new framework.Material();
                    this.mat.setShader(framework.DefaultShaders.UI);
                }
                var img = this.image;
                if (img != null) {
                    this.mat.setTexture("_MainTex", img);
                    canvas.pushRawData(this.mat, this.datar);
                }
            };
            RawImage2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            };
            RawImage2D.prototype.start = function () {
            };
            RawImage2D.prototype.update = function (delta) {
            };
            RawImage2D.prototype.remove = function () {
                this._image.unuse(true);
            };
            RawImage2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            __decorate([
                egret3d.reflect.Field("Texture"),
                __metadata("design:type", framework.Texture)
            ], RawImage2D.prototype, "_image", void 0);
            __decorate([
                egret3d.reflect.Field("Color"),
                egret3d.reflect.UIStyle("vector4"),
                __metadata("design:type", egret3d.math.Color)
            ], RawImage2D.prototype, "color", void 0);
            __decorate([
                egret3d.reflect.Field("Material"),
                egret3d.reflect.UIStyle("Material"),
                __metadata("design:type", framework.Material)
            ], RawImage2D.prototype, "mat", void 0);
            RawImage2D = __decorate([
                egret3d.reflect.node2DComponent,
                egret3d.reflect.nodeRender
            ], RawImage2D);
            return RawImage2D;
        }());
        framework.RawImage2D = RawImage2D;
        __reflect(RawImage2D.prototype, "egret3d.framework.RawImage2D", ["egret3d.framework.IRectRenderer", "egret3d.framework.I2DComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ConstantAdapter = (function () {
            function ConstantAdapter() {
                this.$dirty = true;
                this._scaleFactor = 1;
            }
            Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
                set: function (value) {
                    this._scaleFactor = value;
                    this.$dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
                var scaler = this._scaleFactor;
                out.s = scaler;
                out.w = canvasWidth / scaler;
                out.h = canvasHeight / scaler;
            };
            return ConstantAdapter;
        }());
        framework.ConstantAdapter = ConstantAdapter;
        __reflect(ConstantAdapter.prototype, "egret3d.framework.ConstantAdapter", ["egret3d.framework.IScreenAdapter"]);
        var ExpandAdapter = (function () {
            function ExpandAdapter() {
                this.$dirty = true;
                this._resolution = new egret3d.math.Vector2(640, 1136);
            }
            ExpandAdapter.prototype.setResolution = function (width, height) {
                this._resolution.x = width;
                this._resolution.y = height;
                this.$dirty = true;
            };
            ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
                var canvasRate = canvasWidth / canvasHeight;
                var resolutionRate = this._resolution.x / this._resolution.y;
                var scaler = 1;
                if (canvasRate > resolutionRate) {
                    scaler = canvasHeight / this._resolution.y;
                }
                else {
                    scaler = canvasWidth / this._resolution.x;
                }
                out.s = scaler;
                out.w = canvasWidth / scaler;
                out.h = canvasHeight / scaler;
            };
            return ExpandAdapter;
        }());
        framework.ExpandAdapter = ExpandAdapter;
        __reflect(ExpandAdapter.prototype, "egret3d.framework.ExpandAdapter", ["egret3d.framework.IScreenAdapter"]);
        var ShrinkAdapter = (function () {
            function ShrinkAdapter() {
                this.$dirty = true;
                this._resolution = new egret3d.math.Vector2(640, 1136);
            }
            ShrinkAdapter.prototype.setResolution = function (width, height) {
                this._resolution.x = width;
                this._resolution.y = height;
                this.$dirty = true;
            };
            ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
                var canvasRate = canvasWidth / canvasHeight;
                var resolutionRate = this._resolution.x / this._resolution.y;
                var scaler = 1;
                if (canvasRate > resolutionRate) {
                    scaler = canvasWidth / this._resolution.x;
                }
                else {
                    scaler = canvasHeight / this._resolution.y;
                }
                out.s = scaler;
                out.w = canvasWidth / scaler;
                out.h = canvasHeight / scaler;
            };
            return ShrinkAdapter;
        }());
        framework.ShrinkAdapter = ShrinkAdapter;
        __reflect(ShrinkAdapter.prototype, "egret3d.framework.ShrinkAdapter", ["egret3d.framework.IScreenAdapter"]);
        var MatchWidthOrHeightAdapter = (function () {
            function MatchWidthOrHeightAdapter() {
                this.$dirty = true;
                this._resolution = new egret3d.math.Vector2(640, 1136);
                this._matchFactor = 0;
            }
            MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
                this._resolution.x = width;
                this._resolution.y = height;
                this.$dirty = true;
            };
            Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
                set: function (value) {
                    this._matchFactor = value;
                    this.$dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
                var scaler1 = canvasWidth / this._resolution.x;
                var scaler2 = canvasHeight / this._resolution.y;
                var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
                out.s = scaler;
                out.w = canvasWidth / scaler;
                out.h = canvasHeight / scaler;
            };
            return MatchWidthOrHeightAdapter;
        }());
        framework.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
        __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.framework.MatchWidthOrHeightAdapter", ["egret3d.framework.IScreenAdapter"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var AssetMap = (function () {
            function AssetMap() {
            }
            AssetMap.register = function (asset) {
                var id = asset.getGUID();
                var name = asset.getName();
                this._map[id] = asset;
                if (!this._nameMap[name]) {
                    this._nameMap[name] = [];
                }
                this._nameMap[name].push(id);
            };
            AssetMap.unregister = function (asset) {
                delete this._map[asset.getGUID()];
                var name = asset.getName();
                if (this._nameMap[name].length <= 1) {
                    delete this._nameMap[name];
                }
                else {
                    for (var key in this._nameMap[name]) {
                        if (asset.getGUID() == this._nameMap[name][key]) {
                            this._nameMap[name].splice(parseInt(key), 1);
                        }
                    }
                }
            };
            AssetMap.find = function (name, bundleName) {
                var id = this._nameMap[name][0];
                if (bundleName) {
                    var bundle = this._bundleName[bundleName];
                    if (bundle) {
                        id = bundle.mapNamed[name];
                    }
                }
                return this._map[id];
            };
            AssetMap.findById = function (id) {
                return this._map[id];
            };
            AssetMap.registerBundle = function (name, bundle) {
                this._bundleName[name] = bundle;
            };
            AssetMap.unregisterBundle = function (name) {
                delete this._bundleName[name];
            };
            AssetMap.findBundle = function (name) {
                return this._bundleName[name];
            };
            AssetMap._map = {};
            AssetMap._nameMap = {};
            AssetMap._bundleName = {};
            return AssetMap;
        }());
        framework.AssetMap = AssetMap;
        __reflect(AssetMap.prototype, "egret3d.framework.AssetMap");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var DefaultMeshes = (function () {
            function DefaultMeshes() {
            }
            Object.defineProperty(DefaultMeshes, "isInit", {
                get: function () {
                    return this._inited;
                },
                enumerable: true,
                configurable: true
            });
            DefaultMeshes.init = function (gl) {
                this.Cube = this.createDefaultMesh("cube", egret3d.render.MeshData.genBoxCCW(1.0), gl);
                this.Quad = this.createDefaultMesh("circleline", egret3d.render.MeshData.genQuad(1.0), gl);
                this.QuadParticle = this.createDefaultMesh("quad_particle", egret3d.render.MeshData.genQuad_forparticle(1.0), gl);
                this.Plane = this.createDefaultMesh("plane", egret3d.render.MeshData.genPlaneCCW(10), gl);
                this.Sphere = this.createDefaultMesh("sphere", egret3d.render.MeshData.genSphereCCW(), gl);
                this.Pyramid = this.createDefaultMesh("pyramid", egret3d.render.MeshData.genPyramid(2, 0.5), gl);
                this.Cylinder = this.createDefaultMesh("cylinder", egret3d.render.MeshData.genCylinderCCW(2, 0.5), gl);
                this.CircleLine = this.createDefaultMesh("circleline", egret3d.render.MeshData.genCircleLineCCW(1), gl);
                framework.AssetMap.register(this.Cube);
                framework.AssetMap.register(this.Quad);
                framework.AssetMap.register(this.QuadParticle);
                framework.AssetMap.register(this.Plane);
                framework.AssetMap.register(this.Sphere);
                framework.AssetMap.register(this.Pyramid);
                framework.AssetMap.register(this.Cylinder);
                framework.AssetMap.register(this.CircleLine);
                this._inited = true;
            };
            DefaultMeshes.createDefaultMesh = function (name, meshData, webgl) {
                var mesh = new framework.Mesh(name + ".mesh.bin");
                mesh.defaultAsset = true;
                mesh.data = meshData;
                var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Normal | egret3d.render.VertexFormatMask.Tangent | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0;
                var v32 = mesh.data.genVertexDataArray(vf);
                var i16 = mesh.data.genIndexDataArray();
                mesh.glMesh = new egret3d.render.GlMesh();
                mesh.glMesh.initBuffer(webgl, vf, mesh.data.pos.length);
                mesh.glMesh.uploadVertexSubData(webgl, v32);
                mesh.glMesh.addIndex(webgl, i16.length);
                mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = i16.length;
                sm.line = false;
                mesh.submesh.push(sm);
                return mesh;
            };
            DefaultMeshes._inited = false;
            return DefaultMeshes;
        }());
        framework.DefaultMeshes = DefaultMeshes;
        __reflect(DefaultMeshes.prototype, "egret3d.framework.DefaultMeshes");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var DefaultShaders = (function () {
            function DefaultShaders() {
            }
            Object.defineProperty(DefaultShaders, "isInit", {
                get: function () {
                    return this._inited;
                },
                enumerable: true,
                configurable: true
            });
            DefaultShaders.init = function (gl) {
                var def_code_vs = framework.Shader.registerVertShader("def_code", framework.ShaderLib.code_vert);
                var def_code_fs = framework.Shader.registerFragShader("def_code", framework.ShaderLib.code_frag);
                var def_code2_fs = framework.Shader.registerFragShader("def_code2", framework.ShaderLib.code2_frag);
                var def_ui_fs = framework.Shader.registerFragShader("def_ui", framework.ShaderLib.ui_frag);
                var def_uifont_vs = framework.Shader.registerVertShader("def_uifont", framework.ShaderLib.uifont_vert);
                var def_uifont_fs = framework.Shader.registerFragShader("def_uifont", framework.ShaderLib.uifont_frag);
                var def_diffuse_vs = framework.Shader.registerVertShader("def_diffuse", framework.ShaderLib.diffuse_vert);
                var def_diffuse_fs = framework.Shader.registerFragShader("def_diffuse", framework.ShaderLib.diffuse_frag);
                var def_boneeff_vs = framework.Shader.registerVertShader("def_boneeff", framework.ShaderLib.boneeff_vert);
                var def_diffuselightmap_vs = framework.Shader.registerVertShader("def_diffuselightmap", framework.ShaderLib.diffuselightmap_vert);
                var def_diffuselightmap_fs = framework.Shader.registerFragShader("def_diffuselightmap", framework.ShaderLib.diffuselightmap_frag);
                var def_postquad_vs = framework.Shader.registerVertShader("def_postquad", framework.ShaderLib.postquad_vert);
                var def_postquaddepth_fs = framework.Shader.registerFragShader("def_postquaddepth", framework.ShaderLib.postquaddepth_frag);
                var def_postdepth_vs = framework.Shader.registerVertShader("def_postdepth", framework.ShaderLib.postdepth_vert);
                var def_postdepth_fs = framework.Shader.registerFragShader("def_postdepth", framework.ShaderLib.postdepth_frag);
                var def_line_vs = framework.Shader.registerVertShader("def_line", framework.ShaderLib.line_vert);
                var def_line_fs = framework.Shader.registerFragShader("def_line", framework.ShaderLib.line_frag);
                var def_materialcolor_vs = framework.Shader.registerVertShader("def_materialcolor", framework.ShaderLib.materialcolor_vert);
                var def_diffusetintcolor_fs = framework.Shader.registerFragShader("def_diffusetintcolor", framework.ShaderLib.tintcolor_frag);
                var def_diffusevertcolor_vs = framework.Shader.registerVertShader("def_diffusevertcolor", framework.ShaderLib.vertcolor_vert);
                var def_diffusevertcolor_fs = framework.Shader.registerFragShader("def_diffusevertcolor", framework.ShaderLib.vertcolor_frag);
                var def_lambert_vs = framework.Shader.registerVertShader("def_lambert", framework.ShaderLib.lambert_vert);
                var def_lambert_fs = framework.Shader.registerFragShader("def_lambert", framework.ShaderLib.lambert_frag);
                var def_lambertnormal_vs = framework.Shader.registerVertShader("def_lambertnormal", framework.ShaderLib.lambertnormal_vert);
                var def_lambertnormal_fs = framework.Shader.registerFragShader("def_lambertnormal", framework.ShaderLib.lambertnormal_frag);
                {
                    var sh = new framework.Shader("shader/lambert");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_lambert_vs, def_lambert_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.Lambert = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/lambertnormal");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_lambertnormal_vs, def_lambertnormal_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.LambertNormal = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/def");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("transparent.shader.json");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Blend);
                    this.Transparent = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("transparent_additive.shader.json");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Add);
                    this.TransparentAdditive = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("transparent_bothside.shader.json");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Blend);
                    this.TransparentBothSide = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("diffuse.shader.json");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"] = [];
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p2 = new egret3d.render.GlDrawPass(def_boneeff_vs, def_diffuse_fs);
                    sh.passes["skin"] = [];
                    sh.passes["skin"].push(p2);
                    p2.state_ztest = true;
                    p2.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p2.state_zwrite = true;
                    p2.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p2.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p3 = new egret3d.render.GlDrawPass(def_diffuselightmap_vs, def_diffuselightmap_fs);
                    sh.passes["lightmap"] = [];
                    sh.passes["lightmap"].push(p3);
                    p3.state_ztest = true;
                    p3.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p3.state_zwrite = true;
                    p3.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p3.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p4 = new egret3d.render.GlDrawPass(def_postquad_vs, def_postquaddepth_fs);
                    sh.passes["quad"] = [];
                    sh.passes["quad"].push(p4);
                    p4.state_ztest = true;
                    p4.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p4.state_zwrite = true;
                    p4.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p4.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p5 = new egret3d.render.GlDrawPass(def_postdepth_vs, def_postdepth_fs);
                    sh.passes["base_depth"] = [];
                    sh.passes["base_depth"].push(p5);
                    p5.state_ztest = true;
                    p5.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p5.state_zwrite = true;
                    p5.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p5.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.Diffuse = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/diffuse_tintcolor");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    sh.defaultValue["_TintColor"] = { type: "Color", value: new egret3d.math.Color(1, 1, 1, 1) };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffusetintcolor_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.DiffuseTintColor = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/diffuse_vertcolor");
                    sh.defaultAsset = true;
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.passes["base"] = [];
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffusevertcolor_vs, def_diffusevertcolor_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.DiffuseVertColor = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("diffuse_bothside.shader.json");
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.defaultAsset = true;
                    sh.defaultValue["_MainTex"] = { type: "Texture", defaultValue: framework.AssetMap.find("grid") };
                    sh.defaultValue["_MainTex_ST"] = { type: "Texture", value: new egret3d.math.Vector4(1, 1, 0, 0) };
                    sh.defaultValue["_AlphaCut"] = { type: "Range", value: 0.1, min: 0, max: 1 };
                    var p = new egret3d.render.GlDrawPass(def_diffuse_vs, def_diffuse_fs);
                    sh.passes["base"] = [];
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p2 = new egret3d.render.GlDrawPass(def_boneeff_vs, def_diffuse_fs);
                    sh.passes["skin"] = [];
                    sh.passes["skin"].push(p2);
                    p2.state_ztest = true;
                    p2.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p2.state_zwrite = true;
                    p2.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p2.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p3 = new egret3d.render.GlDrawPass(def_diffuselightmap_vs, def_diffuselightmap_fs);
                    sh.passes["lightmap"] = [];
                    sh.passes["lightmap"].push(p3);
                    p3.state_ztest = true;
                    p3.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p3.state_zwrite = true;
                    p3.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p3.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p4 = new egret3d.render.GlDrawPass(def_postquad_vs, def_postquaddepth_fs);
                    sh.passes["quad"] = [];
                    sh.passes["quad"].push(p4);
                    p4.state_ztest = true;
                    p4.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p4.state_zwrite = true;
                    p4.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p4.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    var p5 = new egret3d.render.GlDrawPass(def_postdepth_vs, def_postdepth_fs);
                    sh.passes["base_depth"] = [];
                    sh.passes["base_depth"].push(p5);
                    p5.state_ztest = true;
                    p5.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p5.state_zwrite = true;
                    p5.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                    p5.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.DiffuseBothSide = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_code_vs, def_ui_fs);
                    sh.passes["base"].push(p);
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CW;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Blend_PreMultiply);
                    var p2 = new egret3d.render.GlDrawPass(def_code_vs, def_ui_fs);
                    sh.passes["base"].push(p2);
                    p2.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p2.state_ztest = true;
                    p2.state_zwrite = false;
                    p2.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p2.setAlphaBlend(egret3d.render.BlendModeEnum.Blend_PreMultiply);
                    this.UI = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_uifont_vs, def_uifont_fs);
                    sh.passes["base"].push(p);
                    p.state_showface = egret3d.render.ShowFaceStateEnum.CW;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Blend_PreMultiply);
                    var p2 = new egret3d.render.GlDrawPass(def_uifont_vs, def_uifont_fs);
                    sh.passes["base"].push(p2);
                    p2.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p2.state_ztest = true;
                    p2.state_zwrite = false;
                    p2.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p2.setAlphaBlend(egret3d.render.BlendModeEnum.Blend_PreMultiply);
                    this.UIFont = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("line.shader.json");
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_line_vs, def_line_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    this.Line = sh;
                    framework.AssetMap.register(sh);
                }
                {
                    var sh = new framework.Shader("materialcolor.shader.json");
                    sh.layer = framework.RenderLayerEnum.Common;
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new egret3d.render.GlDrawPass(def_materialcolor_vs, def_line_fs);
                    sh.passes["base"].push(p);
                    p.state_ztest = false;
                    p.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(egret3d.render.BlendModeEnum.Close);
                    sh.layer = framework.RenderLayerEnum.Overlay;
                    this.MaterialColor = sh;
                    framework.AssetMap.register(sh);
                }
                this._inited = true;
            };
            DefaultShaders._inited = false;
            return DefaultShaders;
        }());
        framework.DefaultShaders = DefaultShaders;
        __reflect(DefaultShaders.prototype, "egret3d.framework.DefaultShaders");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var DefaultTextures = (function () {
            function DefaultTextures() {
            }
            Object.defineProperty(DefaultTextures, "isInit", {
                get: function () {
                    return this._inited;
                },
                enumerable: true,
                configurable: true
            });
            DefaultTextures.init = function (gl) {
                var t1 = new framework.Texture("white");
                t1.glTexture = egret3d.render.GlTexture2D.staticTexture(gl, "white");
                t1.defaultAsset = true;
                this.White = t1;
                var t2 = new framework.Texture("gray");
                t2.glTexture = egret3d.render.GlTexture2D.staticTexture(gl, "gray");
                t2.defaultAsset = true;
                this.Gray = t2;
                var t3 = new framework.Texture("grid");
                t3.glTexture = egret3d.render.GlTexture2D.staticTexture(gl, "grid");
                t3.defaultAsset = true;
                this.Grid = t3;
                framework.AssetMap.register(this.White);
                framework.AssetMap.register(this.Gray);
                framework.AssetMap.register(this.Grid);
                this._inited = true;
            };
            DefaultTextures._inited = false;
            return DefaultTextures;
        }());
        framework.DefaultTextures = DefaultTextures;
        __reflect(DefaultTextures.prototype, "egret3d.framework.DefaultTextures");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ShaderLib;
        (function (ShaderLib) {
            ShaderLib.bone_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_bones[24];\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;  \n\t\n    int i = int(_glesBlendIndex4.x);  \n    int i2 =int(_glesBlendIndex4.y);\n\tint i3 =int(_glesBlendIndex4.z);\n\tint i4 =int(_glesBlendIndex4.w);\n\t\n    mat4 mat = glstate_matrix_bones[i]*_glesBlendWeight4.x \n\t\t\t + glstate_matrix_bones[i2]*_glesBlendWeight4.y \n\t\t\t + glstate_matrix_bones[i3]*_glesBlendWeight4.z \n\t\t\t + glstate_matrix_bones[i4]*_glesBlendWeight4.w;\n\t\t\t \n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n}";
            ShaderLib.boneeff_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_vec4_bones[110];\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy2 = 2.0 * quat.x * quat.y;\n\tfloat xz2 = 2.0 * quat.x * quat.z;\n\tfloat xw2 = 2.0 * quat.x * quat.w;\n\tfloat yz2 = 2.0 * quat.y * quat.z;\n\tfloat yw2 = 2.0 * quat.y * quat.w;\n\tfloat zw2 = 2.0 * quat.z * quat.w;\n\tfloat xx = quat.x * quat.x;\n\tfloat yy = quat.y * quat.y;\n\tfloat zz = quat.z * quat.z;\n\tfloat ww = quat.w * quat.w;\n\tmat4 matrix = mat4(\n\txx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n\txy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n\txz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);  \n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\t\n    mat4 mat = buildMat4(i)*blendWeight.x \n\t\t\t + buildMat4(i2)*blendWeight.y \n\t\t\t + buildMat4(i3)*blendWeight.z \n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\nvoid main()\n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz;  \n\t\t\t \n    gl_Position = glstate_matrix_mvp *  tmpvar_1;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n}";
            ShaderLib.code2_frag = "void main() {\n    gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\n}";
            ShaderLib.code_frag = "uniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() {\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    prev_2 = tmpvar_3;\n    mediump vec4 tmpvar_4;\n    tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    col_1 = tmpvar_4;\n    col_1.x =xlv_TEXCOORD0.x;\n    col_1.y =xlv_TEXCOORD0.y;\n    gl_FragData[0] = col_1;\n}";
            ShaderLib.code_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesColor;             \nattribute vec4 _glesMultiTexCoord0;    \nuniform highp mat4 glstate_matrix_mvp; \nvarying lowp vec4 xlv_COLOR;           \nvarying highp vec2 xlv_TEXCOORD0;      \nvoid main() {                                          \n    highp vec4 tmpvar_1;                   \n    tmpvar_1.w = 1.0;                      \n    tmpvar_1.xyz = _glesVertex.xyz;        \n    xlv_COLOR = _glesColor;                \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
            ShaderLib.diffuse_frag = "uniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(tmpvar_3.a < _AlphaCut)\n        discard;\n    gl_FragData[0] = tmpvar_3;\n}";
            ShaderLib.diffuse_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 _MainTex_ST;  \nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
            ShaderLib.diffuselightmap_frag = "uniform sampler2D _MainTex;\nuniform sampler2D _LightmapTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\nvoid main() \n{\n    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    lowp vec4 lightmap = texture2D(_LightmapTex, xlv_TEXCOORD1);\n    outColor.xyz *= decode_hdr(lightmap);\n    gl_FragData[0] = outColor;\n}";
            ShaderLib.diffuselightmap_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nattribute vec4 _glesMultiTexCoord1;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_lightmapOffset;\nuniform lowp float glstate_lightmapUV;\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n    highp vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    if(glstate_lightmapUV == 0.0)\n    {\n        beforelightUV = _glesMultiTexCoord0.xy;\n    }\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = 1.0 - ((1.0 - beforelightUV.y) * glstate_lightmapOffset.y + glstate_lightmapOffset.w);\n    xlv_TEXCOORD1 = vec2(u,v);\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
            ShaderLib.lambert_frag = "uniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() \n{\n    lowp vec4 tmpvar_3= (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    mediump vec4 tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), tmpvar_3, tmpvar_3.wwww);\n    gl_FragData[0] = tmpvar_4;\n}";
            ShaderLib.lambert_vert = "attribute vec3 _glesVertex;   \nattribute vec3 _glesNormal;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesMultiTexCoord0;        \nuniform highp mat4 glstate_matrix_mvp;      \nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform highp vec4 glstate_vec4_lightposs[8];\nuniform highp vec4 glstate_vec4_lightdirs[8];\nuniform highp float glstate_float_spotangelcoss[8];\nuniform highp float glstate_lightcount;\nvarying lowp vec4 xlv_COLOR;                \nvarying highp vec2 xlv_TEXCOORD0;     \nhighp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot)\n{\n    highp vec3 L = normalize(lightPos.xyz - worldpos); \n    highp vec3 L2 = -lightDir.xyz;\n    highp float dotSpot = dot(L,L2);\n    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n     \n}\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;    \n    highp mat3 normalmat = mat3(glstate_matrix_model);\n    highp vec3 N =normalize(normalmat*_glesNormal);\n    highp vec3 worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;\n    highp float diff=0.0;\n    for(int i=0;i<8;i++)\n    {\n        int c =int(glstate_lightcount);\n        if(i>=c)break;\n        diff += calcDiffuse(N,worldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);\n    }\n    xlv_COLOR = vec4(diff,diff,diff,1.0);         \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}";
            ShaderLib.lambertnormal_frag = "\nuniform sampler2D _MainTex;  \nuniform sampler2D _NormalTex;\nuniform highp mat4 glstate_matrix_model;\nuniform highp vec4 glstate_vec4_lightposs[8];\nuniform highp vec4 glstate_vec4_lightdirs[8];\nuniform highp float glstate_float_spotangelcoss[8];\nuniform highp float glstate_lightcount;\nvarying lowp vec4 xlv_COLOR;     \nvarying highp vec3 xlv_Position;                                             \nvarying highp vec2 xlv_TEXCOORD0; \nvarying highp mat3 TBNmat;\nvarying highp vec3 worldpos; \nhighp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot);\nvoid main() \n{\n\t\n\thighp mat3 TBN = TBNmat;\n    highp mat3 normalmat = mat3(glstate_matrix_model);\n\thighp vec3 N = normalize(TBNmat[2]*normalmat);\n    highp float diff=0.0;\n    for(int i=0;i<8;i++)\n    {        \n        int c =int(glstate_lightcount);\n        if(i>=c)break;\n\t\thighp vec4 lpos=glstate_vec4_lightposs[i];\n\t\thighp vec4 ldir =glstate_vec4_lightdirs[i];\n\t\t\n\t\thighp vec3 normal;\t\tnormal =  texture2D(_NormalTex, xlv_TEXCOORD0).xyz *2.0 -1.0;\n        normal =normalize(normal);\n\t\tnormal =TBN*(normal);\n\t\t\n        diff += calcDiffuse(normal,worldpos,lpos,ldir,glstate_float_spotangelcoss[i]);\n    }\n\tlowp vec4 color = vec4(diff,diff,diff,1.0);       \n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (color * texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}\nhighp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot)\n{\n    highp vec3 L = normalize(lightPos.xyz - worldpos); \n    highp vec3 L2 = -lightDir.xyz;\n    highp float dotSpot = dot(L,L2);\n    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n     \n}\n";
            ShaderLib.lambertnormal_vert = "\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\nattribute vec4 _glesColor;\nattribute vec3 _glesNormal;\nattribute vec3 _glesTangent;  \nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform highp vec4 glstate_eyepos;\nuniform highp vec4 glstate_vec4_lightposs[8];\nuniform highp vec4 glstate_vec4_lightdirs[8];\nuniform highp float glstate_float_spotangelcoss[8];\nuniform highp float glstate_lightcount;\nvarying highp vec4 xlv_COLOR;\nvarying highp vec3 xlv_Position;      \nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp mat3 TBNmat;\nvarying highp vec3 worldpos;\nhighp mat3 calBTNMatrix(highp mat3 NormalMatToWorld,highp vec3 _normal,highp vec3 _tangent)\n{\n    highp vec3 normal=normalize(NormalMatToWorld*_normal);\n    highp vec3 tangent=normalize(NormalMatToWorld*_tangent);\n    highp vec3 binormal=cross(normal,tangent);\n  \treturn (mat3(tangent,binormal,normal));\n}\nvoid main()\n{\n    mat3 normalmat = mat3(glstate_matrix_model);\n   \tTBNmat=calBTNMatrix(normalmat,_glesNormal,_glesTangent);\n    worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;\n\txlv_COLOR = _glesColor;\n\txlv_Position = _glesVertex.xyz;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\n}\n";
            ShaderLib.line_frag = "varying lowp vec4 xlv_COLOR;\nvoid main() {\n    gl_FragData[0] = xlv_COLOR;\n}";
            ShaderLib.line_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesColor;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _glesColor;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
            ShaderLib.materialcolor_vert = "attribute vec4 _glesVertex;\nuniform vec4 _Color;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _Color;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
            ShaderLib.postdepth_frag = "precision highp float;\nconst float PackUpscale = 256. / 255.; \nconst float UnpackDownscale = 255. / 256.; \nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( const in float v ) \n{\n    vec2 r = vec2( fract( v * PackFactors.z ), v );\n\tr.y -= r.x * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGToDepth( const in vec2 v ) \n{\n    return dot( v.xy, UnpackFactors.zw );\n}\nvec3 packDepthToRGB( const in float v ) \n{\n    vec3 r = vec3( fract( v * PackFactors.yz ), v );\n\tr.yz -= r.xy * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGBToDepth( const in vec3 v ) \n{\n    return dot( v.xyz, UnpackFactors.yzw );\n}\nvoid main() \n{\n    float z = gl_FragCoord.z;    gl_FragColor=packDepthToRGBA(z);\n}";
            ShaderLib.postdepth_vert = "precision highp float;\nattribute vec4 _glesVertex;    \nuniform highp mat4 glstate_matrix_mvp;      \n       \nvoid main()                                     \n{        \n    gl_Position = (glstate_matrix_mvp * _glesVertex);  \n}";
            ShaderLib.postquad_vert = "attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0; \nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main()                     \n{ \n    gl_Position = _glesVertex;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw; \n}   ";
            ShaderLib.postquaddepth_frag = "precision mediump float;\nvarying highp vec2 xlv_TEXCOORD0;       \nuniform sampler2D _DepthTex;   \nuniform sampler2D _MainTex;  \nconst float PackUpscale = 256. / 255.; \nconst float UnpackDownscale = 255. / 256.; \nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\nfloat planeDistance(const in vec3 positionA, const in vec3 normalA, \n                    const in vec3 positionB, const in vec3 normalB) \n{\n  vec3 positionDelta = positionB-positionA;\n  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));\n  return planeDistanceDelta;\n}\nvoid main()         \n{\n    lowp vec4 c1=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0.001,0));\n    lowp vec4 c2=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(-0.001,0));\n    lowp vec4 c3=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,0.001));\n    lowp vec4 c4=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,-0.001));\n    highp float z1 = unpackRGBAToDepth(c1);\n    highp float z2 = unpackRGBAToDepth(c2);\n    highp float z3 = unpackRGBAToDepth(c3);\n    highp float z4 = unpackRGBAToDepth(c4);\n    highp float d = clamp(  (abs(z2-z1)+abs(z4-z3))*10.0,0.0,1.0);\n    lowp vec4 c=texture2D(_MainTex, xlv_TEXCOORD0);\n    lowp float g = c.r*0.3+c.g*0.6+c.b*0.1;\n    gl_FragColor =mix(vec4(g,g,g,1.),vec4(1.0,1.0,0.0,1.0),d);}";
            ShaderLib.tintcolor_frag = "uniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nuniform lowp vec4 _TintColor;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() \n{\n    lowp vec4 tmpvar_3 = _TintColor*texture2D(_MainTex, xlv_TEXCOORD0);\n    if(tmpvar_3.a < _AlphaCut)\n        discard;\n    gl_FragData[0] = tmpvar_3;\n}";
            ShaderLib.transparentdiffuse_vert = "";
            ShaderLib.ui_frag = "uniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}";
            ShaderLib.uifont_frag = "precision mediump float;\nuniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying lowp vec4 xlv_COLOREx;\nvarying highp vec2 xlv_TEXCOORD0;  \nvoid main() {\n    float scale = 10.0;\n    float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5) * scale;    float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34) * scale;\n    float c=xlv_COLOR.a * clamp ( d,0.0,1.0);\n    float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);\n    bc =min(1.0-c,bc);\n    gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc;\n}";
            ShaderLib.uifont_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesColorEx;                  \nattribute vec4 _glesMultiTexCoord0;         \nuniform highp mat4 glstate_matrix_mvp;      \nvarying lowp vec4 xlv_COLOR;                \nvarying lowp vec4 xlv_COLOREx;                                                 \nvarying highp vec2 xlv_TEXCOORD0;           \nvoid main() {                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_COLOREx = _glesColorEx;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}";
            ShaderLib.vertcolor_frag = "uniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() \n{\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}";
            ShaderLib.vertcolor_vert = "attribute vec4 _glesVertex;   \nattribute vec4 _glesNormal;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesMultiTexCoord0;        \nuniform highp mat4 glstate_matrix_mvp;   \nvarying lowp vec4 xlv_COLOR;                \nvarying highp vec2 xlv_TEXCOORD0;   \nuniform highp vec4 _MainTex_ST;       \nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;   \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}\n";
        })(ShaderLib = framework.ShaderLib || (framework.ShaderLib = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var SubClip = (function () {
            function SubClip() {
            }
            SubClip.caclByteLength = function () {
                var total = 0;
                total += egret3d.math.caclStringByteLength(name);
                total += 1;
                total += 8;
                return total;
            };
            return SubClip;
        }());
        framework.SubClip = SubClip;
        __reflect(SubClip.prototype, "egret3d.framework.SubClip");
        var AnimationClip = (function (_super) {
            __extends(AnimationClip, _super);
            function AnimationClip(name) {
                return _super.call(this, name, "animationClip") || this;
            }
            AnimationClip.prototype.dispose = function () {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            };
            AnimationClip.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.bones) {
                    total += egret3d.math.caclStringByteLength(this.bones[k]);
                }
                for (var k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += egret3d.math.caclStringByteLength(k);
                }
                total += SubClip.caclByteLength() * this.subclips.length;
                return total;
            };
            AnimationClip.prototype.Parse = function (buf) {
                var read = new egret3d.io.BinReader(buf);
                var _name = read.readStringAnsi();
                this.fps = read.readFloat();
                this.loop = read.readBoolean();
                this.boneCount = read.readInt();
                this.bones = [];
                for (var i = 0; i < this.boneCount; i++) {
                    this.bones.push(read.readStringAnsi());
                }
                this.subclipCount = read.readInt();
                this.subclips = [];
                for (var i = 0; i < this.subclipCount; i++) {
                    var _subClip = new SubClip();
                    _subClip.name = read.readStringAnsi();
                    _subClip.loop = read.readBoolean();
                    this.subclips.push(_subClip);
                }
                this.frameCount = read.readInt();
                this.frames = {};
                for (var i = 0; i < this.frameCount; i++) {
                    var _fid = read.readInt().toString();
                    var _key = read.readBoolean();
                    var _frame = new Float32Array(this.boneCount * 7 + 1);
                    _frame[0] = _key ? 1 : 0;
                    var _boneInfo = new PoseBoneMatrix();
                    for (var i_1 = 0; i_1 < this.boneCount; i_1++) {
                        _boneInfo.load(read);
                        _frame[i_1 * 7 + 1] = _boneInfo.r.x;
                        _frame[i_1 * 7 + 2] = _boneInfo.r.y;
                        _frame[i_1 * 7 + 3] = _boneInfo.r.z;
                        _frame[i_1 * 7 + 4] = _boneInfo.r.w;
                        _frame[i_1 * 7 + 5] = _boneInfo.t.x;
                        _frame[i_1 * 7 + 6] = _boneInfo.t.y;
                        _frame[i_1 * 7 + 7] = _boneInfo.t.z;
                    }
                    this.frames[_fid] = _frame;
                }
                buf = null;
            };
            AnimationClip = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], AnimationClip);
            return AnimationClip;
        }(framework.Asset));
        framework.AnimationClip = AnimationClip;
        __reflect(AnimationClip.prototype, "egret3d.framework.AnimationClip");
        var PoseBoneMatrix = (function () {
            function PoseBoneMatrix() {
            }
            PoseBoneMatrix_1 = PoseBoneMatrix;
            PoseBoneMatrix.caclByteLength = function () {
                var total = 12 + 16;
                return total;
            };
            PoseBoneMatrix.prototype.Clone = function () {
                var p = new PoseBoneMatrix_1();
                p.t = new egret3d.math.Vector3();
                p.r = new egret3d.math.Quaternion();
                egret3d.math.vec3Clone(this.t, p.t);
                egret3d.math.quatClone(this.r, p.r);
                return p;
            };
            PoseBoneMatrix.prototype.load = function (read) {
                var x, y, z, w;
                x = read.readSingle();
                y = read.readSingle();
                z = read.readSingle();
                w = read.readSingle();
                this.r = new egret3d.math.Quaternion(x, y, z, w);
                x = read.readSingle();
                y = read.readSingle();
                z = read.readSingle();
                this.t = new egret3d.math.Vector3(x, y, z);
            };
            PoseBoneMatrix.createDefault = function () {
                var pt = new PoseBoneMatrix_1();
                pt.r = new egret3d.math.Quaternion(0, 0, 0, 1);
                pt.t = new egret3d.math.Vector3(0, 0, 0);
                return pt;
            };
            PoseBoneMatrix.prototype.copyFrom = function (src) {
                this.r.x = src.r.x;
                this.r.y = src.r.y;
                this.r.z = src.r.z;
                this.r.w = src.r.w;
                this.t.x = src.t.x;
                this.t.y = src.t.y;
                this.t.z = src.t.z;
            };
            PoseBoneMatrix.prototype.copyFromData = function (src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
            };
            PoseBoneMatrix.prototype.invert = function () {
                egret3d.math.quatInverse(this.r, this.r);
                egret3d.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            };
            PoseBoneMatrix.prototype.lerpInWorld = function (_tpose, from, to, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.prototype.lerpInWorldWithData = function (_tpose, from, todata, toseek, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.sMultiply = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null) {
                    target = PoseBoneMatrix_1.createDefault();
                }
                var dir = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(right.t, dir);
                var dirtran = egret3d.math.Pool.new_vector3();
                egret3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                egret3d.math.quatMultiply(left.r, right.r, target.r);
                egret3d.math.Pool.delete_vector3(dir);
                egret3d.math.Pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplyDataAndMatrix = function (leftdata, leftseek, right, target) {
                if (target === void 0) { target = null; }
                if (target == null) {
                    target = PoseBoneMatrix_1.createDefault();
                }
                var dir = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(right.t, dir);
                var dirtran = egret3d.math.Pool.new_vector3();
                egret3d.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                egret3d.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                egret3d.math.Pool.delete_vector3(dir);
                egret3d.math.Pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sLerp = function (left, right, v, target) {
                if (target === void 0) { target = null; }
                if (target == null) {
                    target = PoseBoneMatrix_1.createDefault();
                }
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                egret3d.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            };
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], PoseBoneMatrix.prototype, "t", void 0);
            __decorate([
                egret3d.reflect.Field("Quaternion"),
                __metadata("design:type", egret3d.math.Quaternion)
            ], PoseBoneMatrix.prototype, "r", void 0);
            PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
                egret3d.reflect.SerializeType
            ], PoseBoneMatrix);
            return PoseBoneMatrix;
            var PoseBoneMatrix_1;
        }());
        framework.PoseBoneMatrix = PoseBoneMatrix;
        __reflect(PoseBoneMatrix.prototype, "egret3d.framework.PoseBoneMatrix");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var AssetBundle = (function (_super) {
            __extends(AssetBundle, _super);
            function AssetBundle(name) {
                var _this = _super.call(this, name, "bundle_") || this;
                _this.files = [];
                _this.packages = [];
                _this.mapNamed = {};
                return _this;
            }
            AssetBundle.prototype.find = function (name) {
                return framework.AssetMap.find(name, this._name);
            };
            AssetBundle.prototype.dispose = function () {
            };
            AssetBundle.prototype.caclByteLength = function () {
                return 0;
            };
            AssetBundle.prototype.parse = function (json) {
                var files = json["files"];
                for (var i = 0; i < files.length; i++) {
                    var item = files[i];
                    var packes = -1;
                    if (item.packes != undefined) {
                        packes = item.packes;
                    }
                    this.files.push({ name: item.name, length: item.length, packes: packes });
                }
                if (json["packes"] != undefined) {
                    var packes = json["packes"];
                    for (var i = 0; i < packes.length; i++) {
                        this.packages.push(packes[i]);
                    }
                }
            };
            return AssetBundle;
        }(framework.Asset));
        framework.AssetBundle = AssetBundle;
        __reflect(AssetBundle.prototype, "egret3d.framework.AssetBundle");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Atlas = (function (_super) {
            __extends(Atlas, _super);
            function Atlas(name) {
                var _this = _super.call(this, name, "atlas") || this;
                _this.sprites = {};
                return _this;
            }
            Atlas.prototype.dispose = function () {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            };
            Atlas.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += egret3d.math.caclStringByteLength(k);
                }
                return total;
            };
            Object.defineProperty(Atlas.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Atlas.prototype.Parse = function (jsonStr) {
                var json = JSON.parse(jsonStr);
                var name = json["t"];
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = framework.AssetMap.find(name);
                if (this.texture == null) {
                    console.log("atlas texture not found");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.Sprite(this.getName() + "_" + spriteName);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new egret3d.math.Rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new egret3d.math.Border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
            };
            Atlas = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Atlas);
            return Atlas;
        }(framework.Asset));
        framework.Atlas = Atlas;
        __reflect(Atlas.prototype, "egret3d.framework.Atlas");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Charinfo = (function () {
            function Charinfo() {
            }
            Charinfo.caclByteLength = function () {
                return 36;
            };
            return Charinfo;
        }());
        framework.Charinfo = Charinfo;
        __reflect(Charinfo.prototype, "egret3d.framework.Charinfo");
        var Font = (function (_super) {
            __extends(Font, _super);
            function Font(name) {
                return _super.call(this, name, "font") || this;
            }
            Font.prototype.dispose = function () {
                if (this.texture) {
                    this.texture.unuse(true);
                }
                delete this.cmap;
            };
            Font.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.cmap) {
                    total += egret3d.math.caclStringByteLength(k);
                    total += Charinfo.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(Font.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Font.prototype.Parse = function (jsonStr) {
                var d1 = new Date().valueOf();
                var json = JSON.parse(jsonStr);
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = framework.AssetMap.find(picName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                this.cmap = {};
                var map = json["map"];
                for (var c in map) {
                    var finfo = new Charinfo();
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                var d2 = new Date().valueOf();
                var n = d2 - d1;
            };
            Font = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Font);
            return Font;
        }(framework.Asset));
        framework.Font = Font;
        __reflect(Font.prototype, "egret3d.framework.Font");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var UniformData = (function () {
            function UniformData(type, value, defaultValue) {
                if (defaultValue === void 0) { defaultValue = null; }
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
            __decorate([
                egret3d.reflect.Field("number"),
                egret3d.reflect.UIStyle("UniformTypeEnum"),
                __metadata("design:type", Number)
            ], UniformData.prototype, "type", void 0);
            __decorate([
                egret3d.reflect.Field("any"),
                __metadata("design:type", Object)
            ], UniformData.prototype, "value", void 0);
            UniformData = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Object, Object])
            ], UniformData);
            return UniformData;
        }());
        framework.UniformData = UniformData;
        __reflect(UniformData.prototype, "egret3d.framework.UniformData");
        var Material = (function (_super) {
            __extends(Material, _super);
            function Material(name) {
                var _this = _super.call(this, name, "material") || this;
                _this.version = 0;
                _this._changeShaderMap = {};
                _this.mapUniform = {};
                _this.mapUniformTemp = {};
                egret3d.io.EnumMgr.enumMap["UniformTypeEnum"] = egret3d.render.UniformTypeEnum;
                return _this;
            }
            Material_1 = Material;
            Material.prototype.dispose = function () {
                for (var id in this.mapUniform) {
                    switch (this.mapUniform[id].type) {
                        case egret3d.render.UniformTypeEnum.Texture:
                            if (this.mapUniform[id] != null && this.mapUniform[id].value != null) {
                                this.mapUniform[id].value.unuse(true);
                            }
                            break;
                    }
                }
                delete this.mapUniform;
                delete this.mapUniformTemp;
                this.version++;
            };
            Material.prototype.caclByteLength = function () {
                var total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (var k in this.mapUniform) {
                    var type = this.mapUniform[k].type;
                    var value = this.mapUniform[k].value;
                    var defaultValue = this.mapUniform[k].defaultValue;
                    switch (type) {
                        case egret3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case egret3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Texture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                for (var k in this.mapUniformTemp) {
                    var type = this.mapUniformTemp[k].type;
                    var value = this.mapUniformTemp[k].value;
                    var defaultValue = this.mapUniformTemp[k].defaultValue;
                    switch (type) {
                        case egret3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case egret3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case egret3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case egret3d.render.UniformTypeEnum.Texture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            };
            Material.prototype.initUniformData = function (passes) {
                this.version++;
                if (passes == null)
                    return;
                for (var i = 0; i < passes.length; i++) {
                    var p = passes[i];
                    for (var key in p.uniforms) {
                        if (key.indexOf("glstate_") >= 0 || key.indexOf("_LightmapTex") >= 0)
                            continue;
                        var type = p.uniforms[key];
                        var defv = this.shader.defaultValue[key];
                        if (defv != null) {
                            this.mapUniform[key] = new UniformData(type, defv.value, defv.defaultValue);
                            continue;
                        }
                        if (this.mapUniform[key] != null) {
                            continue;
                        }
                        if (type == egret3d.render.UniformTypeEnum.Float) {
                            this.mapUniform[key] = new UniformData(type, null, 0);
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Floatv) {
                            this.mapUniform[key] = new UniformData(type, null, new Float32Array(0));
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Float4) {
                            var _v4 = new egret3d.math.Vector4();
                            if (key.indexOf("_ST") > 0) {
                                _v4.x = 1;
                                _v4.y = 1;
                            }
                            this.mapUniform[key] = new UniformData(type, null, _v4);
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Float4v) {
                            this.mapUniform[key] = new UniformData(type, null, new Float32Array(0));
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Float4x4) {
                            this.mapUniform[key] = new UniformData(type, null, new egret3d.math.Matrix());
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Float4x4v) {
                            this.mapUniform[key] = new UniformData(type, null, new Float32Array(0));
                        }
                        else if (type == egret3d.render.UniformTypeEnum.Texture) {
                            this.mapUniform[key] = new UniformData(type, null);
                        }
                    }
                }
            };
            Material.prototype.setShader = function (shader) {
                this.shader = shader;
                this.mapUniform = {};
                this.initUniformData(this.shader.passes["base"]);
            };
            Material.prototype.getShader = function () {
                return this.shader;
            };
            Material.prototype.changeShader = function (shader) {
                var map;
                if (this._changeShaderMap[shader.getName()] != undefined) {
                    map = this._changeShaderMap[shader.getName()].mapUniform;
                }
                else {
                    var mat = this.clone();
                    map = mat.mapUniform;
                    this._changeShaderMap[shader.getName()] = mat;
                }
                this.setShader(shader);
                for (var key in map) {
                    if (this.mapUniform[key] != undefined) {
                        this.mapUniform[key] = map[key];
                    }
                }
            };
            Material.prototype.getLayer = function () {
                return this.shader.layer;
            };
            Material.prototype.getQueue = function () {
                return this.shader.queue;
            };
            Material.prototype.setFloat = function (_id, _number) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _number;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Float, _number);
                }
                this.version++;
            };
            Material.prototype.setFloatv = function (_id, _numbers) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _numbers;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Floatv, _numbers);
                }
                this.version++;
            };
            Material.prototype.setVector4 = function (_id, _vector4) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _vector4;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Float4, _vector4);
                }
                this.version++;
            };
            Material.prototype.setVector4v = function (_id, _vector4v) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _vector4v;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Float4v, _vector4v);
                }
                this.version++;
            };
            Material.prototype.setMatrix = function (_id, _matrix) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _matrix;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Float4x4, _matrix);
                }
                this.version++;
            };
            Material.prototype.setMatrixv = function (_id, _matrixv) {
                if (this.mapUniform[_id] != undefined) {
                    this.mapUniform[_id].value = _matrixv;
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Float4x4v, _matrixv);
                }
                this.version++;
            };
            Material.prototype.setTexture = function (_id, _texture) {
                if (this.mapUniform[_id] != undefined) {
                    if (this.mapUniform[_id].value) {
                        this.mapUniform[_id].value.unuse();
                    }
                    this.mapUniform[_id].value = _texture;
                    if (_texture != null) {
                        _texture.use();
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (this.mapUniform[_texelsizeName] != undefined) {
                            this.setVector4(_texelsizeName, new egret3d.math.Vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(egret3d.render.UniformTypeEnum.Texture, _texture);
                }
                this.version++;
            };
            Material.prototype.draw = function (context, mesh, sm, basetype) {
                if (basetype === void 0) { basetype = "base"; }
                var drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined) {
                    drawPasses = this.shader.passes["base" + context.drawtype];
                }
                if (drawPasses == undefined) {
                    return;
                }
                for (var i = 0; i < drawPasses.length; i++) {
                    var pass = drawPasses[i];
                    var program = pass.program;
                    var force = pass.use(context.webgl);
                    program.uploadUniforms(this, context, force);
                    program.bindAttributes(mesh.glMesh, sm.useVertexIndex, force);
                    if (sm.useVertexIndex < 0) {
                        if (sm.line) {
                            egret3d.render.Webglkit.drawArrayLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            egret3d.render.Webglkit.drawArrayTris(context.webgl, sm.start, sm.size);
                        }
                    }
                    else {
                        if (sm.line) {
                            egret3d.render.Webglkit.drawElementLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            egret3d.render.Webglkit.drawElementTris(context.webgl, sm.start, sm.size);
                        }
                    }
                }
                this.mapUniformTemp = {};
            };
            Material.prototype.Parse = function (json) {
                var shaderName = json["shader"];
                this.setShader(framework.AssetMap.find(shaderName));
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    switch (_uniformType) {
                        case egret3d.render.UniformTypeEnum.Texture:
                            var _value = jsonChild["value"];
                            var _texture = framework.AssetMap.find(_value);
                            if (_texture == undefined) {
                                _texture = framework.DefaultTextures.Grid;
                            }
                            this.setTexture(i, _texture);
                            break;
                        case egret3d.render.UniformTypeEnum.Float:
                            var __value = jsonChild["value"];
                            this.setFloat(i, parseFloat(__value));
                            break;
                        case egret3d.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                var values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new egret3d.math.Vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                                console.log(e);
                            }
                            break;
                        default:
                            console.log("map uniform type in material json <" + jsonChild["type"] + "> out of range（0-2）!");
                    }
                }
            };
            Material.prototype.clone = function () {
                var mat = new Material_1(this.getName());
                mat.setShader(this.shader);
                for (var i in this.mapUniform) {
                    var data = this.mapUniform[i];
                    var _uniformType = data.type;
                    switch (_uniformType) {
                        case egret3d.render.UniformTypeEnum.Texture:
                            mat.setTexture(i, data.value);
                            break;
                        case egret3d.render.UniformTypeEnum.Float:
                            mat.setFloat(i, data.value);
                            break;
                        case egret3d.render.UniformTypeEnum.Float4:
                            mat.setVector4(i, data.value);
                            break;
                        default:
                            break;
                    }
                }
                return mat;
            };
            __decorate([
                egret3d.reflect.Field("Shader"),
                __metadata("design:type", framework.Shader)
            ], Material.prototype, "shader", void 0);
            __decorate([
                egret3d.reflect.Field("UniformDataDic"),
                __metadata("design:type", Object)
            ], Material.prototype, "mapUniform", void 0);
            Material = Material_1 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Material);
            return Material;
            var Material_1;
        }(framework.Asset));
        framework.Material = Material;
        __reflect(Material.prototype, "egret3d.framework.Material");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var SubMeshInfo = (function () {
            function SubMeshInfo() {
                this.useVertexIndex = 0;
                this.line = false;
            }
            return SubMeshInfo;
        }());
        framework.SubMeshInfo = SubMeshInfo;
        __reflect(SubMeshInfo.prototype, "egret3d.framework.SubMeshInfo");
        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            function Mesh(name) {
                var _this = _super.call(this, name, "mesh") || this;
                _this.submesh = [];
                return _this;
            }
            Mesh_1 = Mesh;
            Mesh.prototype.dispose = function () {
                this.glMesh.dispose(egret3d.render.Webglkit.webgl);
                this.data = null;
                delete this.submesh;
            };
            Mesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            };
            Mesh.prototype.Parse = function (buf, webgl) {
                var vf = 0;
                var data = new egret3d.render.MeshData();
                var read = new egret3d.io.BinReader(buf);
                var meshName = read.readStringAnsi();
                read.position = read.position + 24;
                var vcount = read.readUInt32();
                var vec10tpose = [];
                while (true) {
                    var tag = read.readUInt8();
                    if (tag == 255)
                        break;
                    if (tag == 1) {
                        if (data.pos == undefined) {
                            data.pos = [];
                            vf = vf | egret3d.render.VertexFormatMask.Position;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _position = new egret3d.math.Vector3();
                            _position.x = read.readSingle();
                            _position.y = read.readSingle();
                            _position.z = read.readSingle();
                            data.pos.push(_position);
                        }
                    }
                    else if (tag == 2) {
                        if (data.color == undefined) {
                            data.color = [];
                            vf = vf | egret3d.render.VertexFormatMask.Color;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _color = new egret3d.math.Color();
                            _color.a = read.readUInt8();
                            _color.r = read.readUInt8();
                            _color.g = read.readUInt8();
                            _color.b = read.readUInt8();
                            data.color.push(_color);
                        }
                    }
                    else if (tag == 3) {
                        if (data.normal == undefined) {
                            data.normal = [];
                            vf = vf | egret3d.render.VertexFormatMask.Normal;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _normal = new egret3d.math.Vector3();
                            _normal.x = read.readSingle();
                            _normal.y = read.readSingle();
                            _normal.z = read.readSingle();
                            data.normal.push(_normal);
                        }
                    }
                    else if (tag == 4) {
                        if (data.uv == undefined) {
                            data.uv = [];
                            vf = vf | egret3d.render.VertexFormatMask.UV0;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var uv = new egret3d.math.Vector2();
                            uv.x = read.readSingle();
                            uv.y = 1 - read.readSingle();
                            data.uv.push(uv);
                        }
                    }
                    else if (tag == 5) {
                        if (data.uv2 == undefined) {
                            data.uv2 = [];
                            vf = vf | egret3d.render.VertexFormatMask.UV1;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var uv = new egret3d.math.Vector2();
                            uv.x = read.readSingle();
                            uv.y = 1 - read.readSingle();
                            data.uv2.push(uv);
                        }
                    }
                    else if (tag == 6) {
                        for (var i = 0; i < vcount; i++) {
                            read.readSingle();
                            1 - read.readSingle();
                        }
                    }
                    else if (tag == 7) {
                        if (data.tangent == undefined) {
                            data.tangent = [];
                            vf = vf | egret3d.render.VertexFormatMask.Tangent;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var tangent = new egret3d.math.Vector3();
                            var x = read.readSingle();
                            var y = read.readSingle();
                            var z = read.readSingle();
                            var w = read.readSingle();
                            tangent.x = x / w;
                            tangent.y = y / w;
                            tangent.z = z / w;
                            data.tangent.push(tangent);
                        }
                    }
                    else if (tag == 8) {
                        for (var i = 0; i < vcount; i++) {
                            read.readSingle();
                            1 - read.readSingle();
                        }
                    }
                    else if (tag == 16) {
                        var tposelen = read.readUInt8();
                        for (var i = 0; i < tposelen; i++) {
                            vec10tpose[i * 10 + 0] = read.readSingle();
                            vec10tpose[i * 10 + 1] = read.readSingle();
                            vec10tpose[i * 10 + 2] = read.readSingle();
                            vec10tpose[i * 10 + 3] = read.readSingle();
                            vec10tpose[i * 10 + 4] = read.readSingle();
                            vec10tpose[i * 10 + 5] = read.readSingle();
                            vec10tpose[i * 10 + 6] = read.readSingle();
                            vec10tpose[i * 10 + 7] = read.readSingle();
                            vec10tpose[i * 10 + 8] = read.readSingle();
                            vec10tpose[i * 10 + 9] = read.readSingle();
                        }
                    }
                    else if (tag == 17) {
                        if (data.blendIndex == undefined) {
                            data.blendIndex = [];
                            vf = vf | egret3d.render.VertexFormatMask.BlendIndex4;
                        }
                        if (data.blendWeight == undefined) {
                            data.blendWeight = [];
                            vf = vf | egret3d.render.VertexFormatMask.BlendWeight4;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _boneIndex = new egret3d.render.Number4();
                            _boneIndex.v0 = read.readUInt32();
                            _boneIndex.v1 = read.readUInt32();
                            _boneIndex.v2 = read.readUInt32();
                            _boneIndex.v3 = read.readUInt32();
                            var _boneWeight = new egret3d.render.Number4();
                            _boneWeight.v0 = read.readSingle();
                            _boneWeight.v1 = read.readSingle();
                            _boneWeight.v2 = read.readSingle();
                            _boneWeight.v3 = read.readSingle();
                            data.blendIndex.push(_boneIndex);
                            data.blendWeight.push(_boneWeight);
                        }
                    }
                    else {
                        throw "not write " + tag;
                    }
                }
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new SubMeshInfo();
                    var tv = read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                this.data = data;
                this.glMesh = new egret3d.render.GlMesh();
                var vertexs = this.data.genVertexDataArray(vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, vf, this.data.pos.length);
                this.glMesh.uploadVertexSubData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexSubData(webgl, 0, indices);
            };
            Mesh.prototype.intersects = function (ray, matrix) {
                var pickinfo = null;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                        }
                        else {
                            var t0 = egret3d.math.Pool.new_vector3();
                            var t1 = egret3d.math.Pool.new_vector3();
                            var t2 = egret3d.math.Pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                var p0 = this.data.pos[this.data.trisindex[index]];
                                var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                egret3d.math.matrixTransformVector3(p0, matrix, t0);
                                egret3d.math.matrixTransformVector3(p1, matrix, t1);
                                egret3d.math.matrixTransformVector3(p2, matrix, t2);
                                var result = ray.intersectsTriangle(t0, t1, t2);
                                if (result) {
                                    if (result.distance < 0)
                                        continue;
                                    if (!pickinfo || pickinfo.distance > result.distance) {
                                        pickinfo = result;
                                        pickinfo.faceId = index / 3;
                                        pickinfo.subMeshId = i;
                                        var tdir = egret3d.math.Pool.new_vector3();
                                        egret3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                        egret3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                                    }
                                }
                            }
                            egret3d.math.Pool.delete_vector3(t0);
                            egret3d.math.Pool.delete_vector3(t1);
                            egret3d.math.Pool.delete_vector3(t2);
                        }
                    }
                }
                return pickinfo;
            };
            Mesh.prototype.clone = function () {
                var _result = new Mesh_1(this.getName());
                var vf = this.glMesh.vertexFormat;
                var data = new egret3d.render.MeshData();
                if (this.data.pos != undefined) {
                    data.pos = [];
                    for (var i = 0; i < this.data.pos.length; i++) {
                        var _position = new egret3d.math.Vector3();
                        _position.x = this.data.pos[i].x;
                        _position.y = this.data.pos[i].y;
                        _position.z = this.data.pos[i].z;
                        data.pos.push(_position);
                    }
                }
                if (this.data.color != undefined) {
                    data.color = [];
                    for (var i = 0; i < this.data.color.length; i++) {
                        var _color = new egret3d.math.Color();
                        _color.a = this.data.color[i].a;
                        _color.r = this.data.color[i].r;
                        _color.g = this.data.color[i].g;
                        _color.b = this.data.color[i].b;
                        data.color.push(_color);
                    }
                }
                if (this.data.normal != undefined) {
                    data.normal = [];
                    for (var i = 0; i < this.data.normal.length; i++) {
                        var _normal = new egret3d.math.Vector3();
                        _normal.x = this.data.normal[i].x;
                        _normal.y = this.data.normal[i].y;
                        _normal.z = this.data.normal[i].z;
                        data.normal.push(_normal);
                    }
                }
                if (this.data.uv != undefined) {
                    data.uv = [];
                    for (var i = 0; i < this.data.uv.length; i++) {
                        var uv = new egret3d.math.Vector2();
                        uv.x = this.data.uv[i].x;
                        uv.y = this.data.uv[i].y;
                        data.uv.push(uv);
                    }
                }
                if (this.data.uv2 != undefined) {
                    data.uv2 = [];
                    for (var i = 0; i < this.data.uv2.length; i++) {
                        var uv = new egret3d.math.Vector2();
                        uv.x = this.data.uv2[i].x;
                        uv.y = this.data.uv2[i].y;
                        data.uv2.push(uv);
                    }
                }
                if (this.data.tangent != undefined) {
                    data.tangent = [];
                    for (var i = 0; i < this.data.tangent.length; i++) {
                        var tangent = new egret3d.math.Vector3();
                        tangent.x = this.data.tangent[i].x;
                        tangent.y = this.data.tangent[i].y;
                        tangent.z = this.data.tangent[i].z;
                        data.tangent.push(tangent);
                    }
                }
                if (this.data.blendIndex != undefined) {
                    data.blendIndex = [];
                    for (var i = 0; i < this.data.blendIndex.length; i++) {
                        var _boneIndex = new egret3d.render.Number4();
                        _boneIndex.v0 = this.data.blendIndex[i].v0;
                        _boneIndex.v1 = this.data.blendIndex[i].v1;
                        _boneIndex.v2 = this.data.blendIndex[i].v2;
                        _boneIndex.v3 = this.data.blendIndex[i].v3;
                        data.blendIndex.push(_boneIndex);
                    }
                }
                if (this.data.blendWeight != undefined) {
                    data.blendWeight = [];
                    for (var i = 0; i < this.data.blendWeight.length; i++) {
                        var _boneWeight = new egret3d.render.Number4();
                        _boneWeight.v0 = this.data.blendWeight[i].v0;
                        _boneWeight.v1 = this.data.blendWeight[i].v1;
                        _boneWeight.v2 = this.data.blendWeight[i].v2;
                        _boneWeight.v3 = this.data.blendWeight[i].v3;
                        data.blendWeight.push(_boneWeight);
                    }
                }
                _result.submesh = [];
                for (var i = 0; i < this.submesh.length; i++) {
                    var _submeshinfo = new SubMeshInfo();
                    _submeshinfo.start = this.submesh[i].start;
                    _submeshinfo.size = this.submesh[i].size;
                    _submeshinfo.matIndex = i;
                    _result.submesh.push(_submeshinfo);
                }
                data.trisindex = this.data.trisindex.slice();
                _result.data = data;
                _result.glMesh = new egret3d.render.GlMesh();
                var vertexs = _result.data.genVertexDataArray(vf);
                var indices = _result.data.genIndexDataArray();
                var webgl = egret3d.render.Webglkit.webgl;
                _result.glMesh.initBuffer(webgl, vf, this.data.pos.length);
                _result.glMesh.uploadVertexSubData(webgl, vertexs);
                _result.glMesh.addIndex(webgl, indices.length);
                _result.glMesh.uploadIndexSubData(webgl, 0, indices);
                return _result;
            };
            Mesh = Mesh_1 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Mesh);
            return Mesh;
            var Mesh_1;
        }(framework.Asset));
        framework.Mesh = Mesh;
        __reflect(Mesh.prototype, "egret3d.framework.Mesh");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        var epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype || (epointtype = {}));
        var Pathasset = (function (_super) {
            __extends(Pathasset, _super);
            function Pathasset(name) {
                var _this = _super.call(this, name, "path") || this;
                _this.paths = [];
                _this.items = [];
                _this.lines = [];
                return _this;
            }
            Pathasset.prototype.dispose = function () {
                this.paths.length = 0;
            };
            Pathasset.prototype.caclByteLength = function () {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            };
            Pathasset.prototype.Parse = function (json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = { type: undefined, point: undefined };
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new egret3d.math.Vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                }
                this.getpaths();
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
            };
            Pathasset.prototype.getpaths = function () {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBezierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBezierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            };
            Pathasset.prototype.getBezierPointAlongCurve = function (points, rate, clearflag) {
                if (clearflag === void 0) { clearflag = false; }
                var length = points.length;
                if (points.length < 2) {
                    console.log("need more than 2 point to calculate bezier!");
                    return;
                }
                if (length == 2) {
                    var out = new egret3d.math.Vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = egret3d.math.Pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBezierPointAlongCurve(temptpoints, rate, true);
            };
            Pathasset.prototype.vec3Lerp = function (start, end, lerp, out) {
                egret3d.math.vec3Subtract(end, start, out);
                egret3d.math.vec3ScaleByNum(out, lerp, out);
                egret3d.math.vec3Add(start, out, out);
            };
            Pathasset = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Pathasset);
            return Pathasset;
        }(framework.Asset));
        framework.Pathasset = Pathasset;
        __reflect(Pathasset.prototype, "egret3d.framework.Pathasset");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Prefab = (function (_super) {
            __extends(Prefab, _super);
            function Prefab(name) {
                var _this = _super.call(this, name, "prefab") || this;
                _this.assetbundle = null;
                return _this;
            }
            Prefab.prototype.dispose = function () {
                this.trans.dispose();
                this.jsonstr = null;
            };
            Prefab.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            Prefab.prototype.getCloneTrans = function () {
                return egret3d.io.cloneObj(this.trans);
            };
            Prefab.prototype.apply = function (trans) {
                this.trans = trans;
            };
            Prefab.prototype.Parse = function (jsonStr) {
                jsonStr = jsonStr.replace(/localRotate/g, "localRotation");
                jsonStr = jsonStr.replace(/localTranslate/g, "localPosition");
                this.jsonstr = jsonStr;
                this.trans = new framework.Transform();
                egret3d.io.deSerialize(JSON.parse(jsonStr), this.trans, this.assetbundle);
            };
            Prefab = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Prefab);
            return Prefab;
        }(framework.Asset));
        framework.Prefab = Prefab;
        __reflect(Prefab.prototype, "egret3d.framework.Prefab");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Rawscene = (function (_super) {
            __extends(Rawscene, _super);
            function Rawscene(name) {
                var _this = _super.call(this, name, "rawscene") || this;
                _this.assetbundle = null;
                return _this;
            }
            Rawscene.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            Rawscene.prototype.Parse = function (txt) {
                txt = txt.replace(/localRotate/g, "localRotation");
                txt = txt.replace(/localTranslate/g, "localPosition");
                var _json = JSON.parse(txt);
                this.rootNode = new framework.Transform();
                this.rootNode.name = this.getName();
                egret3d.io.deSerialize(_json["rootNode"], this.rootNode, this.assetbundle);
                this.lightmaps = [];
                var lightmapData = _json["lightmap"];
                var lightmapCount = lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = lightmapData[i].name;
                        var lightmap = framework.AssetMap.find(lightmapName, this.assetbundle);
                        lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            };
            Rawscene.prototype.getSceneRoot = function () {
                return egret3d.io.cloneObj(this.rootNode);
            };
            Rawscene.prototype.useLightMap = function (scene) {
                scene.lightmaps.length = 0;
                for (var i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            };
            Rawscene.prototype.dispose = function () {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (var key in this.lightmaps) {
                    this.lightmaps[key].unuse(true);
                }
            };
            Rawscene = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Rawscene);
            return Rawscene;
        }(framework.Asset));
        framework.Rawscene = Rawscene;
        __reflect(Rawscene.prototype, "egret3d.framework.Rawscene");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var extractUniform = function (txt) {
            var uniforms = {};
            var lines1 = txt.split(";");
            for (var ii in lines1) {
                var lines = lines1[ii].split("\n");
                for (var i in lines) {
                    var line = lines[i];
                    var words = line.match(new RegExp("([_a-zA-Z0-9]+)|([/=;]+)", "g"));
                    if (words != null && words.length >= 3 && words[0] == "uniform") {
                        var t = words[1];
                        var n = words[2];
                        if (t == "highp" || t == "lowp" || t == "mediump") {
                            t = words[2];
                            n = words[3];
                        }
                        switch (t) {
                            case "sampler2D":
                                uniforms[n] = egret3d.render.UniformTypeEnum.Texture;
                                break;
                            case "float":
                                if (line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Floatv;
                                }
                                else {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Float;
                                }
                                break;
                            case "vec4":
                                if (line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Float4v;
                                }
                                else {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Float4;
                                }
                                break;
                            case "mat4":
                                if (line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Float4x4v;
                                }
                                else {
                                    uniforms[n] = egret3d.render.UniformTypeEnum.Float4x4;
                                }
                                break;
                            default:
                                throw new Error("uniform type:" + t + " not defined.");
                        }
                    }
                }
            }
            return uniforms;
        };
        var Shader = (function (_super) {
            __extends(Shader, _super);
            function Shader(name) {
                var _this = _super.call(this, name, "shader") || this;
                _this.passes = {};
                _this.defaultValue = {};
                _this.layer = framework.RenderLayerEnum.Common;
                _this.queue = 0;
                return _this;
            }
            Shader_1 = Shader;
            Shader.registerVertShader = function (name, src) {
                var info = {
                    name: name,
                    src: src,
                    uniforms: extractUniform(src)
                };
                this._vertShaderInfoMap[name] = info;
                return info;
            };
            Shader.registerFragShader = function (name, src) {
                var info = {
                    name: name,
                    src: src,
                    uniforms: extractUniform(src)
                };
                this._fragShaderInfoMap[name] = info;
                return info;
            };
            Shader.prototype.dispose = function () {
            };
            Shader.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            Shader.prototype.parse = function (json) {
                this._parseProperties(json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent") {
                        this.layer = framework.RenderLayerEnum.Transparent;
                    }
                    else if (layer == "overlay") {
                        this.layer = framework.RenderLayerEnum.Overlay;
                    }
                    else if (layer == "common") {
                        this.layer = framework.RenderLayerEnum.Common;
                    }
                }
                if (json.queue) {
                    this.queue = json.queue;
                }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses = void 0;
                    if (key == "base" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(passbass[i]));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base pass group.");
                }
            };
            Shader.prototype._parseProperties = function (properties) {
                this.defaultValue = {};
                for (var index in properties) {
                    var property = properties[index];
                    var words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        console.error(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        var key = words[1];
                        var showName = words[2];
                        var type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultValue[key] = { type: type, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                this.defaultValue[key] = { type: type, min: parseFloat(words[4]), max: parseFloat(words[5]), value: parseFloat(words[6]) };
                                break;
                            case "vector":
                            case "color":
                                var _vector = new egret3d.math.Vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultValue[key] = { type: type, value: _vector };
                                break;
                            case "texture":
                                this.defaultValue[key] = { type: type, defaultValue: framework.AssetMap.find(words[4]) };
                                break;
                            default:
                                alert(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            };
            Shader.prototype._parsePass = function (json) {
                var vs = Shader_1._vertShaderInfoMap[json["vs"]];
                if (!vs) {
                    console.error("vertex shader " + json["vs"] + " not found!");
                }
                var fs = Shader_1._fragShaderInfoMap[json["fs"]];
                if (!fs) {
                    console.error("fragment shader " + json["fs"] + " not found!");
                }
                var pass = new egret3d.render.GlDrawPass(vs, fs);
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = egret3d.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = egret3d.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = egret3d.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = egret3d.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = egret3d.render.Webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = egret3d.render.Webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = egret3d.render.Webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = egret3d.render.Webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = egret3d.render.Webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = egret3d.render.Webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = egret3d.render.Webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = egret3d.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = egret3d.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = egret3d.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = egret3d.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = egret3d.render.Webglkit.ALWAYS;
                }
                return pass;
            };
            Shader._vertShaderInfoMap = {};
            Shader._fragShaderInfoMap = {};
            Shader = Shader_1 = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Shader);
            return Shader;
            var Shader_1;
        }(framework.Asset));
        framework.Shader = Shader;
        __reflect(Shader.prototype, "egret3d.framework.Shader");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Sound = (function (_super) {
            __extends(Sound, _super);
            function Sound(name) {
                return _super.call(this, name, "sound") || this;
            }
            Sound.prototype.dispose = function () {
                this.buffer = null;
            };
            Sound.prototype.caclByteLength = function () {
                if (this.buffer) {
                    return this.buffer.length;
                }
            };
            Sound = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Sound);
            return Sound;
        }(framework.Asset));
        framework.Sound = Sound;
        __reflect(Sound.prototype, "egret3d.framework.Sound");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            function Sprite(name) {
                return _super.call(this, name, "sprite") || this;
            }
            Sprite.prototype.dispose = function () {
                if (this.texture != null) {
                    this.texture.unuse(true);
                }
            };
            Sprite.prototype.caclByteLength = function () {
                var total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(Sprite.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "urange", {
                get: function () {
                    if (this._urange == null) {
                        this._urange = new egret3d.math.Vector2();
                        this._urange.x = this.rect.x / this._texture.glTexture.width;
                        this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                    }
                    return this._urange;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "vrange", {
                get: function () {
                    if (this._vrange == null) {
                        this._vrange = new egret3d.math.Vector2();
                        this._vrange.x = this.rect.y / this._texture.glTexture.height;
                        this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                    }
                    return this._vrange;
                },
                enumerable: true,
                configurable: true
            });
            Sprite = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Sprite);
            return Sprite;
        }(framework.Asset));
        framework.Sprite = Sprite;
        __reflect(Sprite.prototype, "egret3d.framework.Sprite");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Textasset = (function (_super) {
            __extends(Textasset, _super);
            function Textasset(name) {
                return _super.call(this, name, "text") || this;
            }
            Textasset.prototype.dispose = function () {
                this.content == null;
            };
            Textasset.prototype.caclByteLength = function () {
                if (this.content) {
                    return egret3d.math.caclStringByteLength(this.content);
                }
            };
            Textasset = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Textasset);
            return Textasset;
        }(framework.Asset));
        framework.Textasset = Textasset;
        __reflect(Textasset.prototype, "egret3d.framework.Textasset");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Texture = (function (_super) {
            __extends(Texture, _super);
            function Texture(name) {
                return _super.call(this, name, "texture") || this;
            }
            Texture.prototype.dispose = function () {
                this.glTexture.dispose(egret3d.render.Webglkit.webgl);
            };
            Texture.prototype.caclByteLength = function () {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            };
            Object.defineProperty(Texture.prototype, "realName", {
                get: function () {
                    return this._realName;
                },
                set: function (name) {
                    this._realName = name;
                },
                enumerable: true,
                configurable: true
            });
            Texture = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], Texture);
            return Texture;
        }(framework.Asset));
        framework.Texture = Texture;
        __reflect(Texture.prototype, "egret3d.framework.Texture");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var sound;
    (function (sound) {
        var WebAudio = (function () {
            function WebAudio() {
                var _win = window;
                var _AudioContext = _win["AudioContext"] || _win["webkitAudioContext"] || _win["mozAudioContext"] || _win["msAudioContext"];
                if (!!_AudioContext) {
                    this._audioContext = new _AudioContext();
                    console.log("AudioContext inited --> ");
                    console.log(this._audioContext);
                }
                else {
                    console.warn("!Your browser does not support AudioContext");
                }
            }
            Object.defineProperty(WebAudio, "instance", {
                get: function () {
                    if (!this._instance) {
                        this._instance = new WebAudio();
                    }
                    return this._instance;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudio.prototype, "audioContext", {
                get: function () {
                    return this._audioContext;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudio.prototype, "isSupported", {
                get: function () {
                    return !!this._audioContext;
                },
                enumerable: true,
                configurable: true
            });
            WebAudio.prototype.active = function () {
                if (!this.isSupported) {
                    return;
                }
                var buffer = this._audioContext.createBuffer(1, 1, 22050);
                var source = this._audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(this._audioContext.destination);
                source.start();
            };
            WebAudio.prototype.decodeAudioData = function (buffer, onSuccess, onError) {
                this._audioContext.decodeAudioData(buffer, function (audiobuffer) { return onSuccess(audiobuffer); }, function () { return onError(); });
            };
            WebAudio.prototype.getAudioListener = function () {
                if (!this.audioListener) {
                    this.audioListener = new sound.WebAudioListener();
                }
                return this.audioListener;
            };
            return WebAudio;
        }());
        sound.WebAudio = WebAudio;
        __reflect(WebAudio.prototype, "egret3d.sound.WebAudio");
    })(sound = egret3d.sound || (egret3d.sound = {}));
})(egret3d || (egret3d = {}));
var RES;
(function (RES) {
    var processor;
    (function (processor) {
        var AssetTypeEnum;
        (function (AssetTypeEnum) {
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            AssetTypeEnum[AssetTypeEnum["CompressBundle"] = 3] = "CompressBundle";
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 4] = "GLVertexShader";
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 5] = "GLFragmentShader";
            AssetTypeEnum[AssetTypeEnum["Shader"] = 6] = "Shader";
            AssetTypeEnum[AssetTypeEnum["Texture"] = 7] = "Texture";
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 8] = "TextureDesc";
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 9] = "Mesh";
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 10] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["Material"] = 11] = "Material";
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 12] = "Aniclip";
            AssetTypeEnum[AssetTypeEnum["Scene"] = 13] = "Scene";
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 14] = "Atlas";
            AssetTypeEnum[AssetTypeEnum["Font"] = 15] = "Font";
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 16] = "TextAsset";
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 17] = "PackBin";
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 18] = "PackTxt";
            AssetTypeEnum[AssetTypeEnum["pathAsset"] = 19] = "pathAsset";
            AssetTypeEnum[AssetTypeEnum["PVR"] = 20] = "PVR";
            AssetTypeEnum[AssetTypeEnum["Sound"] = 21] = "Sound";
        })(AssetTypeEnum = processor.AssetTypeEnum || (processor.AssetTypeEnum = {}));
        function calcType(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            var i = file.indexOf(".", 0);
            var extname = null;
            while (i >= 0) {
                extname = file.substr(i);
                if (extname == ".vs.glsl") {
                    return AssetTypeEnum.GLVertexShader;
                }
                else if (extname == ".assetbundle.json") {
                    return AssetTypeEnum.Bundle;
                }
                else if (extname == ".fs.glsl") {
                    return AssetTypeEnum.GLFragmentShader;
                }
                else if (extname == ".shader.json") {
                    return AssetTypeEnum.Shader;
                }
                else if (extname == ".png" || extname == ".jpg") {
                    return AssetTypeEnum.Texture;
                }
                else if (extname == ".pvr.bin" || extname == ".pvr") {
                    return AssetTypeEnum.PVR;
                }
                else if (extname == ".imgdesc.json") {
                    return AssetTypeEnum.TextureDesc;
                }
                else if (extname == ".mat.json") {
                    return AssetTypeEnum.Material;
                }
                else if (extname == ".mesh.bin") {
                    return AssetTypeEnum.Mesh;
                }
                else if (extname == ".aniclip.bin") {
                    return AssetTypeEnum.Aniclip;
                }
                else if (extname == ".prefab.json") {
                    return AssetTypeEnum.Prefab;
                }
                else if (extname == ".scene.json") {
                    return AssetTypeEnum.Scene;
                }
                else if (extname == ".atlas.json") {
                    return AssetTypeEnum.Atlas;
                }
                else if (extname == ".font.json") {
                    return AssetTypeEnum.Font;
                }
                else if (extname == ".json" || extname == ".txt" || extname == ".effect.json") {
                    return AssetTypeEnum.TextAsset;
                }
                else if (extname == ".packs.bin") {
                    return AssetTypeEnum.PackBin;
                }
                else if (extname == ".packs.txt") {
                    return AssetTypeEnum.PackTxt;
                }
                else if (extname == ".path.json") {
                    return AssetTypeEnum.pathAsset;
                }
                else if (extname == ".mp3" || extname == ".ogg") {
                    return AssetTypeEnum.Sound;
                }
                i = file.indexOf(".", i + 1);
            }
            return AssetTypeEnum.Unknown;
        }
        function getFileName(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            return file;
        }
        ;
        function getUrl(url) {
            return RES.resourceRoot + url;
        }
        function getBundleUrlList(bundle) {
            var glvshaders = [];
            var glfshaders = [];
            var shaders = [];
            var meshs = [];
            var textures = [];
            var texturedescs = [];
            var materials = [];
            var anclips = [];
            var prefabs = [];
            var scenes = [];
            var textassets = [];
            var pvrs = [];
            var mapPackes = {};
            for (var i = 0; i < bundle.files.length; i++) {
                var fitem = bundle.files[i];
                var type = calcType(fitem.name);
                var url = bundle.path + "/" + fitem.name;
                if (fitem.packes != -1) {
                    mapPackes[url] = fitem.packes;
                }
                switch (type) {
                    case AssetTypeEnum.GLFragmentShader: {
                        glfshaders.push(url);
                        break;
                    }
                    case AssetTypeEnum.GLVertexShader: {
                        glvshaders.push(url);
                        break;
                    }
                    case AssetTypeEnum.Shader: {
                        shaders.push(url);
                        break;
                    }
                    case AssetTypeEnum.Texture: {
                        textures.push(url);
                        break;
                    }
                    case AssetTypeEnum.TextureDesc: {
                        texturedescs.push(url);
                        break;
                    }
                    case AssetTypeEnum.Mesh: {
                        meshs.push(url);
                        break;
                    }
                    case AssetTypeEnum.Material: {
                        materials.push(url);
                        break;
                    }
                    case AssetTypeEnum.Aniclip: {
                        anclips.push(url);
                        break;
                    }
                    case AssetTypeEnum.Prefab: {
                        prefabs.push(url);
                        break;
                    }
                    case AssetTypeEnum.Scene: {
                        scenes.push(url);
                        break;
                    }
                    case AssetTypeEnum.TextAsset: {
                        textassets.push(url);
                        break;
                    }
                    case AssetTypeEnum.PVR: {
                        pvrs.push(url);
                        break;
                    }
                }
            }
            var list = [];
            for (var i = 0; i < bundle.packages.length; i++) {
                var pack = bundle.packages[i];
                var type = this.calcType(pack);
                var url = bundle.path + "/" + pack;
                list.push({ url: url, type: type });
            }
            for (var i = 0; i < glvshaders.length; i++) {
                list.push({ url: glvshaders[i], type: AssetTypeEnum.GLVertexShader });
            }
            for (var i = 0; i < glfshaders.length; i++) {
                list.push({ url: glfshaders[i], type: AssetTypeEnum.GLFragmentShader });
            }
            for (var i = 0; i < shaders.length; i++) {
                list.push({ url: shaders[i], type: AssetTypeEnum.Shader });
            }
            for (var i = 0; i < textures.length; i++) {
                list.push({ url: textures[i], type: AssetTypeEnum.Texture });
            }
            for (var i = 0; i < texturedescs.length; i++) {
                list.push({ url: texturedescs[i], type: AssetTypeEnum.TextureDesc });
            }
            for (var i = 0; i < meshs.length; i++) {
                list.push({ url: meshs[i], type: AssetTypeEnum.Mesh });
            }
            for (var i = 0; i < materials.length; i++) {
                list.push({ url: materials[i], type: AssetTypeEnum.Material });
            }
            for (var i = 0; i < anclips.length; i++) {
                list.push({ url: anclips[i], type: AssetTypeEnum.Aniclip });
            }
            for (var i = 0; i < prefabs.length; i++) {
                list.push({ url: prefabs[i], type: AssetTypeEnum.Prefab });
            }
            for (var i = 0; i < scenes.length; i++) {
                list.push({ url: scenes[i], type: AssetTypeEnum.Scene });
            }
            for (var i = 0; i < textassets.length; i++) {
                list.push({ url: textassets[i], type: AssetTypeEnum.TextAsset });
            }
            return list;
        }
        function promisify(loader, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2, new Promise(function (resolve, reject) {
                            var onSuccess = function () {
                                var texture = loader['data'] ? loader['data'] : loader['response'];
                                resolve(texture);
                            };
                            var onError = function () {
                                var e = new RES.ResourceManagerError(1001, resource.url);
                                reject(e);
                            };
                            loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                            loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                        })];
                });
            });
        }
        function promisifySoundDecode(arrayBuffer, resource) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, new Promise(function (resolve, reject) {
                            var onSuccess = function (audioBuffer) {
                                resolve(audioBuffer);
                            };
                            var onError = function () {
                                var e = new RES.ResourceManagerError(1001, resource.url);
                                reject(e);
                            };
                            egret3d.sound.WebAudio.instance.decodeAudioData(arrayBuffer, onSuccess, onError);
                        })];
                });
            });
        }
        processor.BundleProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, bundle, list, i, r, asset, fileName;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                bundle = new egret3d.framework.AssetBundle(filename);
                                bundle.url = url;
                                bundle.path = resource.url.substring(0, resource.url.lastIndexOf("/"));
                                bundle.parse(JSON.parse(text));
                                egret3d.framework.AssetMap.registerBundle(filename, bundle);
                                list = getBundleUrlList(bundle);
                                i = 0;
                                _a.label = 2;
                            case 2:
                                if (!(i < list.length)) return [3, 5];
                                r = RES.host.resourceConfig["getResource"](list[i].url);
                                if (!r) return [3, 4];
                                return [4, host.load(r)];
                            case 3:
                                asset = _a.sent();
                                fileName = getFileName(list[i].url);
                                if (list[i].type !== AssetTypeEnum.GLVertexShader && list[i].type !== AssetTypeEnum.GLFragmentShader) {
                                    bundle.mapNamed[fileName] = asset.getGUID();
                                    if (list[i].type == AssetTypeEnum.Prefab || list[i].type == AssetTypeEnum.Scene) {
                                        asset.assetbundle = bundle.getName();
                                    }
                                }
                                _a.label = 4;
                            case 4:
                                i++;
                                return [3, 2];
                            case 5: return [2, bundle];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, key;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregisterBundle(data.getName());
                        for (key in data.mapNamed) {
                            data.find(key).dispose && data.find(key).dispose();
                        }
                        return [2];
                    });
                });
            }
        };
        processor.GLVertexShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                return [2, egret3d.framework.Shader.registerVertShader(name, text)];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, url, filename, name;
                    return __generator(this, function (_a) {
                        gl = egret3d.render.Webglkit.webgl;
                        url = getUrl(resource.url);
                        filename = getFileName(url);
                        name = filename.substring(0, filename.indexOf("."));
                        return [2];
                    });
                });
            }
        };
        processor.GLFragmentShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                return [2, egret3d.framework.Shader.registerFragShader(name, text)];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, url, filename, name;
                    return __generator(this, function (_a) {
                        gl = egret3d.render.Webglkit.webgl;
                        url = getUrl(resource.url);
                        filename = getFileName(url);
                        name = filename.substring(0, filename.indexOf("."));
                        return [2];
                    });
                });
            }
        };
        processor.ShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, shader;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                shader = new egret3d.framework.Shader(filename);
                                shader.parse(JSON.parse(text));
                                shader.url = url;
                                egret3d.framework.AssetMap.register(shader);
                                return [2, shader];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.D3PVRProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2];
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2];
                    });
                });
            }
        };
        processor.TextureDescProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _texturedesc, _name, _filterMode, _format, _mipmap, _wrap, _textureFormat, _linear, _repeat, _textureSrc, loader, image, _texture, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _texturedesc = JSON.parse(text);
                                _name = _texturedesc["name"];
                                _filterMode = _texturedesc["filterMode"];
                                _format = _texturedesc["format"];
                                _mipmap = _texturedesc["mipmap"];
                                _wrap = _texturedesc["wrap"];
                                if (_name.indexOf("LightmapFar") >= 0) {
                                    console.log("");
                                }
                                _textureFormat = egret3d.render.TextureFormatEnum.RGBA;
                                if (_format == "RGB") {
                                    _textureFormat = egret3d.render.TextureFormatEnum.RGB;
                                }
                                else if (_format == "Gray") {
                                    _textureFormat = egret3d.render.TextureFormatEnum.Gray;
                                }
                                _linear = true;
                                if (_filterMode.indexOf("linear") < 0) {
                                    _linear = false;
                                }
                                _repeat = false;
                                if (_wrap.indexOf("Repeat") >= 0) {
                                    _repeat = true;
                                }
                                _textureSrc = url.replace(filename, _name);
                                loader = new egret.ImageLoader();
                                loader.load(_textureSrc);
                                return [4, promisify(loader, resource)];
                            case 2:
                                image = _a.sent();
                                _texture = new egret3d.framework.Texture(filename);
                                _texture.realName = _name;
                                _texture.url = url;
                                t2d = new egret3d.render.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, _mipmap, _linear, true, _repeat);
                                _texture.glTexture = t2d;
                                egret3d.framework.AssetMap.register(_texture);
                                return [2, _texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.TextureProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, url, filename, name, loader, image, _texture, _textureFormat, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                loader = new egret.ImageLoader();
                                loader.load(url);
                                return [4, promisify(loader, resource)];
                            case 1:
                                image = _a.sent();
                                _texture = new egret3d.framework.Texture(filename);
                                _texture.url = url;
                                _textureFormat = egret3d.render.TextureFormatEnum.RGBA;
                                t2d = new egret3d.render.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, true, true, true, true);
                                _texture.glTexture = t2d;
                                egret3d.framework.AssetMap.register(_texture);
                                return [2, _texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.MaterialProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _material;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _material = new egret3d.framework.Material(filename);
                                _material.Parse(JSON.parse(text));
                                _material.url = url;
                                egret3d.framework.AssetMap.register(_material);
                                return [2, _material];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.MeshProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var arrayBuffer, gl, url, filename, name, _mesh;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.BinaryProcessor)];
                            case 1:
                                arrayBuffer = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _mesh = new egret3d.framework.Mesh(filename);
                                _mesh.Parse(arrayBuffer, gl);
                                _mesh.url = url;
                                egret3d.framework.AssetMap.register(_mesh);
                                return [2, _mesh];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.AniclipProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var arrayBuffer, gl, url, filename, name, _clip;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.BinaryProcessor)];
                            case 1:
                                arrayBuffer = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _clip = new egret3d.framework.AnimationClip(filename);
                                _clip.Parse(arrayBuffer);
                                _clip.url = url;
                                egret3d.framework.AssetMap.register(_clip);
                                return [2, _clip];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.AtlasProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _atlas;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _atlas = new egret3d.framework.Atlas(filename);
                                _atlas.Parse(text);
                                _atlas.url = url;
                                egret3d.framework.AssetMap.register(_atlas);
                                return [2, _atlas];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.PrefabProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _prefab;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _prefab = new egret3d.framework.Prefab(filename);
                                _prefab.Parse(text);
                                _prefab.url = url;
                                egret3d.framework.AssetMap.register(_prefab);
                                return [2, _prefab];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.SceneProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _scene;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _scene = new egret3d.framework.Rawscene(filename);
                                _scene.Parse(text);
                                _scene.url = url;
                                egret3d.framework.AssetMap.register(_scene);
                                return [2, _scene];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.D3FontProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _font;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _font = new egret3d.framework.Font(filename);
                                _font.Parse(text);
                                _font.url = url;
                                egret3d.framework.AssetMap.register(_font);
                                return [2, _font];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.Sound3DProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var arrayBuffer, gl, url, filename, name, audioBuffer, sound;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.BinaryProcessor)];
                            case 1:
                                arrayBuffer = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                return [4, promisifySoundDecode(arrayBuffer, resource)];
                            case 2:
                                audioBuffer = _a.sent();
                                sound = new egret3d.framework.Sound(filename);
                                sound.buffer = audioBuffer;
                                sound.url = url;
                                egret3d.framework.AssetMap.register(sound);
                                return [2, sound];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.TextAssetProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _text;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _text = new egret3d.framework.Textasset(filename);
                                _text.content = text;
                                _text.url = url;
                                egret3d.framework.AssetMap.register(_text);
                                return [2, _text];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        processor.PathAssetProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var text, gl, url, filename, name, _path;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4, host.load(resource, RES.processor.TextProcessor)];
                            case 1:
                                text = _a.sent();
                                gl = egret3d.render.Webglkit.webgl;
                                url = getUrl(resource.url);
                                filename = getFileName(url);
                                name = filename.substring(0, filename.indexOf("."));
                                _path = new egret3d.framework.Pathasset(filename);
                                _path.Parse(JSON.parse(text));
                                _path.url = url;
                                egret3d.framework.AssetMap.register(_path);
                                return [2, _path];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        egret3d.framework.AssetMap.unregister(data);
                        return [2];
                    });
                });
            }
        };
        RES.processor.map("GLVertexShader", processor.GLVertexShaderProcessor);
        RES.processor.map("GLFragmentShader", processor.GLFragmentShaderProcessor);
        RES.processor.map("Shader", processor.ShaderProcessor);
        RES.processor.map("Bundle", processor.BundleProcessor);
        RES.processor.map("Texture", processor.TextureProcessor);
        RES.processor.map("TextureDesc", processor.TextureDescProcessor);
        RES.processor.map("PVR", processor.D3PVRProcessor);
        RES.processor.map("Material", processor.MaterialProcessor);
        RES.processor.map("Mesh", processor.MeshProcessor);
        RES.processor.map("Aniclip", processor.AniclipProcessor);
        RES.processor.map("Prefab", processor.PrefabProcessor);
        RES.processor.map("Scene", processor.SceneProcessor);
        RES.processor.map("Atlas", processor.AtlasProcessor);
        RES.processor.map("Font", processor.D3FontProcessor);
        RES.processor.map("TextAsset", processor.TextAssetProcessor);
        RES.processor.map("pathAsset", processor.PathAssetProcessor);
        RES.processor.map("Sound", processor.Sound3DProcessor);
    })(processor = RES.processor || (RES.processor = {}));
})(RES || (RES = {}));
var egret3d;
(function (egret3d) {
    var sound;
    (function (sound) {
        var WebAudioChannel3D = (function (_super) {
            __extends(WebAudioChannel3D, _super);
            function WebAudioChannel3D() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.position = new egret3d.math.Vector3();
                _this.velocity = new egret3d.math.Vector3();
                return _this;
            }
            WebAudioChannel3D.prototype._init = function () {
                var context = sound.WebAudio.instance.audioContext;
                this.source = context.createBufferSource();
                this.panner = context.createPanner();
                this.gain = context.createGain();
                this.source.connect(this.panner);
                this.panner.connect(this.gain);
                this.gain.connect(context.destination);
            };
            Object.defineProperty(WebAudioChannel3D.prototype, "maxDistance", {
                get: function () {
                    return this.panner.maxDistance;
                },
                set: function (value) {
                    this.panner.maxDistance = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudioChannel3D.prototype, "minDistance", {
                get: function () {
                    return this.panner.refDistance;
                },
                set: function (value) {
                    this.panner.refDistance = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudioChannel3D.prototype, "rollOffFactor", {
                get: function () {
                    return this.panner.rolloffFactor;
                },
                set: function (value) {
                    this.panner.rolloffFactor = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebAudioChannel3D.prototype, "distanceModel", {
                get: function () {
                    return this.panner.distanceModel;
                },
                set: function (value) {
                    if (value === "linear" || value === "inverse" || value === "exponential") {
                        this.panner.distanceModel = value;
                    }
                    else {
                        console.warn("distanceModel: " + value + " Is not a valid parameter");
                    }
                },
                enumerable: true,
                configurable: true
            });
            WebAudioChannel3D.prototype.setPosition = function (x, y, z) {
                this.position.x = x;
                this.position.y = y;
                this.position.z = z;
                this.panner.setPosition(x, y, z);
            };
            WebAudioChannel3D.prototype.getPosition = function () {
                return this.position;
            };
            WebAudioChannel3D.prototype.setVelocity = function (x, y, z) {
                this.position.x = x;
                this.position.y = y;
                this.position.z = z;
                this.panner.setVelocity(x, y, z);
            };
            WebAudioChannel3D.prototype.getVelocity = function () {
                return this.velocity;
            };
            return WebAudioChannel3D;
        }(sound.WebAudioChannel2D));
        sound.WebAudioChannel3D = WebAudioChannel3D;
        __reflect(WebAudioChannel3D.prototype, "egret3d.sound.WebAudioChannel3D");
    })(sound = egret3d.sound || (egret3d.sound = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var sound;
    (function (sound) {
        var WebAudioListener = (function () {
            function WebAudioListener() {
                this.position = new egret3d.math.Vector3();
                this.velocity = new egret3d.math.Vector3();
                this.orientation = new egret3d.math.Matrix();
                this.listener = sound.WebAudio.instance.audioContext.listener;
            }
            WebAudioListener.prototype.setPosition = function (x, y, z) {
                this.position.x = x;
                this.position.y = y;
                this.position.z = z;
                this.listener.setPosition(x, y, z);
            };
            WebAudioListener.prototype.getPosition = function () {
                return this.position;
            };
            WebAudioListener.prototype.setVelocity = function (x, y, z) {
                this.velocity.x = x;
                this.velocity.y = y;
                this.velocity.z = z;
                this.listener.setVelocity(x, y, z);
            };
            WebAudioListener.prototype.getVelocity = function () {
                return this.velocity;
            };
            WebAudioListener.prototype.setOrientation = function (orientation) {
                egret3d.math.matrixClone(orientation, this.orientation);
                this.listener.setOrientation(-orientation.rawData[8], -orientation.rawData[9], -orientation.rawData[10], orientation.rawData[4], orientation.rawData[5], orientation.rawData[6]);
            };
            WebAudioListener.prototype.getOrientation = function () {
                return this.orientation;
            };
            return WebAudioListener;
        }());
        sound.WebAudioListener = WebAudioListener;
        __reflect(WebAudioListener.prototype, "egret3d.sound.WebAudioListener");
    })(sound = egret3d.sound || (egret3d.sound = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var TPoseInfo = (function () {
            function TPoseInfo() {
            }
            __decorate([
                egret3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], TPoseInfo.prototype, "name", void 0);
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], TPoseInfo.prototype, "tposep", void 0);
            __decorate([
                egret3d.reflect.Field("Quaternion"),
                __metadata("design:type", egret3d.math.Quaternion)
            ], TPoseInfo.prototype, "tposeq", void 0);
            TPoseInfo = __decorate([
                egret3d.reflect.SerializeType
            ], TPoseInfo);
            return TPoseInfo;
        }());
        framework.TPoseInfo = TPoseInfo;
        __reflect(TPoseInfo.prototype, "egret3d.framework.TPoseInfo");
        var PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
        var AniPlayer = (function () {
            function AniPlayer() {
                this._clipnameCount = 0;
                this._clipnames = null;
                this.autoplay = true;
                this.playIndex = 0;
                this._playClip = null;
                this.tpose = {};
                this.nowpose = {};
                this.lerppose = {};
                this.carelist = {};
                this._playFrameid = 0;
                this._playTimer = 0;
                this.speed = 1.0;
                this.crossdelta = 0;
                this.crossspeed = 0;
                this.beRevert = false;
                this.playStyle = PlayStyle.NormalPlay;
                this.percent = 0;
                this.mix = false;
                this.isCache = false;
            }
            AniPlayer_1 = AniPlayer;
            Object.defineProperty(AniPlayer.prototype, "clipnames", {
                get: function () {
                    if (this._clipnames == null || this._clipnameCount != this.clips.length) {
                        this._clipnameCount = this.clips.length;
                        this._clipnames = {};
                        for (var key in this.clips) {
                            this.clipnames[this.clips[key].getName()] = parseInt(key);
                        }
                    }
                    return this._clipnames;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AniPlayer.prototype, "cacheKey", {
                get: function () {
                    if (this._playClip) {
                        return this._playClip.getGUID() + "_" + this._playFrameid;
                    }
                    return this._playFrameid;
                },
                enumerable: true,
                configurable: true
            });
            AniPlayer.prototype.init = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var _info = this.bones[i];
                    var name_1 = _info.name;
                    var nb = new framework.PoseBoneMatrix();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.tpose[name_1] = nb;
                    this.nowpose[name_1] = this.startPos[i].Clone();
                }
                var asbones = this.gameObject.getComponentsInChildren("Asbone");
                for (var key in asbones) {
                    this.care(asbones[key].gameObject.transform);
                }
                if (this.autoplay && this.clips != null && this.clips.length > 0) {
                    this.playByIndex(this.playIndex);
                }
            };
            AniPlayer.prototype.start = function () {
                if (this.bones != null) {
                    this.init();
                }
            };
            AniPlayer.prototype.update = function (delta) {
                if (this._playClip == null) {
                    return;
                }
                this.checkFrameId(delta);
                this.mix = false;
                if (this.crossdelta > 0) {
                    this.crossdelta -= delta / this.speed * this.crossspeed;
                    this.mix = true;
                }
                var cached = false;
                if (this.isCache && !this.mix && AniPlayer_1.playerCaches[this.cacheKey]) {
                    cached = true;
                    if (!this.carelist) {
                        return;
                    }
                    var count = 0;
                    for (var key in this.carelist) {
                        count++;
                    }
                    if (count == 0) {
                        return;
                    }
                }
                for (var i = 0; i < this._playClip.boneCount; i++) {
                    var bone = this._playClip.bones[i];
                    if (cached && !this.carelist[bone]) {
                        continue;
                    }
                    var frame = this._playClip.frames[this._playFrameid];
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined) {
                        if (this.mix) {
                            var last = this.lerppose[bone];
                            if (last != undefined) {
                                outb.lerpInWorldWithData(tpose, last, frame, nextseek, 1 - this.crossdelta);
                            }
                            else {
                                outb.copyFromData(frame, nextseek);
                            }
                        }
                        else {
                            outb.copyFromData(frame, nextseek);
                        }
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        var fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        var _transform = this.gameObject.transform;
                        var _position = egret3d.math.Pool.new_vector3();
                        var _rotation = egret3d.math.Pool.new_quaternion();
                        egret3d.math.vec3Add(_transform.getPosition(), fmat.t, _position);
                        egret3d.math.quatMultiply(fmat.r, _transform.getRotation(), _rotation);
                        _transform.setPosition(_position);
                        _transform.setRotation(_rotation);
                        egret3d.math.Pool.delete_vector3(_position);
                        egret3d.math.Pool.delete_quaternion(_rotation);
                    }
                }
                if (!cached) {
                    AniPlayer_1.playerCaches[this.cacheKey] = this;
                }
            };
            AniPlayer.prototype.playByIndex = function (animIndex, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossdelta = 0;
            };
            AniPlayer.prototype.playCrossByIndex = function (animIndex, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossspeed = 1.0 / crosstimer;
                this.crossdelta = 1;
            };
            AniPlayer.prototype.play = function (animName, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                this.playByIndex(this.clipnames[animName], speed, beRevert);
            };
            AniPlayer.prototype.playCross = function (animName, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (crosstimer <= 0) {
                    this.playByIndex(this.clipnames[animName], speed, beRevert);
                }
                else {
                    this.playCrossByIndex(this.clipnames[animName], crosstimer, speed, beRevert);
                }
            };
            AniPlayer.prototype.playAniamtion = function (index, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clips[index] == undefined)
                    return;
                this._playClip = this.clips[index];
                this._playTimer = 0;
                this._playFrameid = 0;
                this.speed = speed;
                this.beRevert = beRevert;
                this.playStyle = PlayStyle.NormalPlay;
                this.speed = speed;
                this.lerppose = {};
                for (var key in this.nowpose) {
                    var src = this.nowpose[key];
                    this.lerppose[key] = src.Clone();
                }
            };
            AniPlayer.prototype.stop = function () {
                this._playClip = null;
            };
            AniPlayer.prototype.isPlay = function () {
                return this._playClip != null;
            };
            AniPlayer.prototype.isStop = function () {
                if (this._playClip == null)
                    return false;
                if (this.playStyle != PlayStyle.NormalPlay)
                    return false;
                if (this._playClip.loop)
                    return false;
                if (this._playFrameid == this._playClip.frameCount - 1)
                    return true;
                return false;
            };
            AniPlayer.prototype.remove = function () {
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                delete this.tpose;
                delete this.nowpose;
                delete this.lerppose;
                delete this.carelist;
                delete this._clipnames;
            };
            AniPlayer.prototype.clone = function () {
            };
            AniPlayer.prototype.addFinishedEventListener = function (finishCallBack, thisObject) {
                this.finishCallBack = finishCallBack;
                this.thisObject = thisObject;
            };
            AniPlayer.prototype.checkFrameId = function (delay) {
                if (this.playStyle == PlayStyle.NormalPlay) {
                    this._playTimer += delay * this.speed;
                    this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                    if (this._playClip.loop) {
                        this._playFrameid %= this._playClip.frameCount;
                    }
                    else if (this._playFrameid > this._playClip.frameCount - 1) {
                        this._playFrameid = this._playClip.frameCount - 1;
                    }
                    if (this.beRevert) {
                        this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
                    }
                }
                else if (this.playStyle == PlayStyle.FramePlay) {
                    this._playFrameid = (this._playClip.frameCount * this.percent) - 1;
                    this._playFrameid = Math.round(this._playFrameid);
                }
                if (this._playFrameid < 0) {
                    this._playFrameid = 0;
                }
                if (this._playFrameid > this._playClip.frameCount - 1) {
                    this._playFrameid = this._playClip.frameCount - 1;
                }
                if (this.isStop()) {
                    if (this.finishCallBack) {
                        this.finishCallBack(this.thisObject);
                        this.finishCallBack = null;
                        this.thisObject = null;
                    }
                }
            };
            AniPlayer.prototype.fillPoseData = function (data, bones, efficient) {
                if (efficient === void 0) { efficient = true; }
                var seek = 0;
                for (var i in bones) {
                    var key = bones[i].name;
                    var obj = this.nowpose[key];
                    if (obj == undefined) {
                        if (efficient) {
                            data[seek * 8 + 0] = 0;
                            data[seek * 8 + 1] = 0;
                            data[seek * 8 + 2] = 0;
                            data[seek * 8 + 3] = 1;
                            data[seek * 8 + 4] = 0;
                            data[seek * 8 + 5] = 0;
                            data[seek * 8 + 6] = 0;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            data[seek * 16 + 0] = 1;
                            data[seek * 16 + 1] = 0;
                            data[seek * 16 + 2] = 0;
                            data[seek * 16 + 3] = 0;
                            data[seek * 16 + 4] = 0;
                            data[seek * 16 + 5] = 1;
                            data[seek * 16 + 6] = 0;
                            data[seek * 16 + 7] = 0;
                            data[seek * 16 + 8] = 0;
                            data[seek * 16 + 9] = 0;
                            data[seek * 16 + 10] = 1;
                            data[seek * 16 + 11] = 0;
                            data[seek * 16 + 12] = 0;
                            data[seek * 16 + 13] = 0;
                            data[seek * 16 + 14] = 0;
                            data[seek * 16 + 15] = 1;
                        }
                    }
                    else {
                        var _mat = egret3d.math.Pool.new_matrix();
                        if (efficient) {
                            data[seek * 8 + 0] = obj.r.x;
                            data[seek * 8 + 1] = obj.r.y;
                            data[seek * 8 + 2] = obj.r.z;
                            data[seek * 8 + 3] = obj.r.w;
                            data[seek * 8 + 4] = obj.t.x;
                            data[seek * 8 + 5] = obj.t.y;
                            data[seek * 8 + 6] = obj.t.z;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            egret3d.math.matrixMakeTransformRTS(obj.t, egret3d.math.Pool.vector3_one, obj.r, _mat);
                            for (var j = 0; j < 16; j++) {
                                data[seek * 16 + j] = _mat.rawData[j];
                            }
                        }
                    }
                    seek++;
                }
            };
            AniPlayer.prototype.care = function (node) {
                var pnode = node;
                while (true) {
                    if (this.nowpose[pnode.name] != undefined) {
                        this.carelist[pnode.name] = pnode;
                        return;
                    }
                    pnode = pnode.parent;
                }
            };
            AniPlayer.playerCaches = [];
            __decorate([
                egret3d.reflect.Field("AnimationClip[]"),
                __metadata("design:type", Array)
            ], AniPlayer.prototype, "clips", void 0);
            __decorate([
                egret3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], AniPlayer.prototype, "autoplay", void 0);
            __decorate([
                egret3d.reflect.Field("TPoseInfo[]"),
                __metadata("design:type", Array)
            ], AniPlayer.prototype, "bones", void 0);
            __decorate([
                egret3d.reflect.Field("PoseBoneMatrix[]"),
                __metadata("design:type", Array)
            ], AniPlayer.prototype, "startPos", void 0);
            AniPlayer = AniPlayer_1 = __decorate([
                egret3d.reflect.nodeComponent
            ], AniPlayer);
            return AniPlayer;
            var AniPlayer_1;
        }());
        framework.AniPlayer = AniPlayer;
        __reflect(AniPlayer.prototype, "egret3d.framework.AniPlayer", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Asbone = (function () {
            function Asbone() {
            }
            Asbone.prototype.start = function () {
            };
            Asbone.prototype.update = function (delta) {
            };
            Asbone.prototype.remove = function () {
            };
            Asbone.prototype.clone = function () {
            };
            Asbone = __decorate([
                egret3d.reflect.nodeComponent
            ], Asbone);
            return Asbone;
        }());
        framework.Asbone = Asbone;
        __reflect(Asbone.prototype, "egret3d.framework.Asbone", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var AudioListener = (function () {
            function AudioListener() {
            }
            AudioListener.prototype.start = function () {
            };
            AudioListener.prototype.update = function (deltaTime) {
                if (this.gameObject) {
                    var position = this.gameObject.transform.getPosition();
                    egret3d.sound.WebAudio.instance.getAudioListener().setPosition(position.x, position.y, position.z);
                    var wtm = this.gameObject.transform.getWorldMatrix();
                    egret3d.sound.WebAudio.instance.getAudioListener().setOrientation(wtm);
                }
            };
            AudioListener.prototype.remove = function () {
            };
            AudioListener.prototype.clone = function () {
            };
            AudioListener = __decorate([
                egret3d.reflect.nodeComponent
            ], AudioListener);
            return AudioListener;
        }());
        framework.AudioListener = AudioListener;
        __reflect(AudioListener.prototype, "egret3d.framework.AudioListener", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var AudioSource2D = (function () {
            function AudioSource2D() {
                this._volume = 1;
                this._loop = false;
                this._playing = false;
            }
            AudioSource2D.prototype.start = function () {
            };
            AudioSource2D.prototype.update = function (deltaTime) {
            };
            AudioSource2D.prototype.remove = function () {
            };
            AudioSource2D.prototype.clone = function () {
            };
            Object.defineProperty(AudioSource2D.prototype, "sound", {
                set: function (sound) {
                    if (!!this._channel && this._playing) {
                        this._channel.stop();
                        this._channel.dispose();
                        this._sound.unuse();
                    }
                    if (!egret3d.sound.WebAudio.instance.isSupported) {
                        return;
                    }
                    this._channel = new egret3d.sound.WebAudioChannel2D();
                    this._channel.buffer = sound.buffer;
                    this._sound = sound;
                    sound.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource2D.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.volume = value;
                        this._volume = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource2D.prototype, "loop", {
                get: function () {
                    return this._loop;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.loop = value;
                        this._loop = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            AudioSource2D.prototype.play = function (offset) {
                if (!!this._channel) {
                    this._channel.start(offset);
                    this._playing = true;
                }
            };
            AudioSource2D.prototype.stop = function () {
                if (!!this._channel) {
                    this._channel.stop();
                    this._playing = false;
                }
            };
            AudioSource2D = __decorate([
                egret3d.reflect.nodeComponent
            ], AudioSource2D);
            return AudioSource2D;
        }());
        framework.AudioSource2D = AudioSource2D;
        __reflect(AudioSource2D.prototype, "egret3d.framework.AudioSource2D", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var AudioSource3D = (function () {
            function AudioSource3D() {
                this._volume = 1;
                this._loop = false;
                this._playing = false;
            }
            AudioSource3D.prototype.start = function () {
            };
            AudioSource3D.prototype.update = function (deltaTime) {
                if (!!this._channel && this._playing && this.gameObject) {
                    var position = this.gameObject.transform.getPosition();
                    this._channel.setPosition(position.x, position.y, position.z);
                }
            };
            AudioSource3D.prototype.remove = function () {
            };
            AudioSource3D.prototype.clone = function () {
            };
            Object.defineProperty(AudioSource3D.prototype, "sound", {
                set: function (sound) {
                    if (!!this._channel && this._playing) {
                        this._channel.stop();
                        this._channel.dispose();
                        this._sound.unuse();
                    }
                    if (!egret3d.sound.WebAudio.instance.isSupported) {
                        return;
                    }
                    this._channel = new egret3d.sound.WebAudioChannel3D();
                    this._channel.buffer = sound.buffer;
                    this._sound = sound;
                    sound.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource3D.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.volume = value;
                        this._volume = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource3D.prototype, "loop", {
                get: function () {
                    return this._loop;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.loop = value;
                        this._loop = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            AudioSource3D.prototype.play = function (offset) {
                if (!!this._channel && !this._playing) {
                    this._channel.start(offset);
                    this._playing = true;
                }
            };
            AudioSource3D.prototype.stop = function () {
                if (!!this._channel && this._playing) {
                    this._channel.stop();
                    this._playing = false;
                }
            };
            Object.defineProperty(AudioSource3D.prototype, "maxDistance", {
                get: function () {
                    if (!!this._channel) {
                        return this._channel.maxDistance;
                    }
                    return 0;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.maxDistance = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource3D.prototype, "minDistance", {
                get: function () {
                    if (!!this._channel) {
                        return this._channel.minDistance;
                    }
                    return 0;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.minDistance = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource3D.prototype, "rollOffFactor", {
                get: function () {
                    if (!!this._channel) {
                        return this._channel.rollOffFactor;
                    }
                    return 0;
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.rollOffFactor = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioSource3D.prototype, "distanceModel", {
                get: function () {
                    if (!!this._channel) {
                        return this._channel.distanceModel;
                    }
                    return "";
                },
                set: function (value) {
                    if (!!this._channel) {
                        this._channel.distanceModel = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            AudioSource3D.prototype.getVelocity = function () {
                if (!!this._channel) {
                    return this._channel.getVelocity();
                }
                return new egret3d.math.Vector3();
            };
            AudioSource3D.prototype.setVelocity = function (x, y, z) {
                if (!!this._channel) {
                    this._channel.setVelocity(x, y, z);
                }
            };
            AudioSource3D = __decorate([
                egret3d.reflect.nodeComponent
            ], AudioSource3D);
            return AudioSource3D;
        }());
        framework.AudioSource3D = AudioSource3D;
        __reflect(AudioSource3D.prototype, "egret3d.framework.AudioSource3D", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var BoxCollider = (function () {
            function BoxCollider() {
                this._colliderVisible = false;
            }
            BoxCollider.prototype.getBound = function () {
                return this.obb;
            };
            Object.defineProperty(BoxCollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject) {
                        return this.gameObject.transform.getWorldMatrix();
                    }
                    return new egret3d.math.Matrix();
                },
                enumerable: true,
                configurable: true
            });
            BoxCollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("MeshFilter");
                this.build();
            };
            BoxCollider.prototype.update = function (delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            };
            Object.defineProperty(BoxCollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            BoxCollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            };
            BoxCollider.prototype.build = function () {
                this.obb = new framework.Obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = new egret3d.math.Vector3();
                    var maximum = new egret3d.math.Vector3();
                    if (this.filter) {
                        var meshdata = this.filter.getMeshOutput().data;
                        egret3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        egret3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < meshdata.pos.length; i++) {
                            egret3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                            egret3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                }
                this.buildMesh();
            };
            BoxCollider.prototype.buildMesh = function () {
                this.subTran = new egret3d.framework.Transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("MeshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("MeshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
            };
            BoxCollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.Mesh();
                _mesh.data = egret3d.render.MeshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new egret3d.render.GlMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = i16.length;
                sm.line = true;
                _mesh.submesh.push(sm);
                return _mesh;
            };
            BoxCollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            };
            BoxCollider.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], BoxCollider.prototype, "center", void 0);
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], BoxCollider.prototype, "size", void 0);
            BoxCollider = __decorate([
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeBoxCollider
            ], BoxCollider);
            return BoxCollider;
        }());
        framework.BoxCollider = BoxCollider;
        __reflect(BoxCollider.prototype, "egret3d.framework.BoxCollider", ["egret3d.framework.INodeComponent", "egret3d.framework.ICollider"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var CullingMask;
        (function (CullingMask) {
            CullingMask[CullingMask["Everything"] = 16777215] = "Everything";
            CullingMask[CullingMask["Nothing"] = 1] = "Nothing";
            CullingMask[CullingMask["Default"] = 2] = "Default";
            CullingMask[CullingMask["UI"] = 4] = "UI";
            CullingMask[CullingMask["UserLayer1"] = 8] = "UserLayer1";
            CullingMask[CullingMask["UserLayer2"] = 16] = "UserLayer2";
            CullingMask[CullingMask["UserLayer3"] = 32] = "UserLayer3";
            CullingMask[CullingMask["UserLayer4"] = 64] = "UserLayer4";
            CullingMask[CullingMask["UserLayer5"] = 128] = "UserLayer5";
            CullingMask[CullingMask["UserLayer6"] = 240] = "UserLayer6";
            CullingMask[CullingMask["UserLayer7"] = 256] = "UserLayer7";
            CullingMask[CullingMask["UserLayer8"] = 512] = "UserLayer8";
            CullingMask[CullingMask["UserLayer9"] = 1024] = "UserLayer9";
            CullingMask[CullingMask["UserLayer10"] = 2048] = "UserLayer10";
            CullingMask[CullingMask["UserLayer11"] = 3840] = "UserLayer11";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
        var Camera = (function () {
            function Camera() {
                this.fov = Math.PI * 0.25;
                this.size = 2;
                this.opvalue = 1;
                this._near = 0.01;
                this._far = 1000;
                this.CullingMask = CullingMask.Default | CullingMask.UI;
                this.clearOption_Color = true;
                this.clearOption_Depth = true;
                this.backgroundColor = new egret3d.math.Color(0.5, 0.8, 1, 1);
                this.viewport = new egret3d.math.Rect(0, 0, 1, 1);
                this.renderTarget = null;
                this.order = 0;
                this.overlays = [];
                this.matView = new egret3d.math.Matrix;
                this.matProjP = new egret3d.math.Matrix;
                this.matProjO = new egret3d.math.Matrix;
                this.matProj = new egret3d.math.Matrix;
                this.frameVecs = [
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3(),
                    new egret3d.math.Vector3()
                ];
                this.postQueues = [];
            }
            Object.defineProperty(Camera.prototype, "near", {
                get: function () {
                    return this._near;
                },
                set: function (val) {
                    if (val >= this.far)
                        val = this.far - 1;
                    if (val < 0.01)
                        val = 0.01;
                    this._near = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Camera.prototype, "far", {
                get: function () {
                    return this._far;
                },
                set: function (val) {
                    if (val <= this.near)
                        val = this.near + 1;
                    if (val >= 1000)
                        val = 1000;
                    this._far = val;
                },
                enumerable: true,
                configurable: true
            });
            Camera.prototype.markDirty = function () {
            };
            Camera.prototype.start = function () {
            };
            Camera.prototype.update = function (delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            };
            Camera.prototype.addOverLay = function (overLay) {
                this.overlays.push(overLay);
            };
            Camera.prototype.addOverLayAt = function (overLay, index) {
                this.overlays.splice(index, 0, overLay);
            };
            Camera.prototype.getOverLays = function () {
                return this.overlays;
            };
            Camera.prototype.removeOverLay = function (overLay) {
                if (this.overlays == null)
                    return;
                var index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
            };
            Camera.prototype.calcViewMatrix = function (matrix) {
                var camworld = this.gameObject.transform.getWorldMatrix();
                egret3d.math.matrixInverse(camworld, this.matView);
                egret3d.math.matrixClone(this.matView, matrix);
            };
            Camera.prototype.calcProjectMatrix = function (asp, matrix) {
                if (this.opvalue > 0) {
                    egret3d.math.matrixProject_PerspectiveLH(this.fov, asp, this.near, this.far, this.matProjP);
                }
                if (this.opvalue < 1) {
                    egret3d.math.matrixProject_OrthoLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
                }
                if (this.opvalue == 0) {
                    egret3d.math.matrixClone(this.matProjO, this.matProj);
                }
                else if (this.opvalue == 1) {
                    egret3d.math.matrixClone(this.matProjP, this.matProj);
                }
                else {
                    egret3d.math.matrixLerp(this.matProjO, this.matProjP, this.opvalue, this.matProj);
                }
                egret3d.math.matrixClone(this.matProj, matrix);
            };
            Camera.prototype.calcViewPortPixel = function (app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                viewPortPixel.x = w * this.viewport.x;
                viewPortPixel.y = h * this.viewport.y;
                viewPortPixel.w = w * this.viewport.w;
                viewPortPixel.h = h * this.viewport.h;
            };
            Camera.prototype.creatRayByScreen = function (screenpos, app) {
                var src1 = egret3d.math.Pool.new_vector3();
                src1.x = screenpos.x;
                src1.y = screenpos.y;
                src1.z = 0;
                var src2 = egret3d.math.Pool.new_vector3();
                src2.x = screenpos.x;
                src2.y = screenpos.y;
                src2.z = 1;
                var dest1 = egret3d.math.Pool.new_vector3();
                var dest2 = egret3d.math.Pool.new_vector3();
                this.calcWorldPosFromScreenPos(app, src1, dest1);
                this.calcWorldPosFromScreenPos(app, src2, dest2);
                var dir = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(dest2, dest1, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var ray = new egret3d.framework.Ray(dest1, dir);
                egret3d.math.Pool.delete_vector3(src1);
                egret3d.math.Pool.delete_vector3(src2);
                egret3d.math.Pool.delete_vector3(dest1);
                egret3d.math.Pool.delete_vector3(dest2);
                egret3d.math.Pool.delete_vector3(dir);
                return ray;
            };
            Camera.prototype.calcWorldPosFromScreenPos = function (app, screenPos, outWorldPos) {
                var vpp = new egret3d.math.Rect();
                this.calcViewPortPixel(app, vpp);
                var vppos = new egret3d.math.Vector2(screenPos.x / vpp.w * 2 - 1, 1 - screenPos.y / vpp.h * 2);
                var matrixView = new egret3d.math.Matrix();
                var matrixProject = new egret3d.math.Matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new egret3d.math.Matrix();
                var matinv = new egret3d.math.Matrix();
                egret3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                egret3d.math.matrixInverse(matrixViewProject, matinv);
                var src1 = new egret3d.math.Vector3(vppos.x, vppos.y, screenPos.z);
                egret3d.math.matrixTransformVector3(src1, matinv, outWorldPos);
            };
            Camera.prototype.calcScreenPosFromWorldPos = function (app, worldPos, outScreenPos) {
                var vpp = new egret3d.math.Rect();
                this.calcViewPortPixel(app, vpp);
                var matrixView = new egret3d.math.Matrix();
                var matrixProject = new egret3d.math.Matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new egret3d.math.Matrix();
                egret3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                var ndcPos = egret3d.math.Pool.new_vector3();
                egret3d.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w / 2;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h / 2;
            };
            Camera.prototype.calcCameraFrame = function (app) {
                var _vpp = new egret3d.math.Rect();
                this.calcViewPortPixel(app, _vpp);
                var farLD = this.frameVecs[0];
                var nearLD = this.frameVecs[1];
                var farRD = this.frameVecs[2];
                var nearRD = this.frameVecs[3];
                var farLT = this.frameVecs[4];
                var nearLT = this.frameVecs[5];
                var farRT = this.frameVecs[6];
                var nearRT = this.frameVecs[7];
                var near_h = this.near * Math.tan(this.fov * 0.5);
                var asp = _vpp.w / _vpp.h;
                var near_w = near_h * asp;
                egret3d.math.vec3SetByFloat(-near_w, near_h, this.near, nearLT);
                egret3d.math.vec3SetByFloat(-near_w, -near_h, this.near, nearLD);
                egret3d.math.vec3SetByFloat(near_w, near_h, this.near, nearRT);
                egret3d.math.vec3SetByFloat(near_w, -near_h, this.near, nearRD);
                var far_h = this.far * Math.tan(this.fov * 0.5);
                var far_w = far_h * asp;
                egret3d.math.vec3SetByFloat(-far_w, far_h, this.far, farLT);
                egret3d.math.vec3SetByFloat(-far_w, -far_h, this.far, farLD);
                egret3d.math.vec3SetByFloat(far_w, far_h, this.far, farRT);
                egret3d.math.vec3SetByFloat(far_w, -far_h, this.far, farRD);
                var matrix = this.gameObject.transform.getWorldMatrix();
                egret3d.math.matrixTransformVector3(farLD, matrix, farLD);
                egret3d.math.matrixTransformVector3(nearLD, matrix, nearLD);
                egret3d.math.matrixTransformVector3(farRD, matrix, farRD);
                egret3d.math.matrixTransformVector3(nearRD, matrix, nearRD);
                egret3d.math.matrixTransformVector3(farLT, matrix, farLT);
                egret3d.math.matrixTransformVector3(nearLT, matrix, nearLT);
                egret3d.math.matrixTransformVector3(farRT, matrix, farRT);
                egret3d.math.matrixTransformVector3(nearRT, matrix, nearRT);
            };
            Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, app, z, out) {
                var vpp = new egret3d.math.Rect();
                this.calcViewPortPixel(app, vpp);
                var nearpos = new egret3d.math.Vector3;
                nearpos.z = -this.near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = new egret3d.math.Vector3;
                farpos.z = -this.far;
                farpos.x = this.far * nearpos.x / this.near;
                farpos.y = this.far * nearpos.y / this.near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            };
            Camera.prototype.testFrustumCulling = function (scene, node) {
                var aabb = node.aabb;
                if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                    return false;
                if (!aabb.intersectPlane(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                    return false;
                if (!aabb.intersectPlane(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                    return false;
                if (!aabb.intersectPlane(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                    return false;
                if (!aabb.intersectPlane(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                    return false;
                if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                    return false;
                return true;
            };
            Camera.prototype._targetAndViewport = function (target, scene, context, withoutClear) {
                var w;
                var h;
                if (target == null) {
                    w = scene.app.width;
                    h = scene.app.height;
                    egret3d.render.GlRenderTarget.useNull(context.webgl);
                }
                else {
                    w = target.width;
                    h = target.height;
                    target.use(context.webgl);
                }
                context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                context.webgl.depthRange(0, 1);
                if (withoutClear) {
                    return;
                }
                if (this.clearOption_Color && this.clearOption_Depth) {
                    egret3d.render.Webglkit.zWrite(true);
                    context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                    context.webgl.clearDepth(1.0);
                    context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                }
                else if (this.clearOption_Depth) {
                    egret3d.render.Webglkit.zWrite(true);
                    context.webgl.clearDepth(1.0);
                    context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                }
                else if (this.clearOption_Color) {
                    context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                    context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                }
                else {
                }
            };
            Camera.prototype._renderOnce = function (scene, context, drawtype) {
                context.drawtype = drawtype;
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    for (var j = 0; j < list.length; j++) {
                        var gameObject = list[j].gameObject;
                        if (list[j].frustumTest) {
                            if (!this.testFrustumCulling(scene, gameObject.transform)) {
                                continue;
                            }
                        }
                        if (!gameObject.visible) {
                            continue;
                        }
                        if (this.CullingMask & list[j].renderLayer) {
                            list[j].render(context, this);
                        }
                    }
                }
            };
            Camera.prototype.renderScene = function (scene, context) {
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    if (layer.needSort && list.length > 1) {
                        list.sort(function (a, b) {
                            if (a.queue != b.queue) {
                                return a.queue - b.queue;
                            }
                            else {
                                var matrixView = context.matrixView;
                                var az = egret3d.math.Pool.new_vector3();
                                var bz = egret3d.math.Pool.new_vector3();
                                egret3d.math.matrixTransformVector3(a.gameObject.transform.getPosition(), matrixView, az);
                                egret3d.math.matrixTransformVector3(b.gameObject.transform.getPosition(), matrixView, bz);
                                return az.z - bz.z;
                            }
                        });
                    }
                }
                this.calcCameraFrame(scene.app);
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                }
                else {
                    for (var i = 0; i < this.postQueues.length; i++) {
                        this.postQueues[i].render(scene, context, this);
                    }
                }
                context.webgl.flush();
            };
            Camera.prototype.remove = function () {
            };
            Camera.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.UIStyle("rangeFloat", 1, 1000, 2),
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], Camera.prototype, "near", null);
            __decorate([
                egret3d.reflect.UIStyle("rangeFloat", 1, 1000, 999),
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], Camera.prototype, "far", null);
            __decorate([
                egret3d.reflect.Field("IOverLay[]"),
                __metadata("design:type", Array)
            ], Camera.prototype, "overlays", void 0);
            Camera = __decorate([
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeCamera
            ], Camera);
            return Camera;
        }());
        framework.Camera = Camera;
        __reflect(Camera.prototype, "egret3d.framework.Camera", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var CameraPostQueue_Depth = (function () {
            function CameraPostQueue_Depth() {
                this.renderTarget = null;
            }
            CameraPostQueue_Depth.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                egret3d.render.Webglkit.zWrite(true);
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                egret3d.render.GlRenderTarget.useNull(context.webgl);
            };
            return CameraPostQueue_Depth;
        }());
        framework.CameraPostQueue_Depth = CameraPostQueue_Depth;
        __reflect(CameraPostQueue_Depth.prototype, "egret3d.framework.CameraPostQueue_Depth", ["egret3d.framework.ICameraPostQueue"]);
        var CameraPostQueue_Quad = (function () {
            function CameraPostQueue_Quad() {
                this.renderTarget = null;
                this.material = new framework.Material();
            }
            CameraPostQueue_Quad.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                egret3d.render.Webglkit.zWrite(true);
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = egret3d.framework.DefaultMeshes.Quad;
                context.drawtype = "";
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
            };
            return CameraPostQueue_Quad;
        }());
        framework.CameraPostQueue_Quad = CameraPostQueue_Quad;
        __reflect(CameraPostQueue_Quad.prototype, "egret3d.framework.CameraPostQueue_Quad", ["egret3d.framework.ICameraPostQueue"]);
        var CameraPostQueue_Color = (function () {
            function CameraPostQueue_Color() {
                this.renderTarget = null;
            }
            CameraPostQueue_Color.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                egret3d.render.GlRenderTarget.useNull(context.webgl);
            };
            return CameraPostQueue_Color;
        }());
        framework.CameraPostQueue_Color = CameraPostQueue_Color;
        __reflect(CameraPostQueue_Color.prototype, "egret3d.framework.CameraPostQueue_Color", ["egret3d.framework.ICameraPostQueue"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EffectSystem = (function () {
            function EffectSystem() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.Default;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.frameId = 0;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new egret3d.framework.EffectParser();
                this.vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Normal | egret3d.render.VertexFormatMask.Tangent | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0;
                this.particleVF = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
            }
            EffectSystem_1 = EffectSystem;
            EffectSystem.prototype.setEffect = function (effectConfig) {
                this.data = this.parser.Parse(effectConfig);
            };
            EffectSystem.prototype.setJsonData = function (_jsonData) {
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content);
            };
            Object.defineProperty(EffectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EffectSystem.prototype, "totalFrameCount", {
                get: function () {
                    return this.data.life * EffectSystem_1.fps;
                },
                enumerable: true,
                configurable: true
            });
            EffectSystem.prototype.start = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            EffectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined) {
                    return;
                }
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play) {
                        this.playTimer += delta * this.speed;
                    }
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                    }
                    else {
                        this.gameObject.visible = false;
                    }
                }
            };
            EffectSystem.prototype._update = function (delta) {
                if (this.checkFrameId()) {
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        for (var key in subEffectBatcher.effectElements) {
                            var element = subEffectBatcher.effectElements[key];
                            var frameId = this.curFrameId % element.loopFrame;
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (var j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isActiveFrame(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.frameId = this.curFrameId % this.particles.loopFrame;
                        this.particles.update(1 / EffectSystem_1.fps);
                    }
                }
            };
            EffectSystem.prototype.mergeLerpAttribData = function (realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined)
                    return;
                for (var key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        var val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof egret3d.math.Vector3 || val instanceof egret3d.math.Vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            };
            EffectSystem.prototype.updateEffectBatcher = function (effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                var mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                var vertexCount = mesh.data.pos.length;
                var vertexArr = curAttrsData.meshdataVbo;
                var vertexSize = effectBatcher.vertexSize;
                for (var i = 0; i < vertexCount; i++) {
                    var vertex = egret3d.math.Pool.new_vector3();
                    vertex.x = vertexArr[i * vertexSize + 0];
                    vertex.y = vertexArr[i * vertexSize + 1];
                    vertex.z = vertexArr[i * vertexSize + 2];
                    egret3d.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                    egret3d.math.Pool.delete_vector3(vertex);
                    var r = vertexArr[i * vertexSize + 9];
                    var g = vertexArr[i * vertexSize + 10];
                    var b = vertexArr[i * vertexSize + 11];
                    var a = vertexArr[i * vertexSize + 12];
                    if (curAttrsData.color != undefined) {
                        r = curAttrsData.color.x;
                        g = curAttrsData.color.y;
                        b = curAttrsData.color.z;
                    }
                    if (curAttrsData.alpha != undefined)
                        a = curAttrsData.alpha;
                    if (curAttrsData.colorRate != undefined) {
                        r *= curAttrsData.colorRate;
                        g *= curAttrsData.colorRate;
                        b *= curAttrsData.colorRate;
                        a *= curAttrsData.colorRate;
                    }
                    r = egret3d.math.floatClamp(r, 0, 3);
                    g = egret3d.math.floatClamp(g, 0, 3);
                    b = egret3d.math.floatClamp(b, 0, 3);
                    a = egret3d.math.floatClamp(a, 0, 3);
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                    effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                }
            };
            EffectSystem.prototype.render = function (context, camera) {
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        var mesh = subEffectBatcher.mesh;
                        if (!subEffectBatcher.beBufferInited) {
                            mesh.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (mesh.glMesh.ebos.length == 0) {
                                mesh.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                            }
                            else {
                                mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.beBufferInited = true;
                        }
                        mesh.glMesh.uploadVertexSubData(context.webgl, subEffectBatcher.dataForVbo);
                        subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base");
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, camera);
                    }
                }
            };
            EffectSystem.prototype.clone = function () {
                var effect = new EffectSystem_1();
                effect.data = this.data.clone();
                return effect;
            };
            EffectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
            };
            EffectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            EffectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            EffectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                restSinglemesh && this.resetSingleMesh();
                resetParticle && this.resetparticle();
            };
            EffectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined) {
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                        }
                    }
                }
            };
            EffectSystem.prototype.resetparticle = function () {
                if (this.particles != undefined) {
                    this.particles.dispose();
                }
                for (var index in this.data.elements) {
                    var data = this.data.elements[index];
                    if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                }
            };
            EffectSystem.prototype.addElements = function () {
                for (var index in this.data.elements) {
                    var data = this.data.elements[index];
                    if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                    else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                        this.addInitFrame(data);
                    }
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            EffectSystem.prototype.addInitFrame = function (elementData) {
                var scene = this.gameObject.getScene();
                if (!scene)
                    return;
                var element = new framework.EffectElement(elementData, scene);
                element.transform = this.gameObject.transform;
                var _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined) {
                    return;
                }
                var index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (var i_2 = 0; i_2 < this.matDataGroups.length; i_2++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i_2], _initFrameData.attrsData.mat)) {
                            index = i_2;
                            break;
                        }
                    }
                }
                var vertexStartIndex = 0;
                var vertexCount = _initFrameData.attrsData.mesh.data.pos.length;
                var subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.Mesh();
                    subEffectBatcher.mesh.data = new egret3d.render.MeshData();
                    subEffectBatcher.mesh.glMesh = new egret3d.render.GlMesh();
                    subEffectBatcher.mat = new framework.Material();
                    subEffectBatcher.mesh.submesh = [];
                    var sm = new framework.SubMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    subEffectBatcher.mesh.submesh.push(sm);
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.AssetMap.find("diffuse.shader.json"));
                        console.error("特效 {0} shader为空", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined) {
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    }
                    if (_initFrameData.attrsData.mat.diffuseTexture != null) {
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    }
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startIndex = vertexStartIndex;
                element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
                var vertexSize = subEffectBatcher.vertexSize;
                var vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                    var vertex = egret3d.math.Pool.new_vector3();
                    vertex.x = vertexArr[i_3 * vertexSize + 0];
                    vertex.y = vertexArr[i_3 * vertexSize + 1];
                    vertex.z = vertexArr[i_3 * vertexSize + 2];
                    egret3d.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 0] = vertex.x;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 1] = vertex.y;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 2] = vertex.z;
                    egret3d.math.Pool.delete_vector3(vertex);
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 3] = vertexArr[i_3 * vertexSize + 3];
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 4] = vertexArr[i_3 * vertexSize + 4];
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 5] = vertexArr[i_3 * vertexSize + 5];
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 6] = vertexArr[i_3 * vertexSize + 6];
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 7] = vertexArr[i_3 * vertexSize + 7];
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 8] = vertexArr[i_3 * vertexSize + 8];
                    var r = egret3d.math.floatClamp(element.curAttrData.color.x, 0, 1);
                    var g = egret3d.math.floatClamp(element.curAttrData.color.y, 0, 1);
                    var b = egret3d.math.floatClamp(element.curAttrData.color.z, 0, 1);
                    var a = egret3d.math.floatClamp(vertexArr[i_3 * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 9] = r;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 10] = g;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 11] = b;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 12] = a;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 13] = vertexArr[i_3 * vertexSize + 13] * element.curAttrData.tilling.x;
                    subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 14] = vertexArr[i_3 * vertexSize + 14] * element.curAttrData.tilling.y;
                }
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                var _startIndex = subEffectBatcher.indexStartIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
                this.effectBatchers[index].beBufferInited = false;
            };
            EffectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount) {
                    this.curFrameId = id;
                }
            };
            EffectSystem.prototype.checkFrameId = function () {
                var curid = (EffectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    return true;
                }
                return false;
            };
            EffectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                this.data.dispose();
                for (var key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles) {
                    this.particles.dispose();
                }
            };
            Object.defineProperty(EffectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else {
                        return 9999999999;
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectSystem.fps = 30;
            __decorate([
                egret3d.reflect.Field("Textasset"),
                __metadata("design:type", framework.Textasset)
            ], EffectSystem.prototype, "jsonData", void 0);
            EffectSystem = EffectSystem_1 = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent,
                egret3d.reflect.selfClone
            ], EffectSystem);
            return EffectSystem;
            var EffectSystem_1;
        }());
        framework.EffectSystem = EffectSystem;
        __reflect(EffectSystem.prototype, "egret3d.framework.EffectSystem", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Guidpath = (function () {
            function Guidpath() {
                this.speed = 1;
                this.isactived = false;
                this.loopCount = 1;
                this.isloop = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.lookforward = false;
                this.adjustDir = false;
            }
            Object.defineProperty(Guidpath.prototype, "pathasset", {
                get: function () {
                    return this._pathasset;
                },
                set: function (pathasset) {
                    if (this._pathasset) {
                        this._pathasset.unuse();
                    }
                    this._pathasset = pathasset;
                    if (this._pathasset) {
                        this._pathasset.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Guidpath.prototype.play = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.loopCount = loopCount;
            };
            Guidpath.prototype.pause = function () {
                this.isactived = false;
            };
            Guidpath.prototype.stop = function () {
                this.isactived = false;
                this.folowindex = 0;
            };
            Guidpath.prototype.replay = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.folowindex = 0;
                this.loopCount = loopCount;
            };
            Guidpath.prototype.setpathasset = function (pathasset, speed, oncomplete) {
                if (speed === void 0) { speed = 1; }
                if (oncomplete === void 0) { oncomplete = null; }
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasset（error：null）");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    this.gameObject.transform.setLocalPosition(this.paths[0]);
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            };
            Guidpath.prototype.start = function () {
            };
            Guidpath.prototype.update = function (delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            };
            Guidpath.prototype.followmove = function (delta) {
                var dist = egret3d.math.vec3Distance(this.mystrans.getLocalPosition(), this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new egret3d.math.Vector3();
                        this.mystrans.setLocalPosition(this.paths[this.folowindex]);
                        this.folowindex++;
                        this.adjustDir = true;
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.loopCount--;
                            if (this.loopCount == 0) {
                                this.isactived = false;
                                this.loopCount = 1;
                                if (this.oncomplete) {
                                    this.oncomplete();
                                }
                            }
                        }
                    }
                }
                else {
                    var dir = new egret3d.math.Vector3();
                    egret3d.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.getLocalPosition(), dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.getLocalPosition();
                        var quat = egret3d.math.Pool.new_quaternion();
                        egret3d.math.quatLookat(localppos, targetpos, quat);
                        egret3d.math.quatClone(quat, this.mystrans.getLocalRotation());
                        egret3d.math.Pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    var resultPosition = new egret3d.math.Vector3();
                    egret3d.math.vec3SLerp(this.mystrans.getLocalPosition(), this.paths[this.folowindex], lerp, resultPosition);
                    this.mystrans.setLocalPosition(resultPosition);
                }
            };
            Guidpath.prototype.remove = function () {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            };
            Guidpath.prototype.clone = function () {
            };
            Guidpath = __decorate([
                egret3d.reflect.nodeComponent
            ], Guidpath);
            return Guidpath;
        }());
        framework.Guidpath = Guidpath;
        __reflect(Guidpath.prototype, "egret3d.framework.Guidpath", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        var Light = (function () {
            function Light() {
                this.isOpen = false;
                this.spotAngelCos = 0.9;
            }
            Light.prototype.start = function () {
            };
            Light.prototype.update = function (delta) {
            };
            Light.prototype.remove = function () {
            };
            Light.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], Light.prototype, "isOpen", void 0);
            __decorate([
                egret3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], Light.prototype, "lightName", void 0);
            Light = __decorate([
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeLight
            ], Light);
            return Light;
        }());
        framework.Light = Light;
        __reflect(Light.prototype, "egret3d.framework.Light", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var MeshCollider = (function () {
            function MeshCollider() {
                this._colliderVisible = false;
            }
            MeshCollider.prototype.getBound = function () {
                return this.mesh;
            };
            MeshCollider.prototype.start = function () {
                var filter = this.gameObject.getComponent("MeshFilter");
                if (filter != null) {
                    this.mesh = filter.getMeshOutput();
                    this.buildMesh();
                }
            };
            MeshCollider.prototype.update = function (delta) {
            };
            Object.defineProperty(MeshCollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            MeshCollider.prototype.intersectsTransform = function (tran) {
                return false;
            };
            MeshCollider.prototype.buildMesh = function () {
                this.subTran = new egret3d.framework.Transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "meshcollider";
                var mesh = this.subTran.gameObject.addComponent("MeshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("MeshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
            };
            MeshCollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.Mesh();
                _mesh.data = this.mesh.data;
                var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new egret3d.render.GlMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = i16.length;
                sm.line = true;
                _mesh.submesh.push(sm);
                return _mesh;
            };
            MeshCollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            MeshCollider.prototype.clone = function () {
            };
            MeshCollider = __decorate([
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeMeshCollider
            ], MeshCollider);
            return MeshCollider;
        }());
        framework.MeshCollider = MeshCollider;
        __reflect(MeshCollider.prototype, "egret3d.framework.MeshCollider", ["egret3d.framework.INodeComponent", "egret3d.framework.ICollider"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var MeshFilter = (function () {
            function MeshFilter() {
            }
            MeshFilter.prototype.start = function () {
            };
            MeshFilter.prototype.update = function (delta) {
            };
            Object.defineProperty(MeshFilter.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            MeshFilter.prototype.getMeshOutput = function () {
                return this._mesh;
            };
            MeshFilter.prototype.remove = function () {
                if (this.mesh) {
                    this.mesh.unuse(true);
                }
            };
            MeshFilter.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("Mesh"),
                egret3d.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.Mesh])
            ], MeshFilter.prototype, "mesh", null);
            MeshFilter = __decorate([
                egret3d.reflect.nodeComponent
            ], MeshFilter);
            return MeshFilter;
        }());
        framework.MeshFilter = MeshFilter;
        __reflect(MeshFilter.prototype, "egret3d.framework.MeshFilter", ["egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var MeshRenderer = (function () {
            function MeshRenderer() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.Default;
                this._queue = 0;
                this.issetq = false;
                this.materials = [];
                this.lightmapIndex = -1;
                this.lightmapScaleOffset = new egret3d.math.Vector4(1, 1, 0, 0);
            }
            Object.defineProperty(MeshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            MeshRenderer.prototype.start = function () {
                this.filter = this.gameObject.getComponent("MeshFilter");
                this.refreshLayerAndQue();
            };
            MeshRenderer.prototype.refreshLayerAndQue = function () {
                if (this.materials == null || this.materials.length == 0) {
                    this.materials = [];
                    this.materials.push(new framework.Material());
                    this.materials[0].setShader(framework.DefaultShaders.Diffuse);
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq) {
                    this._queue = this.materials[0].getQueue();
                }
            };
            MeshRenderer.prototype.update = function (delta) {
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq) {
                            this._queue = _mat.getQueue();
                        }
                    }
                }
            };
            MeshRenderer.prototype.render = function (context, camera) {
                context.updateModel(this.gameObject.transform);
                if (this.filter != null) {
                    var mesh = this.filter.getMeshOutput();
                    if (mesh != null && mesh.submesh != null) {
                        for (var i = 0; i < mesh.submesh.length; i++) {
                            var sm = mesh.submesh[i];
                            var mid = mesh.submesh[i].matIndex;
                            var usemat = this.materials[mid];
                            var drawtype = "base";
                            if (this.lightmapIndex >= 0) {
                                drawtype = "lightmap";
                                if (this.gameObject.transform.scene.lightmaps.length > this.lightmapIndex) {
                                    context.updateLightmap(this.gameObject.transform.scene.lightmaps[this.lightmapIndex], mesh.glMesh.vertexFormat & egret3d.render.VertexFormatMask.UV1 ? 1 : 0, this.lightmapScaleOffset);
                                }
                            }
                            if (usemat != null) {
                                usemat.draw(context, mesh, sm, drawtype);
                            }
                        }
                    }
                }
            };
            MeshRenderer.prototype.remove = function () {
                this.materials.length = 0;
            };
            MeshRenderer.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("Material[]"),
                __metadata("design:type", Array)
            ], MeshRenderer.prototype, "materials", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], MeshRenderer.prototype, "lightmapIndex", void 0);
            __decorate([
                egret3d.reflect.Field("Vector4"),
                __metadata("design:type", egret3d.math.Vector4)
            ], MeshRenderer.prototype, "lightmapScaleOffset", void 0);
            MeshRenderer = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent
            ], MeshRenderer);
            return MeshRenderer;
        }());
        framework.MeshRenderer = MeshRenderer;
        __reflect(MeshRenderer.prototype, "egret3d.framework.MeshRenderer", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var SkinnedMeshRenderer = (function () {
            function SkinnedMeshRenderer() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.Default;
                this._queue = 0;
                this.issetq = false;
                this.maxBoneCount = 0;
                this._skintype = 0;
                this._efficient = true;
            }
            SkinnedMeshRenderer_1 = SkinnedMeshRenderer;
            Object.defineProperty(SkinnedMeshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SkinnedMeshRenderer.prototype, "player", {
                get: function () {
                    if (this._player == null) {
                        this._player = this.gameObject.getComponentInParent("AniPlayer");
                    }
                    return this._player;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            SkinnedMeshRenderer.prototype.start = function () {
            };
            SkinnedMeshRenderer.prototype.getMatByIndex = function (index) {
                var data = this.mesh.data;
                if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                var mat = new egret3d.math.Matrix();
                if (this._efficient) {
                    var vec40r = egret3d.math.Pool.new_vector4();
                    var vec30p = egret3d.math.Pool.new_vector3();
                    vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
                    vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
                    vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
                    vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
                    vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
                    vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
                    vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
                    var vec41r = egret3d.math.Pool.new_vector4();
                    var vec31p = egret3d.math.Pool.new_vector3();
                    vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
                    vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
                    vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
                    vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
                    vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
                    vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
                    vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
                    var vec42r = egret3d.math.Pool.new_vector4();
                    var vec32p = egret3d.math.Pool.new_vector3();
                    vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
                    vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
                    vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
                    vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
                    vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
                    vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
                    vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
                    var vec43r = egret3d.math.Pool.new_vector4();
                    var vec33p = egret3d.math.Pool.new_vector3();
                    vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
                    vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
                    vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
                    vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
                    vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
                    vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
                    vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
                    var mat0 = egret3d.math.Pool.new_matrix();
                    var mat1 = egret3d.math.Pool.new_matrix();
                    var mat2 = egret3d.math.Pool.new_matrix();
                    var mat3 = egret3d.math.Pool.new_matrix();
                    egret3d.math.matrixMakeTransformRTS(vec30p, egret3d.math.Pool.vector3_one, vec40r, mat0);
                    egret3d.math.matrixMakeTransformRTS(vec31p, egret3d.math.Pool.vector3_one, vec41r, mat1);
                    egret3d.math.matrixMakeTransformRTS(vec32p, egret3d.math.Pool.vector3_one, vec42r, mat2);
                    egret3d.math.matrixMakeTransformRTS(vec33p, egret3d.math.Pool.vector3_one, vec43r, mat3);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    egret3d.math.matrixAdd(mat0, mat1, mat);
                    egret3d.math.matrixAdd(mat, mat2, mat);
                    egret3d.math.matrixAdd(mat, mat3, mat);
                    egret3d.math.Pool.delete_vector4(vec40r);
                    egret3d.math.Pool.delete_vector4(vec41r);
                    egret3d.math.Pool.delete_vector4(vec42r);
                    egret3d.math.Pool.delete_vector4(vec43r);
                    egret3d.math.Pool.delete_vector3(vec30p);
                    egret3d.math.Pool.delete_vector3(vec31p);
                    egret3d.math.Pool.delete_vector3(vec32p);
                    egret3d.math.Pool.delete_vector3(vec33p);
                    egret3d.math.Pool.delete_matrix(mat0);
                    egret3d.math.Pool.delete_matrix(mat1);
                    egret3d.math.Pool.delete_matrix(mat2);
                    egret3d.math.Pool.delete_matrix(mat3);
                }
                else {
                    var mat0 = egret3d.math.Pool.new_matrix();
                    mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
                    var mat1 = egret3d.math.Pool.new_matrix();
                    mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
                    var mat2 = egret3d.math.Pool.new_matrix();
                    mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
                    var mat3 = egret3d.math.Pool.new_matrix();
                    mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    egret3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    egret3d.math.matrixAdd(mat0, mat1, mat);
                    egret3d.math.matrixAdd(mat, mat2, mat);
                    egret3d.math.matrixAdd(mat, mat3, mat);
                    egret3d.math.Pool.delete_matrix(mat0);
                    egret3d.math.Pool.delete_matrix(mat1);
                    egret3d.math.Pool.delete_matrix(mat2);
                    egret3d.math.Pool.delete_matrix(mat3);
                }
                return mat;
            };
            SkinnedMeshRenderer.prototype.intersects = function (ray) {
                var mvpmat = this.player.gameObject.transform.getWorldMatrix();
                var pickinfo = null;
                var data = this.mesh.data;
                for (var i = 0; i < this.mesh.submesh.length; i++) {
                    var submesh = this.mesh.submesh[i];
                    var t0 = egret3d.math.Pool.new_vector3();
                    var t1 = egret3d.math.Pool.new_vector3();
                    var t2 = egret3d.math.Pool.new_vector3();
                    for (var index = submesh.start; index < submesh.size; index += 3) {
                        var verindex0 = data.trisindex[index];
                        var verindex1 = data.trisindex[index + 1];
                        var verindex2 = data.trisindex[index + 2];
                        var p0 = data.pos[verindex0];
                        var p1 = data.pos[verindex1];
                        var p2 = data.pos[verindex2];
                        var mat0 = this.getMatByIndex(verindex0);
                        var mat1 = this.getMatByIndex(verindex1);
                        var mat2 = this.getMatByIndex(verindex2);
                        if (mat0 == null || mat1 == null || mat2 == null)
                            continue;
                        var mat00 = egret3d.math.Pool.new_matrix();
                        egret3d.math.matrixMultiply(mvpmat, mat0, mat00);
                        var mat11 = egret3d.math.Pool.new_matrix();
                        egret3d.math.matrixMultiply(mvpmat, mat1, mat11);
                        var mat22 = egret3d.math.Pool.new_matrix();
                        egret3d.math.matrixMultiply(mvpmat, mat2, mat22);
                        egret3d.math.matrixTransformVector3(p0, mat00, t0);
                        egret3d.math.matrixTransformVector3(p1, mat11, t1);
                        egret3d.math.matrixTransformVector3(p2, mat22, t2);
                        var result = ray.intersectsTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.faceId = index / 3;
                                pickinfo.subMeshId = i;
                                var tdir = egret3d.math.Pool.new_vector3();
                                egret3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                egret3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                            }
                        }
                    }
                    egret3d.math.Pool.delete_vector3(t0);
                    egret3d.math.Pool.delete_vector3(t1);
                    egret3d.math.Pool.delete_vector3(t2);
                }
                return pickinfo;
            };
            SkinnedMeshRenderer.prototype.update = function (delta) {
                if (this._skeletonMatrixData == null) {
                    this._skintype = this.useBoneShader(this.materials[0]);
                    if (this._skintype == 1) {
                        this.maxBoneCount = 24;
                        this._skeletonMatrixData = new Float32Array(16 * this.maxBoneCount);
                        this._efficient = false;
                    }
                    else if (this._skintype == 2) {
                        this.maxBoneCount = 55;
                        this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                        this._efficient = true;
                    }
                }
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq) {
                            this._queue = _mat.getQueue();
                        }
                    }
                }
                if (this.player != null) {
                    if (this.player.isCache && !this.player.mix) {
                        var cacheKey = this.player.cacheKey + "_" + this.mesh.getGUID();
                        var data = SkinnedMeshRenderer_1.dataCaches[cacheKey];
                        if (!data) {
                            var _cachePlayer = framework.AniPlayer.playerCaches[this.player.cacheKey];
                            if (_cachePlayer) {
                                data = new Float32Array(8 * 60);
                                _cachePlayer.fillPoseData(data, this.bones, true);
                                SkinnedMeshRenderer_1.dataCaches[cacheKey] = data;
                                this.cacheData = data;
                                return;
                            }
                        }
                        else {
                            this.cacheData = data;
                            return;
                        }
                    }
                    this.cacheData = null;
                    if (this._skeletonMatrixData != null) {
                        this.player.fillPoseData(this._skeletonMatrixData, this.bones, this._efficient);
                    }
                }
            };
            SkinnedMeshRenderer.prototype.render = function (context, camera) {
                if (this.player != null) {
                    context.updateModel(this.player.gameObject.transform);
                }
                for (var i_4 = 0; i_4 < this.materials.length; i_4++) {
                    if (this.materials[i_4] == null)
                        continue;
                    if (this.cacheData != null && this._skintype > 0) {
                        context.updateBones(this.cacheData);
                        continue;
                    }
                    if (this._skeletonMatrixData != null && this._skintype > 0) {
                        context.updateBones(this._skeletonMatrixData);
                    }
                }
                if (this._mesh != null) {
                    if (this._mesh != null) {
                        if (this._mesh.submesh != null) {
                            for (var i = 0; i < this._mesh.submesh.length; i++) {
                                var sm = this._mesh.submesh[i];
                                var mid = this._mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                if (usemat != null) {
                                    {
                                        usemat.draw(context, this._mesh, sm, "skin");
                                    }
                                }
                            }
                        }
                    }
                }
            };
            SkinnedMeshRenderer.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse(true);
                this.bones.length = 0;
            };
            SkinnedMeshRenderer.prototype.clone = function () {
            };
            SkinnedMeshRenderer.prototype.useBoneShader = function (mat) {
                var matpasses = mat.getShader().passes["skin"];
                if (matpasses == null || matpasses.length == 0)
                    return 0;
                if (matpasses[0].uniforms["glstate_vec4_bones"]) {
                    return 2;
                }
                else if (matpasses[0].uniforms["glstate_matrix_bones"]) {
                    return 1;
                }
                else {
                    return 0;
                }
            };
            SkinnedMeshRenderer.dataCaches = [];
            __decorate([
                egret3d.reflect.Field("Material[]"),
                __metadata("design:type", Array)
            ], SkinnedMeshRenderer.prototype, "materials", void 0);
            __decorate([
                egret3d.reflect.Field("Mesh"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.Mesh])
            ], SkinnedMeshRenderer.prototype, "mesh", null);
            __decorate([
                egret3d.reflect.Field("Transform[]"),
                __metadata("design:type", Array)
            ], SkinnedMeshRenderer.prototype, "bones", void 0);
            __decorate([
                egret3d.reflect.Field("Transform"),
                __metadata("design:type", framework.Transform)
            ], SkinnedMeshRenderer.prototype, "rootBone", void 0);
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], SkinnedMeshRenderer.prototype, "center", void 0);
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], SkinnedMeshRenderer.prototype, "size", void 0);
            SkinnedMeshRenderer = SkinnedMeshRenderer_1 = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent
            ], SkinnedMeshRenderer);
            return SkinnedMeshRenderer;
            var SkinnedMeshRenderer_1;
        }());
        framework.SkinnedMeshRenderer = SkinnedMeshRenderer;
        __reflect(SkinnedMeshRenderer.prototype, "egret3d.framework.SkinnedMeshRenderer", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Spherestruct = (function () {
            function Spherestruct(_center, _r) {
                this.center = egret3d.math.Pool.clone_vector3(_center);
                this.srcradius = _r;
                this.tempScale = new egret3d.math.Vector3();
            }
            Spherestruct.prototype.update = function (worldmatrix) {
                egret3d.math.matrixGetTranslation(worldmatrix, this.center);
                egret3d.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            };
            Spherestruct.prototype.intersects = function (bound) {
                if (bound instanceof Spherestruct) {
                    var dis = egret3d.math.vec3Distance(this.center, bound.center);
                    if (dis > this.radius + bound.radius)
                        return false;
                    return true;
                }
                else if (bound instanceof framework.Obb) {
                }
            };
            return Spherestruct;
        }());
        framework.Spherestruct = Spherestruct;
        __reflect(Spherestruct.prototype, "egret3d.framework.Spherestruct");
        var SphereCollider = (function () {
            function SphereCollider() {
                this._worldCenter = new egret3d.math.Vector3();
                this._colliderVisible = false;
            }
            Object.defineProperty(SphereCollider.prototype, "worldCenter", {
                get: function () {
                    egret3d.math.vec3Clone(this.center, this._worldCenter);
                    egret3d.math.matrixTransformVector3(this._worldCenter, this.gameObject.transform.getWorldMatrix(), this._worldCenter);
                    return this._worldCenter;
                },
                enumerable: true,
                configurable: true
            });
            SphereCollider.prototype.getBound = function () {
                return this.spherestruct;
            };
            Object.defineProperty(SphereCollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject) {
                        return this.gameObject.transform.getWorldMatrix();
                    }
                    return new egret3d.math.Matrix();
                },
                enumerable: true,
                configurable: true
            });
            SphereCollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("MeshFilter");
                this.build();
            };
            SphereCollider.prototype.update = function (delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                }
            };
            Object.defineProperty(SphereCollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            SphereCollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            };
            SphereCollider.prototype.build = function () {
                if (this.center && this.radius) {
                    this.spherestruct = new Spherestruct(this.center, this.radius);
                }
            };
            SphereCollider.prototype.buildMesh = function () {
                this.subTran = new egret3d.framework.Transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "spherecollider";
                var mesh = this.subTran.gameObject.addComponent("MeshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("MeshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
            };
            SphereCollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.Mesh();
                return _mesh;
            };
            SphereCollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            SphereCollider.prototype.clone = function () {
            };
            __decorate([
                egret3d.reflect.Field("Vector3"),
                __metadata("design:type", egret3d.math.Vector3)
            ], SphereCollider.prototype, "center", void 0);
            __decorate([
                egret3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], SphereCollider.prototype, "radius", void 0);
            SphereCollider = __decorate([
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeSphereCollider
            ], SphereCollider);
            return SphereCollider;
        }());
        framework.SphereCollider = SphereCollider;
        __reflect(SphereCollider.prototype, "egret3d.framework.SphereCollider", ["egret3d.framework.INodeComponent", "egret3d.framework.ICollider"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var TrailRender_recorde = (function () {
            function TrailRender_recorde() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.Default;
                this.queue = 0;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false;
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            Object.defineProperty(TrailRender_recorde.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new egret3d.framework.Material();
                        mat.setShader(framework.DefaultShaders.Diffuse);
                        this._material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this._material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrailRender_recorde.prototype, "startColor", {
                get: function () {
                    if (this._startColor == undefined) {
                        this._startColor = new egret3d.math.Color(1, 1, 1, 1);
                    }
                    return this._startColor;
                },
                set: function (color) {
                    this._startColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrailRender_recorde.prototype, "endColor", {
                get: function () {
                    if (this._endColor == undefined) {
                        this._endColor = new egret3d.math.Color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                    }
                    return this._endColor;
                },
                set: function (color) {
                    this._endColor = color;
                },
                enumerable: true,
                configurable: true
            });
            TrailRender_recorde.prototype.setWidth = function (startWidth, endWidth) {
                if (endWidth === void 0) { endWidth = 0; }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            };
            TrailRender_recorde.prototype.setMaxpointcontroll = function (value) {
                if (value === void 0) { value = false; }
                this.activeMaxpointlimit = value;
            };
            TrailRender_recorde.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = egret3d.render.Webglkit.webgl;
                this.mesh = new egret3d.framework.Mesh();
                this.mesh.data = new egret3d.render.MeshData();
                this.mesh.glMesh = new egret3d.render.GlMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, egret3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = this.dataForEbo.length;
                sm.line = false;
                this.mesh.submesh.push(sm);
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            };
            TrailRender_recorde.prototype.update = function (delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            };
            TrailRender_recorde.prototype.remove = function () {
            };
            TrailRender_recorde.prototype.refreshTrailNode = function (curTime) {
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                var pos = new egret3d.math.Vector3();
                egret3d.math.vec3Clone(this.gameObject.transform.getPosition(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (egret3d.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new egret3d.math.Vector3();
                this.gameObject.transform.getUp(updir);
                var newNode = new TrailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new egret3d.math.Vector3();
                        egret3d.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        egret3d.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new egret3d.math.Vector3();
                            egret3d.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            egret3d.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = egret3d.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new egret3d.math.Vector3();
                            var tempRhandle = egret3d.math.Pool.new_vector3();
                            var tempLhandle = egret3d.math.Pool.new_vector3();
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            egret3d.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            egret3d.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            egret3d.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            egret3d.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            egret3d.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new egret3d.math.Vector3();
                            egret3d.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new TrailNode(inter_pos, inter_updir, curTime);
                            this.interpPath.splice(1, 0, inter_node);
                            egret3d.math.Pool.delete_vector3(tempRhandle);
                            egret3d.math.Pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            };
            TrailRender_recorde.prototype.updateTrailData = function (curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new egret3d.math.Vector3();
                    egret3d.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    egret3d.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = egret3d.math.Pool.new_vector3();
                    egret3d.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = egret3d.math.Pool.new_color();
                    egret3d.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    egret3d.math.Pool.delete_vector3(tempPos);
                    egret3d.math.Pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            };
            TrailRender_recorde.prototype.checkBufferSize = function () {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            };
            TrailRender_recorde.prototype.render = function (context, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexSubData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
            };
            TrailRender_recorde.prototype.clone = function () {
            };
            TrailRender_recorde = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent
            ], TrailRender_recorde);
            return TrailRender_recorde;
        }());
        framework.TrailRender_recorde = TrailRender_recorde;
        __reflect(TrailRender_recorde.prototype, "egret3d.framework.TrailRender_recorde", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent"]);
        var TrailNode = (function () {
            function TrailNode(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
            return TrailNode;
        }());
        framework.TrailNode = TrailNode;
        __reflect(TrailNode.prototype, "egret3d.framework.TrailNode");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Egret2DRenderer = (function () {
            function Egret2DRenderer() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.UI;
                this.renderLayer = framework.CullingMask.UI;
                this.queue = 0;
                this._screenAdapter = new framework.ConstantAdapter();
                this._catchedEvent = {};
                this._stageWidth = 0;
                this._stageHeight = 0;
                this._scaler = 1;
                var stage = new egret.Stage();
                stage.maxTouches = 1;
                this.stage = stage;
                this.root = new egret.DisplayObjectContainer();
                this.stage.addChild(this.root);
            }
            Egret2DRenderer.prototype.getBound = function () {
                return null;
            };
            Egret2DRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
                get: function () {
                    return this._screenAdapter;
                },
                set: function (adapter) {
                    adapter.$dirty = true;
                    this._screenAdapter = adapter;
                },
                enumerable: true,
                configurable: true
            });
            Egret2DRenderer.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                var context = this.app.webgl;
                if (!this.renderer) {
                    this.renderer = egret.web.Renderer.getInstance(context, this.app);
                }
                var stage = this.stage;
                var displayList = new egret.sys.DisplayList(stage);
                displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
                stage.$displayList = displayList;
                this.app.inputManager.touch.addEventListener("touchstart", this._onTouchStart, this);
                this.app.inputManager.touch.addEventListener("touchend", this._onTouchEnd, this);
                this.app.inputManager.touch.addEventListener("touchcancel", this._onTouchEnd, this);
                this.app.inputManager.touch.addEventListener("touchmove", this._onTouchMove, this);
                this.app.inputManager.mouse.addEventListener("mousedown", this._onTouchStart, this);
                this.app.inputManager.mouse.addEventListener("mouseup", this._onTouchEnd, this);
                this.app.inputManager.mouse.addEventListener("mousemove", this._onTouchMove, this);
            };
            Egret2DRenderer.prototype.checkEventThrough = function (x, y) {
                return !!this._catchedEvent[x + "_" + y];
            };
            Egret2DRenderer.prototype._onTouchStart = function (event) {
                if (this.stage.$onTouchBegin(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                    this._catchedEvent[event.x + "_" + event.y] = true;
                }
            };
            Egret2DRenderer.prototype._onTouchMove = function (event) {
                if (this.stage.$onTouchMove(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                    this._catchedEvent[event.x + "_" + event.y] = true;
                }
            };
            Egret2DRenderer.prototype._onTouchEnd = function (event) {
                if (this.stage.$onTouchEnd(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                    this._catchedEvent[event.x + "_" + event.y] = true;
                }
            };
            Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
                if (out === void 0) { out = new egret3d.math.Vector2(); }
                out.x = pos.x / this._scaler;
                out.y = pos.y / this._scaler;
                return out;
            };
            Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
                get: function () {
                    return this._scaler;
                },
                enumerable: true,
                configurable: true
            });
            Egret2DRenderer.prototype.update = function (delta) {
                var stage = this.stage;
                if (this._stageWidth != this.app.width || this._stageHeight != this.app.height || this.screenAdapter.$dirty) {
                    var result = { w: 0, h: 0, s: 0 };
                    this.screenAdapter.calculateScaler(this.app.width, this.app.height, result);
                    this.screenAdapter.$dirty = false;
                    stage.$displayList["offsetMatrix"].a = result.s;
                    stage.$displayList["offsetMatrix"].d = result.s;
                    this._scaler = result.s;
                    var stageWidth = result.w;
                    var stageHeight = result.h;
                    stage.$stageWidth = stageWidth;
                    stage.$stageHeight = stageHeight;
                    stage.$displayList.setClipRect(this.app.width, this.app.height);
                    stage.dispatchEventWith(egret.Event.RESIZE);
                    this._stageWidth = this.app.width;
                    this._stageHeight = this.app.height;
                }
                this._catchedEvent = {};
            };
            Egret2DRenderer.prototype.render = function (context, camera) {
                var gl = this.app.webgl;
                this.renderer.beforeRender();
                this.stage.drawToSurface();
                egret3d.render.Webglkit.resetState();
            };
            Egret2DRenderer.prototype.remove = function () {
                this.app.inputManager.touch.removeEventListener("touchstart", this._onTouchStart, this);
                this.app.inputManager.touch.removeEventListener("touchend", this._onTouchEnd, this);
                this.app.inputManager.touch.removeEventListener("touchcancel", this._onTouchEnd, this);
                this.app.inputManager.touch.removeEventListener("touchmove", this._onTouchMove, this);
                this.app.inputManager.mouse.removeEventListener("mousedown", this._onTouchStart, this);
                this.app.inputManager.mouse.removeEventListener("mouseup", this._onTouchEnd, this);
                this.app.inputManager.mouse.removeEventListener("mousemove", this._onTouchMove, this);
            };
            Egret2DRenderer.prototype.clone = function () {
            };
            Egret2DRenderer = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent,
                egret3d.reflect.nodeCanvasRendererCollider,
                __metadata("design:paramtypes", [])
            ], Egret2DRenderer);
            return Egret2DRenderer;
        }());
        framework.Egret2DRenderer = Egret2DRenderer;
        __reflect(Egret2DRenderer.prototype, "egret3d.framework.Egret2DRenderer", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent", "egret3d.framework.ICollider"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var InputManager = (function () {
            function InputManager(app) {
                this._touchPoint = new egret3d.math.Vector2();
                this.keyboard = new egret3d.input.KeyboardDevice(window);
                this.mouse = new egret3d.input.MouseDevice(app.webgl.canvas);
                this.touch = new egret3d.input.TouchDevice(app.webgl.canvas);
            }
            InputManager.prototype.update = function (deltaTime) {
                this.keyboard.update();
                this.mouse.update();
                this.touch.update();
            };
            InputManager.prototype.isPressed = function () {
                if (this.mouse.isPressed(0)) {
                    return true;
                }
                else {
                    var t = this.touch.getTouch(0);
                    if (t && this.touch.touchCount == 1) {
                        if (t.phase == egret3d.input.TouchPhase.MOVED || t.phase == egret3d.input.TouchPhase.STATIONARY) {
                            return true;
                        }
                    }
                }
                return false;
            };
            InputManager.prototype.wasPressed = function () {
                if (this.mouse.wasPressed(0)) {
                    return true;
                }
                else {
                    var t = this.touch.getTouch(0);
                    if (t && this.touch.touchCount == 1) {
                        if (t.phase == egret3d.input.TouchPhase.BEGAN) {
                            return true;
                        }
                    }
                }
                return false;
            };
            InputManager.prototype.wasReleased = function () {
                if (this.mouse.wasReleased(0)) {
                    return true;
                }
                else {
                    var t = this.touch.getTouch(0);
                    if (t && this.touch.touchCount == 1) {
                        if (t.phase == egret3d.input.TouchPhase.ENDED || t.phase == egret3d.input.TouchPhase.CANCELED) {
                            return true;
                        }
                    }
                }
                return false;
            };
            InputManager.prototype.getTouchPoint = function () {
                var t = this.touch.getTouch(0);
                if (t) {
                    this._touchPoint.x = t.position.x;
                    this._touchPoint.y = t.position.y;
                }
                else {
                    this._touchPoint.x = this.mouse.position.x;
                    this._touchPoint.y = this.mouse.position.y;
                }
                return this._touchPoint;
            };
            return InputManager;
        }());
        framework.InputManager = InputManager;
        __reflect(InputManager.prototype, "egret3d.framework.InputManager");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var input;
    (function (input) {
        var _keyCodeToKeyIdentifier = {
            'TAB': 9,
            'ENTER': 13,
            'SHIFT': 16,
            'CONTROL': 17,
            'ALT': 18,
            'ESCAPE': 27,
            'LEFT': 37,
            'UP': 38,
            'RIGHT': 39,
            'DOWN': 40,
            'DELETE': 46,
            'WIN': 91
        };
        var KeyboardDevice = (function () {
            function KeyboardDevice(element, options) {
                if (options === void 0) { options = { preventDefault: false, stopPropagation: false }; }
                this._element = null;
                this._keymap = {};
                this._lastmap = {};
                this._keyDownHandler = this._handleKeyDown.bind(this);
                this._keyUpHandler = this._handleKeyUp.bind(this);
                this._keyPressHandler = this._handleKeyPress.bind(this);
                this._cacheKeyCodeMap = {};
                this.attach(element);
                this.preventDefault = options.preventDefault;
                this.stopPropagation = options.stopPropagation;
            }
            KeyboardDevice.prototype.attach = function (element) {
                if (this._element) {
                    this.detach();
                }
                this._element = element;
                this._element.addEventListener("keydown", this._keyDownHandler, false);
                this._element.addEventListener("keypress", this._keyPressHandler, false);
                this._element.addEventListener("keyup", this._keyUpHandler, false);
            };
            KeyboardDevice.prototype.detach = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener("keydown", this._keyDownHandler, false);
                this._element.removeEventListener("keypress", this._keyPressHandler, false);
                this._element.removeEventListener("keyup", this._keyUpHandler, false);
                this._element = null;
            };
            KeyboardDevice.prototype._handleKeyDown = function (event) {
                var code = event.keyCode || event.charCode;
                var id = this._toKeyIdentifier(code);
                this._keymap[id] = true;
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            KeyboardDevice.prototype._handleKeyPress = function (event) {
                var code = event.keyCode || event.charCode;
                var id = this._toKeyIdentifier(code);
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            KeyboardDevice.prototype._handleKeyUp = function (event) {
                var code = event.keyCode || event.charCode;
                var id = this._toKeyIdentifier(code);
                delete this._keymap[id];
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            KeyboardDevice.prototype._toKeyIdentifier = function (keyCode) {
                var code;
                if (typeof (keyCode) == "string") {
                    var upperCode = keyCode.toUpperCase();
                    if (!this._cacheKeyCodeMap[keyCode]) {
                        var _code = _keyCodeToKeyIdentifier[upperCode] || upperCode.charCodeAt(0);
                        this._cacheKeyCodeMap[upperCode] = _code;
                    }
                    code = this._cacheKeyCodeMap[upperCode];
                }
                else {
                    code = keyCode;
                }
                var hex = code.toString(16).toUpperCase();
                var length = hex.length;
                for (var count = 0; count < (4 - length); count++) {
                    hex = '0' + hex;
                }
                return 'U+' + hex;
            };
            KeyboardDevice.prototype.update = function () {
                var prop;
                for (prop in this._lastmap) {
                    delete this._lastmap[prop];
                }
                for (prop in this._keymap) {
                    if (this._keymap.hasOwnProperty(prop)) {
                        this._lastmap[prop] = this._keymap[prop];
                    }
                }
            };
            KeyboardDevice.prototype.isPressed = function (key) {
                var id = this._toKeyIdentifier(key);
                return this._keymap[id];
            };
            KeyboardDevice.prototype.wasPressed = function (key) {
                var id = this._toKeyIdentifier(key);
                return (this._keymap[id] && !this._lastmap[id]);
            };
            KeyboardDevice.prototype.wasReleased = function (key) {
                var id = this._toKeyIdentifier(key);
                return (!this._keymap[id] && this._lastmap[id]);
            };
            return KeyboardDevice;
        }());
        input.KeyboardDevice = KeyboardDevice;
        __reflect(KeyboardDevice.prototype, "egret3d.input.KeyboardDevice");
    })(input = egret3d.input || (egret3d.input = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var input;
    (function (input) {
        var MouseDevice = (function (_super) {
            __extends(MouseDevice, _super);
            function MouseDevice(element) {
                var _this = _super.call(this) || this;
                _this._offsetX = 0;
                _this._offsetY = 0;
                _this._scaler = 1;
                _this.position = new egret3d.math.Vector2();
                _this.wheel = 0;
                _this._buttons = [false, false, false];
                _this._lastbuttons = [false, false, false];
                _this._element = null;
                _this._upHandler = _this._handleUp.bind(_this);
                _this._moveHandler = _this._handleMove.bind(_this);
                _this._downHandler = _this._handleDown.bind(_this);
                _this._wheelHandler = _this._handleWheel.bind(_this);
                _this._contextMenuHandler = function (event) { event.preventDefault(); };
                _this.attach(element);
                return _this;
            }
            MouseDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scaler) {
                this._offsetX = offsetX;
                this._offsetY = offsetY;
                this._scaler = scaler;
            };
            MouseDevice.prototype.convertPosition = function (e, out) {
                out.x = (e.clientX - this._offsetX) * this._scaler;
                out.y = (e.clientY - this._offsetY) * this._scaler;
            };
            MouseDevice.prototype.disableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.addEventListener("contextmenu", this._contextMenuHandler);
            };
            MouseDevice.prototype.enableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener("contextmenu", this._contextMenuHandler);
            };
            MouseDevice.prototype.attach = function (element) {
                if (this._element) {
                    this.detach();
                }
                this._element = element;
                this._element.addEventListener("mouseup", this._upHandler, false);
                this._element.addEventListener("mousemove", this._moveHandler, false);
                this._element.addEventListener("mousedown", this._downHandler, false);
                this._element.addEventListener("mousewheel", this._wheelHandler, false);
                this._element.addEventListener("DOMMouseScroll", this._wheelHandler, false);
            };
            MouseDevice.prototype.detach = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener("mouseup", this._upHandler, false);
                this._element.removeEventListener("mousemove", this._moveHandler, false);
                this._element.removeEventListener("mousedown", this._downHandler, false);
                this._element.removeEventListener("mousewheel", this._wheelHandler, false);
                this._element.removeEventListener("DOMMouseScroll", this._wheelHandler, false);
                this._element = null;
            };
            MouseDevice.prototype.update = function () {
                this._lastbuttons[0] = this._buttons[0];
                this._lastbuttons[1] = this._buttons[1];
                this._lastbuttons[2] = this._buttons[2];
                this.wheel = 0;
            };
            MouseDevice.prototype.isPressed = function (button) {
                return this._buttons[button];
            };
            MouseDevice.prototype.wasPressed = function (button) {
                return (this._buttons[button] && !this._lastbuttons[button]);
            };
            MouseDevice.prototype.wasReleased = function (button) {
                return (!this._buttons[button] && this._lastbuttons[button]);
            };
            MouseDevice.prototype._handleUp = function (event) {
                this._buttons[event.button] = false;
                this.convertPosition(event, this.position);
                this.dispatchEvent({ type: "mouseup", x: this.position.x, y: this.position.y, identifier: event.button });
            };
            MouseDevice.prototype._handleMove = function (event) {
                this.convertPosition(event, this.position);
                if (this._buttons[event.button]) {
                    this.dispatchEvent({ type: "mousemove", x: this.position.x, y: this.position.y, identifier: event.button });
                }
            };
            MouseDevice.prototype._handleDown = function (event) {
                this._buttons[event.button] = true;
                this.convertPosition(event, this.position);
                this.dispatchEvent({ type: "mousedown", x: this.position.x, y: this.position.y, identifier: event.button });
            };
            MouseDevice.prototype._handleWheel = function (event) {
                if (event.detail) {
                    this.wheel = -1 * event.detail;
                }
                else if (event.wheelDelta) {
                    this.wheel = event.wheelDelta / 120;
                }
                else {
                    this.wheel = 0;
                }
            };
            return MouseDevice;
        }(egret3d.framework.EventDispatcher));
        input.MouseDevice = MouseDevice;
        __reflect(MouseDevice.prototype, "egret3d.input.MouseDevice");
    })(input = egret3d.input || (egret3d.input = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var input;
    (function (input) {
        var TouchPhase;
        (function (TouchPhase) {
            TouchPhase[TouchPhase["BEGAN"] = 0] = "BEGAN";
            TouchPhase[TouchPhase["MOVED"] = 1] = "MOVED";
            TouchPhase[TouchPhase["STATIONARY"] = 2] = "STATIONARY";
            TouchPhase[TouchPhase["ENDED"] = 3] = "ENDED";
            TouchPhase[TouchPhase["CANCELED"] = 4] = "CANCELED";
        })(TouchPhase = input.TouchPhase || (input.TouchPhase = {}));
        var TouchPoint = (function () {
            function TouchPoint() {
                this.altitudeAngle = Math.PI / 2;
                this.azimuthAngle = 0;
                this.deltaPosition = new egret3d.math.Vector2();
                this.fingerId = 0;
                this.maximumPossiblePressure = 1.0;
                this.position = new egret3d.math.Vector2();
                this.pressure = 1.0;
                this.radius = new egret3d.math.Vector2();
                this.type = "Direct";
            }
            TouchPoint.prototype.set = function (touch, phase, device) {
                this.altitudeAngle = touch.rotationAngle;
                this.azimuthAngle = touch.rotationAngle;
                if (phase == TouchPhase.BEGAN || phase == TouchPhase.STATIONARY) {
                    this.deltaPosition.x = 0;
                    this.deltaPosition.y = 0;
                }
                else {
                    device.convertPosition(touch, this.deltaPosition);
                    egret3d.math.vec2Subtract(this.deltaPosition, this.position, this.deltaPosition);
                }
                this.fingerId = touch.identifier;
                this.phase = phase;
                device.convertPosition(touch, this.position);
                this.pressure = touch.force;
                this.radius.x = touch.radiusX;
                this.radius.y = touch.radiusY;
            };
            TouchPoint.create = function () {
                return this._pointPool.pop() || new TouchPoint();
            };
            TouchPoint.release = function (touchPoint) {
                this._pointPool.push(touchPoint);
            };
            TouchPoint._pointPool = [];
            return TouchPoint;
        }());
        input.TouchPoint = TouchPoint;
        __reflect(TouchPoint.prototype, "egret3d.input.TouchPoint");
        var TouchDevice = (function (_super) {
            __extends(TouchDevice, _super);
            function TouchDevice(element, options) {
                if (options === void 0) { options = { preventDefault: true, stopPropagation: true }; }
                var _this = _super.call(this) || this;
                _this._offsetX = 0;
                _this._offsetY = 0;
                _this._scaler = 1;
                _this._touchesMap = {};
                _this._touches = [];
                _this.touchCount = 0;
                _this._startHandler = _this._handleTouchStart.bind(_this);
                _this._endHandler = _this._handleTouchEnd.bind(_this);
                _this._moveHandler = _this._handleTouchMove.bind(_this);
                _this._cancelHandler = _this._handleTouchCancel.bind(_this);
                _this._element = null;
                _this.attach(element);
                _this.preventDefault = options.preventDefault;
                _this.stopPropagation = options.stopPropagation;
                return _this;
            }
            TouchDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scaler) {
                this._offsetX = offsetX;
                this._offsetY = offsetY;
                this._scaler = scaler;
            };
            TouchDevice.prototype.convertPosition = function (e, out) {
                out.x = (e.clientX - this._offsetX) * this._scaler;
                out.y = (e.clientY - this._offsetY) * this._scaler;
            };
            TouchDevice.prototype.attach = function (element) {
                if (this._element) {
                    this.detach();
                }
                this._element = element;
                this._element.addEventListener('touchstart', this._startHandler, false);
                this._element.addEventListener('touchend', this._endHandler, false);
                this._element.addEventListener('touchmove', this._moveHandler, false);
                this._element.addEventListener('touchcancel', this._cancelHandler, false);
            };
            TouchDevice.prototype.detach = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener('touchstart', this._startHandler, false);
                this._element.removeEventListener('touchend', this._endHandler, false);
                this._element.removeEventListener('touchmove', this._moveHandler, false);
                this._element.removeEventListener('touchcancel', this._cancelHandler, false);
                this._element = null;
            };
            TouchDevice.prototype.update = function () {
                for (var i in this._touchesMap) {
                    var touch = this._touchesMap[i];
                    if (touch.phase === TouchPhase.BEGAN) {
                        touch.phase = TouchPhase.STATIONARY;
                    }
                    if (touch.phase === TouchPhase.MOVED) {
                        touch.phase = TouchPhase.STATIONARY;
                    }
                    if (touch.phase === TouchPhase.ENDED || touch.phase === TouchPhase.CANCELED) {
                        delete this._touchesMap[i];
                        var index = this._touches.indexOf(touch);
                        if (index > -1) {
                            this._touches.splice(index, 1);
                        }
                        this.touchCount--;
                    }
                }
            };
            TouchDevice.prototype.getTouch = function (index) {
                return this._touches[index];
            };
            TouchDevice.prototype._getTouch = function (identifier) {
                var touchPoint = this._touchesMap[identifier];
                if (!touchPoint) {
                    touchPoint = TouchPoint.create();
                    this._touchesMap[identifier] = touchPoint;
                    this._touches.push(touchPoint);
                    this.touchCount++;
                }
                return touchPoint;
            };
            TouchDevice.prototype._handleTouchStart = function (event) {
                if (event["isScroll"] != true && !this._element['userTyping']) {
                    event.preventDefault();
                }
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    var identifier = touch.identifier;
                    var touchPoint = this._getTouch(identifier);
                    touchPoint.set(touch, TouchPhase.BEGAN, this);
                    this.dispatchEvent({ type: "touchstart", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            TouchDevice.prototype._handleTouchEnd = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    var identifier = touch.identifier;
                    var touchPoint = this._getTouch(identifier);
                    touchPoint.set(touch, TouchPhase.ENDED, this);
                    this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            TouchDevice.prototype._handleTouchMove = function (event) {
                if (event["isScroll"] != true && !this._element['userTyping']) {
                    event.preventDefault();
                }
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    var identifier = touch.identifier;
                    var touchPoint = this._getTouch(identifier);
                    touchPoint.set(touch, TouchPhase.MOVED, this);
                    this.dispatchEvent({ type: "touchmove", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            TouchDevice.prototype._handleTouchCancel = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    var identifier = touch.identifier;
                    var touchPoint = this._getTouch(identifier);
                    touchPoint.set(touch, TouchPhase.CANCELED, this);
                    this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }
                if (this.stopPropagation) {
                    event.stopPropagation();
                }
            };
            return TouchDevice;
        }(egret3d.framework.EventDispatcher));
        input.TouchDevice = TouchDevice;
        __reflect(TouchDevice.prototype, "egret3d.input.TouchDevice");
    })(input = egret3d.input || (egret3d.input = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinBuffer = (function () {
            function BinBuffer(bufSize) {
                if (bufSize === void 0) { bufSize = 65536; }
                if (bufSize < 1024) {
                    bufSize = 1024;
                }
                if (bufSize > 1024 * 256) {
                    bufSize = 1024 * 256;
                }
                this._bufSize = bufSize;
                this._buf = [];
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._buf[0] = new Uint8Array(bufSize);
                this._seekReadPos = 0;
            }
            BinBuffer.prototype.getLength = function () {
                return (this._seekWriteIndex * this._bufSize + this._seekWritePos) - (this._seekReadPos);
            };
            BinBuffer.prototype.getBufLength = function () {
                return this._buf.length * this._bufSize;
            };
            BinBuffer.prototype.getBytesAvailable = function () {
                return this.getLength();
            };
            BinBuffer.prototype.reset = function () {
                this._buf = [];
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._buf[0] = new Uint8Array(this._bufSize);
                this._seekReadPos = 0;
            };
            BinBuffer.prototype.dispose = function () {
                this._buf.splice(0);
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._seekReadPos = 0;
            };
            BinBuffer.prototype.read = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = offset; i < offset + length; i++) {
                    if (this._seekReadPos >= this._seekWritePos && 0 == this._seekWriteIndex) {
                        this.reset();
                        throw new Error("no data to read.");
                    }
                    target[i] = this._buf[0][this._seekReadPos];
                    this._seekReadPos++;
                    if (this._seekReadPos >= this._bufSize) {
                        this._seekWriteIndex--;
                        this._seekReadPos = 0;
                        var freebuf = this._buf.shift();
                        this._buf.push(freebuf);
                    }
                }
            };
            BinBuffer.prototype.write = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                for (var i = offset; i < offset + length; i++) {
                    this._buf[this._seekWriteIndex][this._seekWritePos] = array[i];
                    this._seekWritePos++;
                    if (this._seekWritePos >= this._bufSize) {
                        this._seekWriteIndex++;
                        this._seekWritePos = 0;
                        if (this._buf.length <= this._seekWriteIndex) {
                            this._buf.push(new Uint8Array(this._bufSize));
                        }
                    }
                }
            };
            BinBuffer.prototype.getBuffer = function () {
                var length = 0;
                if (this._seekWriteIndex > 0) {
                    length = this._bufSize * (this._seekWriteIndex - 1) + this._seekWritePos;
                }
                else {
                    length = this._seekWritePos;
                }
                var array = new Uint8Array(length);
                for (var i = 0; i < this._seekWriteIndex - 1; i++) {
                    array.set(this._buf[i], i * this._bufSize);
                }
                for (var i = 0; i < this._seekWritePos; i++) {
                    array[length - this._seekWritePos + i] = this._buf[this._seekWriteIndex][i];
                }
                return array;
            };
            BinBuffer.prototype.getUint8Array = function () {
                return new Uint8Array(this.getBuffer());
            };
            return BinBuffer;
        }());
        io.BinBuffer = BinBuffer;
        __reflect(BinBuffer.prototype, "egret3d.io.BinBuffer");
        var Converter = (function () {
            function Converter() {
            }
            Converter.getApplyFun = function (value) {
                return Array.prototype.concat.apply([], value);
            };
            Converter.ULongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                Converter.dataView.setUint32(0, uint1, true);
                Converter.dataView.setUint32(4, uint2, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = new Uint8Array(Converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.LongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                Converter.dataView.setInt32(0, uint1, true);
                Converter.dataView.setInt32(4, uint2, true);
                var _array = new Int8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = new Int8Array(Converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Float64ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setFloat64(0, value, false);
                if (target == null) {
                    target = new Uint8Array(Converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = Converter.dataView.buffer[i];
                    }
                }
                return target;
            };
            Converter.Float32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setFloat32(0, value, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Int32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Int16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setInt16(0, value, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Int8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setInt8(0, value);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Uint32toArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Uint16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setUint16(0, value, true);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.Uint8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                Converter.dataView.setUint8(0, value);
                var _array = new Uint8Array(Converter.dataView.buffer);
                if (target == null) {
                    target = Converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            Converter.StringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            };
            Converter.ArrayToLong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    Converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n1 = Converter.dataView.getInt32(0, true);
                for (var i = 4; i < 8; i++) {
                    Converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n2 = Converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            Converter.ArrayToULong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n1 = Converter.dataView.getUint32(0, true);
                for (var i = 4; i < 8; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n2 = Converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            Converter.ArrayToFloat64 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 8; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getFloat64(0, true);
            };
            Converter.ArrayToFloat32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getFloat32(0, true);
            };
            Converter.ArrayToInt32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getInt32(0, true);
            };
            Converter.ArrayToInt16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getInt16(0, true);
            };
            Converter.ArrayToInt8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getInt8(0);
            };
            Converter.ArraytoUint32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getUint32(0, true);
            };
            Converter.ArrayToUint16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getUint16(0, true);
            };
            Converter.ArrayToUint8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    Converter.dataView.setUint8(i, buf[offset + i]);
                }
                return Converter.dataView.getUint8(0);
            };
            Converter.ArrayToString = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            };
            Converter.dataView = new DataView(new ArrayBuffer(8), 0, 8);
            return Converter;
        }());
        io.Converter = Converter;
        __reflect(Converter.prototype, "egret3d.io.Converter");
        var BinTool = (function (_super) {
            __extends(BinTool, _super);
            function BinTool() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            BinTool.prototype.readSingle = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return Converter.ArrayToFloat32(array);
            };
            BinTool.prototype.readLong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return Converter.ArrayToLong(array);
            };
            BinTool.prototype.readULong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return Converter.ArrayToULong(array);
            };
            BinTool.prototype.readDouble = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return Converter.ArrayToFloat64(array);
            };
            BinTool.prototype.readInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return Converter.ArrayToInt8(array);
            };
            BinTool.prototype.readUInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return Converter.ArrayToUint8(array);
            };
            BinTool.prototype.readInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return Converter.ArrayToInt16(array);
            };
            BinTool.prototype.readUInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return Converter.ArrayToUint16(array);
            };
            BinTool.prototype.readInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return Converter.ArrayToInt32(array);
            };
            BinTool.prototype.readUInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return Converter.ArraytoUint32(array);
            };
            BinTool.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinTool.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinTool.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinTool.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinTool.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinTool.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinTool.prototype.readShort = function () {
                return this.readInt16();
            };
            BinTool.prototype.readInt = function () {
                return this.readInt32();
            };
            BinTool.prototype.readBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return array;
            };
            BinTool.prototype.readStringUtf8 = function () {
                var length = this.readInt8();
                var array = new Uint8Array(length);
                this.read(array);
                return Converter.ArrayToString(array);
            };
            BinTool.prototype.readStringUtf8FixLength = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return Converter.ArrayToString(array);
            };
            BinTool.prototype.readUTFBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return Converter.ArrayToString(array);
            };
            BinTool.prototype.readStringAnsi = function () {
                var slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            };
            Object.defineProperty(BinTool.prototype, "length", {
                get: function () {
                    return this.getLength();
                },
                enumerable: true,
                configurable: true
            });
            BinTool.prototype.writeInt8 = function (num) {
                this.write(Converter.Int8ToArray(num));
            };
            BinTool.prototype.writeUInt8 = function (num) {
                this.write(Converter.Uint8ToArray(num));
            };
            BinTool.prototype.writeInt16 = function (num) {
                this.write(Converter.Int16ToArray(num));
            };
            BinTool.prototype.writeUInt16 = function (num) {
                this.write(Converter.Uint16ToArray(num));
            };
            BinTool.prototype.writeInt32 = function (num) {
                this.write(Converter.Int32ToArray(num));
            };
            BinTool.prototype.writeUInt32 = function (num) {
                this.write(Converter.Uint32toArray(num));
            };
            BinTool.prototype.writeSingle = function (num) {
                this.write(Converter.Float32ToArray(num));
            };
            BinTool.prototype.writeLong = function (num) {
                this.write(Converter.LongToArray(num));
            };
            BinTool.prototype.writeULong = function (num) {
                this.write(Converter.ULongToArray(num));
            };
            BinTool.prototype.writeDouble = function (num) {
                this.write(Converter.Float64ToArray(num));
            };
            BinTool.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++) {
                    this.writeUInt8(str.charCodeAt(i));
                }
            };
            BinTool.prototype.writeStringUtf8 = function (str) {
                var bstr = Converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            };
            BinTool.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = Converter.StringToUtf8Array(str);
                this.write(bstr);
            };
            BinTool.prototype.writeByte = function (num) {
                this.write(Converter.Uint8ToArray(num));
            };
            BinTool.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            BinTool.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            BinTool.prototype.writeUnsignedShort = function (num) {
                this.write(Converter.Uint16ToArray(num));
            };
            BinTool.prototype.writeUnsignedInt = function (num) {
                this.write(Converter.Uint32toArray(num));
            };
            BinTool.prototype.writeFloat = function (num) {
                this.write(Converter.Float32ToArray(num));
            };
            BinTool.prototype.writeUTFBytes = function (str) {
                this.write(Converter.StringToUtf8Array(str));
            };
            BinTool.prototype.writeSymbolByte = function (num) {
                this.write(Converter.Int8ToArray(num));
            };
            BinTool.prototype.writeShort = function (num) {
                this.write(Converter.Int16ToArray(num));
            };
            BinTool.prototype.writeInt = function (num) {
                this.write(Converter.Int32ToArray(num));
            };
            return BinTool;
        }(BinBuffer));
        io.BinTool = BinTool;
        __reflect(BinTool.prototype, "egret3d.io.BinTool");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        function cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            io.ReferenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.ReferenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        function fillCloneReference(instanceObj, clonedObj) {
            var _flag = egret3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = egret3d.reflect.getClassName(instanceObj);
            }
            if (_type == "Transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "Transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & egret3d.framework.HideFlags.DontSaveInBuild) || (_flag & egret3d.framework.HideFlags.DontSaveInEditor) || (_flag & egret3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                }
            }
        }
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    var instance = void 0;
                    if ((isArray && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.ReferenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.ReferenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "Transform" || type == "Transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.ReferenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        fillCloneReference(instanceObj[key], clonedObj[key]);
                    }
                }
            }
        }
        function _cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            var _flag = egret3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = egret3d.reflect.getClassName(instanceObj);
            }
            if (_type == "Transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "Transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & egret3d.framework.HideFlags.DontSaveInBuild) || (_flag & egret3d.framework.HideFlags.DontSaveInEditor) || (_flag & egret3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (clonedObj == undefined) {
                var insid = -1;
                clonedObj = egret3d.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "Transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "Transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.ReferenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray = instanceObj[key] instanceof Array;
                    if (isArray) {
                        clonedObj[key] = [];
                    }
                    else {
                        clonedObj[key] = {};
                    }
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (field);
                                switch (baseType) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    if (isArray) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    var isreference = false;
                    if ((isArray && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "Transform" || type == "Transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray) {
                        }
                        else {
                        }
                    }
                    else {
                        var _clonedObj = void 0;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray) {
                                if (type == "NodeComponent" && instanceKey == "components" && egret3d.reflect.getClassName(instanceParent) == "GameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "Transform" && instanceKey == "children" && egret3d.reflect.getClassName(instanceParent) == "Transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && egret3d.reflect.getClassName(instanceParent) == "Transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "Transform2D" && instanceKey == "children" && egret3d.reflect.getClassName(instanceParent) == "Transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                    }
                }
            }
        }
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var SerializeDependent = (function () {
            function SerializeDependent() {
            }
            SerializeDependent.GetAssetUrl = function (asset) {
                if (!asset)
                    return;
                var url = asset.url;
                if (!url)
                    return;
                SerializeDependent.resoursePaths.push(url);
                if (asset instanceof egret3d.framework.Material) {
                    var _mapUniform = asset.mapUniform;
                    if (!_mapUniform)
                        return;
                    for (var newKey in _mapUniform) {
                        if (!_mapUniform[newKey])
                            continue;
                        if (_mapUniform[newKey].type != egret3d.render.UniformTypeEnum.Texture)
                            continue;
                        var _texture = _mapUniform[newKey].value;
                        if (!_texture)
                            continue;
                        url = _texture.url;
                        if (!url)
                            continue;
                        SerializeDependent.resoursePaths.push(url);
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resoursePaths.push(url);
                    }
                }
            };
            SerializeDependent.resoursePaths = [];
            return SerializeDependent;
        }());
        io.SerializeDependent = SerializeDependent;
        __reflect(SerializeDependent.prototype, "egret3d.io.SerializeDependent");
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        function serializeObjForInspector(instanceObj, beComponent, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = egret3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = egret3d.reflect.getClassName(instanceObj);
            }
            if (_type == "Transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "Transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & egret3d.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (var key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new InspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_1 = instanceObj[key] instanceof Array;
                    if (isArray_1) {
                        serializedObj[key] = new InspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    }
                    else {
                        serializedObj[key] = new InspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    }
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new InspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_1) {
                                            serializedObj[key]["value"].push(info);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var isArray_2 = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"][key]) {
                    if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) {
                        var custom = instanceObj["__gdmeta__"][key]["custom"];
                        var info = new InspectorValueInfo(null, custom["valueType"]);
                        if (custom["FieldUIStyle"])
                            info.UIStyle = custom["FieldUIStyle"];
                        if (custom["defvalue"])
                            info.defvalue = custom;
                        if (custom["min"])
                            info.min = custom["min"];
                        if (custom["max"])
                            info.max = custom["max"];
                        if (isArray_2) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
            }
        }
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_3 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new InspectorValueInfo(_assetName, type);
                        if (isArray_3) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_3 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_3 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "Transform" || type == "Transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!ReferenceInfo.isRegType(type)) {
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new InspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            var custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray_3) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!ReferenceInfo.isRegType(type) && beComponent)
                            return;
                        var _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new InspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                var custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray_3) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        function Serialize(obj) {
            return JSON.stringify(serializeObj(obj, null));
        }
        io.Serialize = Serialize;
        function serializeObj(instanceObj, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = egret3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = egret3d.reflect.getClassName(instanceObj);
            }
            if (_type == "Transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "Transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & egret3d.framework.HideFlags.DontSaveInBuild) || (_flag & egret3d.framework.HideFlags.DontSaveInEditor) || (_flag & egret3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new ValueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new ValueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_4 = instanceObj[key] instanceof Array;
                    if (isArray_4) {
                        serializedObj[key] = new ValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    }
                    else {
                        serializedObj[key] = new ValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    }
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new ValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_4) {
                                            serializedObj[key]["value"].push(info);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_5 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            SerializeDependent.GetAssetUrl(instanceObj[key]);
                        }
                        if (isArray_5) {
                            serializedObj.push(new ValueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new ValueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_5 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_5 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "Transform" || type == "Transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_5) {
                            serializedObj.push(new ValueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new ValueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        var _serializeObj = serializeObj(instanceObj[key], serializedObj[key]);
                        if (_serializeObj != null) {
                            if (isArray_5) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        function deSerialize(serializedObj, instanceObj, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            ReferenceInfo.oldmap = {};
            deSerializeObj(serializedObj["value"], instanceObj, bundlename);
            ReferenceInfo.oldmap[serializedObj["insid"]] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        function fillReference(serializedObj, instanceObj) {
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type)) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray) {
                            instanceObj[key] = [];
                        }
                        else {
                            instanceObj[key] = {};
                        }
                    }
                    var arrayObj = null;
                    if (instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("de serialize fail，type not match：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        function dofillReference(serializedObj, instanceObj, key) {
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    var instance = ReferenceInfo.oldmap[serializedObj[key].value];
                    if (type == "Transform" || type == "Transform2D") {
                    }
                    else {
                        if (instance instanceof egret3d.framework.Transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof egret3d.framework.Transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        function deSerializeObj(serializedObj, instanceObj, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (instanceObj == undefined) {
                throw new Error("need a instanceObj");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, bundlename);
                        break;
                }
            }
        }
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type)) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray) {
                            instanceObj[key] = [];
                        }
                        else {
                            instanceObj[key] = {};
                        }
                    }
                    var arrayObj = null;
                    if (instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("de serialize fail，type not match：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key][newkey].type) {
                                    throw new Error("de serialize fail，type not match：" + baseType + " as " + serializedObj[key].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "NodeComponent" && key == "components" && egret3d.reflect.getClassName(instanceObj) == "GameObject") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "Transform" && key == "children" && egret3d.reflect.getClassName(instanceObj) == "Transform") {
                                    var _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && egret3d.reflect.getClassName(instanceObj) == "Transform2D") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "Transform2D" && key == "children" && egret3d.reflect.getClassName(instanceObj) == "Transform2D") {
                                    var _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, bundlename);
                }
            }
        }
        function deSerializeOtherType(serializedObj, instanceObj, key, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                var assetName = serializedObj[key].value;
                var _asset = void 0;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "Mesh") {
                        _asset = egret3d.framework.AssetMap.find(assetName);
                    }
                    else if (type == "Texture") {
                        _asset = egret3d.framework.AssetMap.find(assetName);
                    }
                }
                else {
                    _asset = egret3d.framework.AssetMap.find(assetName, bundlename);
                }
                if (instanceObj instanceof Array) {
                    instanceObj.push(_asset);
                }
                else {
                    instanceObj[key] = _asset;
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    var _newInstance = void 0;
                    if (type == "GameObject" && key == "gameObject" && egret3d.reflect.getClassName(instanceObj) == "Transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "Transform2D" && key == "rootNode" && egret3d.reflect.getClassName(instanceObj) == "Canvas") {
                        _newInstance = egret3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = egret3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        if (_isArray) {
                            instanceObj.push(_newInstance);
                        }
                        else {
                            instanceObj[key] = _newInstance;
                        }
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, bundlename);
                    ReferenceInfo.oldmap[serializedObj[key].insid] = _newInstance;
                }
            }
        }
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        function isAsset(type) {
            if (type == "Mesh" || type == "Texture" || type == "Shader" ||
                type == "Material" || type == "AnimationClip" || type == "Atlas" ||
                type == "Font" || type == "Prefab" || type == "Sprite" || type == "Textasset")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        function isAssetInspector(type) {
            if (type == "Prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        var ValueInfo = (function () {
            function ValueInfo(value, type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = value;
                this.type = type;
                if (isAsset(type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return ValueInfo;
        }());
        __reflect(ValueInfo.prototype, "ValueInfo");
        var InspectorValueInfo = (function () {
            function InspectorValueInfo(_value, _type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return InspectorValueInfo;
        }());
        __reflect(InspectorValueInfo.prototype, "InspectorValueInfo");
        var ReferenceInfo = (function () {
            function ReferenceInfo() {
            }
            ReferenceInfo.regDefaultType = function () {
                ReferenceInfo.regType("Vector3");
                ReferenceInfo.regType("Vector4");
                ReferenceInfo.regType("Color");
                ReferenceInfo.regType("Quaternion");
                ReferenceInfo.regType("Material");
                ReferenceInfo.regType("GameObject");
                ReferenceInfo.regType("Transform2D");
                ReferenceInfo.regType("Shader");
                ReferenceInfo.regType("Atlas");
                ReferenceInfo.regType("Font");
                ReferenceInfo.regType("Sprite");
                ReferenceInfo.regType("Texture");
                ReferenceInfo.regType("Mesh");
                ReferenceInfo.regType("Animationclip");
                ReferenceInfo.regType("ConstText");
                ReferenceInfo.regType("UniformData");
            };
            ReferenceInfo.regType = function (type) {
                ReferenceInfo.regtypelist.push(type);
            };
            ReferenceInfo.isRegType = function (type) {
                return this.regtypelist.indexOf(type) >= 0;
            };
            ReferenceInfo.oldmap = {};
            ReferenceInfo.regtypelist = [];
            return ReferenceInfo;
        }());
        io.ReferenceInfo = ReferenceInfo;
        __reflect(ReferenceInfo.prototype, "egret3d.io.ReferenceInfo");
        var EnumMgr = (function () {
            function EnumMgr() {
            }
            EnumMgr.enumMap = {};
            return EnumMgr;
        }());
        io.EnumMgr = EnumMgr;
        __reflect(EnumMgr.prototype, "egret3d.io.EnumMgr");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.a = src.a;
            out.r = src.r;
            out.g = src.g;
            out.b = src.b;
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
            out.a = Math.floor(out.a);
            out.r = Math.floor(out.r);
            out.g = Math.floor(out.g);
            out.b = Math.floor(out.b);
        }
        math.colorLerp = colorLerp;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new egret3d.math.Matrix();
            var dir1;
            if (index == 1) {
                dir1 = new egret3d.math.Vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new egret3d.math.Vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new egret3d.math.Vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new egret3d.math.Vector3();
            egret3d.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            egret3d.math.matrixInverse(matrix, matrix);
            var outnode = new egret3d.math.Vector3();
            egret3d.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new egret3d.math.Vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new egret3d.math.Vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new egret3d.math.Vector3(0, 0, outnode.z);
            }
        }
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.x = src.rawData[12];
            out.y = src.rawData[13];
            out.z = src.rawData[14];
        }
        math.matrixGetTranslation = matrixGetTranslation;
        function matrixTranspose(src, out) {
            out.rawData[1] = src.rawData[4];
            out.rawData[2] = src.rawData[8];
            out.rawData[3] = src.rawData[12];
            out.rawData[4] = src.rawData[1];
            out.rawData[6] = src.rawData[9];
            out.rawData[7] = src.rawData[13];
            out.rawData[8] = src.rawData[2];
            out.rawData[9] = src.rawData[6];
            out.rawData[11] = src.rawData[14];
            out.rawData[12] = src.rawData[3];
            out.rawData[13] = src.rawData[7];
            out.rawData[14] = src.rawData[11];
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.x = src.rawData[12];
            translation.y = src.rawData[13];
            translation.z = src.rawData[14];
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.Pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        var Angelref = (function () {
            function Angelref() {
            }
            return Angelref;
        }());
        math.Angelref = Angelref;
        __reflect(Angelref.prototype, "egret3d.math.Angelref");
        function matrix3x2Decompose(src, scale, rotation, translation) {
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            var xs = math.sign(src.rawData[0] * src.rawData[1]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = ys * Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var csx = src.rawData[1] / scale.x;
            var r1 = Math.asin(sx);
            var r2 = Math.acos(csx);
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function matrixClone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = egret3d.math.Pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = egret3d.math.Pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            egret3d.math.Pool.delete_matrix(matS);
            egret3d.math.Pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = egret3d.math.Pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = egret3d.math.Pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            egret3d.math.Pool.delete_matrix3x2(matS);
            egret3d.math.Pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            scale.x = src.rawData[0];
            scale.y = src.rawData[5];
            scale.z = src.rawData[10];
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            out.rawData[0] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            out.rawData[2] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[3] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            out.rawData[4] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b3 * a31;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 1.0 / (zfar - znear);
            var nid = znear / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        function matrixLookatLH(forward, up, out) {
            var z = new math.Vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y1 = new math.Vector3();
            math.vec3Clone(up, y1);
            math.vec3Normalize(y1, y1);
            var x = new math.Vector3();
            math.vec3Cross(y1, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.Vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            var z = new math.Vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y1 = new math.Vector3();
            math.vec3Clone(up, y1);
            math.vec3Normalize(y1, y1);
            var x = new math.Vector3();
            math.vec3Cross(y1, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.Vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.x = x;
            result.y = y;
            result.z = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function floatClamp(v, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 1; }
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value;
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return CommonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return CommonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return CommonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        var CommonStatic = (function () {
            function CommonStatic() {
            }
            CommonStatic.x_axis = new egret3d.math.Vector3(1, 0, 0);
            CommonStatic.y_axis = new egret3d.math.Vector3(0, 1, 0);
            CommonStatic.z_axis = new egret3d.math.Vector3(0, 0, 1);
            return CommonStatic;
        }());
        math.CommonStatic = CommonStatic;
        __reflect(CommonStatic.prototype, "egret3d.math.CommonStatic");
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.x = src.x;
            out.y = src.y;
            out.z = src.z;
            out.w = src.w;
        }
        math.quatClone = quatClone;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, out) {
            var temp = 2.0 * (src.w * src.x - src.y * src.z);
            temp = math.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (src.w * src.y + src.z * src.x), 1.0 - 2.0 * (src.y * src.y + src.x * src.x));
            out.z = Math.atan2(2.0 * (src.w * src.z + src.y * src.x), 1.0 - 2.0 * (src.x * src.x + src.z * src.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        function quatLookat(pos, targetpos, out) {
            var dir = new math.Vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.Vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = new math.Vector3(dir.x, 0, dir.z);
            var v3length = math.vec3Length(dirxz1);
            if (v3length > 0.9999999999) {
                v3length = 1;
            }
            if (v3length < -0.999999999) {
                v3length = -1;
            }
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out, updir) {
            if (updir === void 0) { updir = egret3d.math.Pool.vector3_up; }
            var dir = egret3d.math.Pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = egret3d.math.vec3Dot(egret3d.math.Pool.vector3_forward, dir);
            dot = egret3d.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot) * 180 / Math.PI;
            if (rotangle < 0.01) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return;
            }
            if (rotangle > 179.9) {
                egret3d.math.quatFromAxisAngle(updir, 180, out);
                return;
            }
            var rotAxis = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3Cross(egret3d.math.Pool.vector3_forward, dir, rotAxis);
            egret3d.math.vec3Normalize(rotAxis, rotAxis);
            egret3d.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quatYAxis(pos, targetpos, out) {
            var dir = new math.Vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.Vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatYAxis = quatYAxis;
        function setQuatFromMat4(matrix, out) {
            var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;
            var m = matrix.rawData;
            m00 = m[0];
            m01 = m[1];
            m02 = m[2];
            m10 = m[4];
            m11 = m[5];
            m12 = m[6];
            m20 = m[8];
            m21 = m[9];
            m22 = m[10];
            lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
            ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
            lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
            m00 *= lx;
            m01 *= lx;
            m02 *= lx;
            m10 *= ly;
            m11 *= ly;
            m12 *= ly;
            m20 *= lz;
            m21 *= lz;
            m22 *= lz;
            tr = m00 + m11 + m22;
            if (tr >= 0) {
                s = Math.sqrt(tr + 1);
                out.w = s * 0.5;
                s = 0.5 / s;
                out.x = (m12 - m21) * s;
                out.y = (m20 - m02) * s;
                out.z = (m01 - m10) * s;
            }
            else {
                if (m00 > m11) {
                    if (m00 > m22) {
                        rs = (m00 - (m11 + m22)) + 1;
                        rs = Math.sqrt(rs);
                        out.x = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m12 - m21) * rs;
                        out.y = (m01 + m10) * rs;
                        out.z = (m02 + m20) * rs;
                    }
                    else {
                        rs = (m22 - (m00 + m11)) + 1;
                        rs = Math.sqrt(rs);
                        out.z = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m01 - m10) * rs;
                        out.x = (m20 + m02) * rs;
                        out.y = (m21 + m12) * rs;
                    }
                }
                else if (m11 > m22) {
                    rs = (m11 - (m22 + m00)) + 1;
                    rs = Math.sqrt(rs);
                    out.y = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m20 - m02) * rs;
                    out.z = (m12 + m21) * rs;
                    out.x = (m10 + m01) * rs;
                }
                else {
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);
                    out.z = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m01 - m10) * rs;
                    out.x = (m20 + m02) * rs;
                    out.y = (m21 + m12) * rs;
                }
            }
        }
        math.setQuatFromMat4 = setQuatFromMat4;
        var helpVec3_1 = new math.Vector3();
        function setEulerAnglesFromMat4(matrix, out) {
            var x, y, z, sx, sy, sz, m, halfPi;
            var scale = helpVec3_1;
            math.matrixGetScale(matrix, scale);
            sx = scale.x;
            sy = scale.y;
            sz = scale.z;
            m = this.data;
            y = Math.asin(-m[2] / sx);
            halfPi = Math.PI * 0.5;
            if (y < halfPi) {
                if (y > -halfPi) {
                    x = Math.atan2(m[6] / sy, m[10] / sz);
                    z = Math.atan2(m[1] / sx, m[0] / sx);
                }
                else {
                    z = 0;
                    x = -Math.atan2(m[4] / sy, m[5] / sy);
                }
            }
            else {
                z = 0;
                x = Math.atan2(m[4] / sy, m[5] / sy);
            }
            out.x = x * 180 / Math.PI;
            out.y = y * 180 / Math.PI;
            out.z = z * 180 / Math.PI;
        }
        math.setEulerAnglesFromMat4 = setEulerAnglesFromMat4;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            var total = 0;
            for (var i = 0; i < value.length; i++) {
                var charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function spriteAnimation(row, column, index, out) {
            var width = 1 / column;
            var height = 1 / row;
            var offsetx = width * (index % column);
            var offsety = height * Math.floor(index / column);
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
        }
        math.spriteAnimation = spriteAnimation;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
            if (crease === void 0) { crease = 0.3; }
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = egret3d.math.Pool.new_vector3();
            egret3d.math.vec3Add(tempt1, tempt2, tempt5);
            egret3d.math.vec3Add(tempt5, tempt3, tempt5);
            egret3d.math.vec3Add(tempt5, tempt4, tempt5);
            egret3d.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            egret3d.math.Pool.delete_vector3(tempt1);
            egret3d.math.Pool.delete_vector3(tempt2);
            egret3d.math.Pool.delete_vector3(tempt3);
            egret3d.math.Pool.delete_vector3(tempt4);
            egret3d.math.Pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.Pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.Pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec4Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
            to.w = from.w;
        }
        math.vec4Clone = vec4Clone;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        function vec3Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
        }
        math.vec3Clone = vec3Clone;
        function vec3ToString(result) {
            result = this.x + "," + this.y + "," + this.z;
        }
        math.vec3ToString = vec3ToString;
        function vec3Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.x = -a.x;
            out.y = -a.y;
            out.z = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(value) {
            value.x = value.y = value.z = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(value) {
            value.x = value.y = 0;
            value.z = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(value) {
            value.x = value.y = 0;
            value.z = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(value) {
            value.x = value.z = 0;
            value.y = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(value) {
            value.x = value.z = 0;
            value.y = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(value) {
            value.x = -1;
            value.y = value.z = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(value) {
            value.x = 1;
            value.y = value.z = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.x = value.x / num;
                out.y = value.y / num;
                out.z = value.z / num;
            }
            else {
                out.x = 0;
                out.y = 0;
                out.z = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
            out.z = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
        }
        math.vec3Cross = vec3Cross;
        function vec3Reflect(inDirection, inNormal, out) {
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                out.x = out.y = out.z = 0;
            }
            else {
                var num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.Pool.new_vector3();
            var out2 = math.Pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.Pool.delete_vector3(out1);
            math.Pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.Pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.Pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            var val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            out = vector;
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(lhs, rhs, out) {
            out.x = Math.min(lhs.x, rhs.x);
            out.y = Math.min(lhs.y, rhs.y);
            out.z = Math.min(lhs.z, rhs.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(lhs, rhs, out) {
            out.x = Math.max(lhs.x, rhs.x);
            out.y = Math.max(lhs.y, rhs.y);
            out.z = Math.max(lhs.z, rhs.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(val) {
            val.x = 0;
            val.y = 0;
            val.z = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
            out.w = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        function vec3Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EffectSystemData = (function () {
            function EffectSystemData() {
                this.beLoop = false;
                this.elements = [];
            }
            EffectSystemData.prototype.clone = function () {
                var data = new EffectSystemData();
                data.life = this.life;
                data.beLoop = this.beLoop;
                for (var key in this.elements) {
                    data.elements[key] = this.elements[key].clone();
                }
                return data;
            };
            EffectSystemData.prototype.dispose = function () {
                for (var key in this.elements) {
                    this.elements[key].dispose();
                }
                this.elements.length = 0;
            };
            return EffectSystemData;
        }());
        framework.EffectSystemData = EffectSystemData;
        __reflect(EffectSystemData.prototype, "egret3d.framework.EffectSystemData");
        var EffectElement = (function () {
            function EffectElement(_data, scene) {
                this.scene = scene;
                this.startIndex = 0;
                this.actionActive = false;
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.initActions();
                this.recordElementLerpAttributes();
            }
            EffectElement.prototype.recordElementLerpAttributes = function () {
                if (this.data.timelineFrame != undefined) {
                    for (var i in this.data.timelineFrame) {
                        var frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1) {
                            if (frameData.lerpDatas != undefined && frameData.lerpDatas.length != 0) {
                                this.recordLerpValues(frameData);
                            }
                            else if (frameData.attrsData != undefined) {
                                if (this.timelineFrame[frameData.frameIndex] == undefined) {
                                    this.timelineFrame[frameData.frameIndex] = new EffectFrameData();
                                    this.timelineFrame[frameData.frameIndex].attrsData = new EffectAttrsData();
                                    this.timelineFrame[frameData.frameIndex].frameIndex = frameData.frameIndex;
                                }
                                for (var k in frameData.attrsData) {
                                    this.timelineFrame[frameData.frameIndex].attrsData.setLerpAttribute(k, frameData.attrsData.getAttribute(k));
                                }
                            }
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerpValues = function (effectFrameData) {
                for (var i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        for (var key in effectFrameData.lerpDatas[i].attrsList) {
                            var attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerp = function (effectFrameData, lerpData, key) {
                var fromFrame = lerpData.fromFrame;
                var toFrame = lerpData.toFrame.getValue();
                var toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                var fromVal = effectFrameData.attrsData.getAttribute(key);
                for (var i = fromFrame + 1; i <= toFrame; i++) {
                    var outVal = void 0;
                    if (fromVal instanceof egret3d.math.Vector3) {
                        outVal = new egret3d.math.Vector3();
                        egret3d.math.vec3SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof egret3d.math.Vector2) {
                        outVal = new egret3d.math.Vector2();
                        egret3d.math.vec2SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = egret3d.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    var newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            };
            EffectElement.prototype.initActions = function () {
                this.actions = [];
                var action;
                for (var key in this.data.actionData) {
                    var actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(this.scene, actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            };
            EffectElement.prototype.update = function () {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        egret3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    egret3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.updateElementRotation = function () {
                var scene = this.scene;
                var cameraTransform = scene.mainCamera.gameObject.transform;
                var worldRotation = egret3d.math.Pool.new_quaternion();
                var localRotation = egret3d.math.Pool.new_quaternion();
                if (this.curAttrData.renderModel != RenderModel.None) {
                    var invTransformRotation = egret3d.math.Pool.new_quaternion();
                    var worldTranslation = egret3d.math.Pool.new_vector3();
                    var translation = egret3d.math.Pool.new_vector3();
                    egret3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        egret3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == RenderModel.BillBoard) {
                        egret3d.math.quatLookat(worldTranslation, cameraTransform.getPosition(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.VerticalBillBoard) {
                        var forwardTarget = egret3d.math.Pool.new_vector3();
                        egret3d.math.vec3Clone(cameraTransform.getPosition(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        egret3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        egret3d.math.Pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.StretchedBillBoard) {
                        egret3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        egret3d.math.quatLookat(worldTranslation, cameraTransform.getPosition(), worldRotation);
                        var lookRot = new egret3d.math.Quaternion();
                        egret3d.math.quatClone(this.transform.getRotation(), invTransformRotation);
                        egret3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        egret3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = egret3d.math.Pool.new_quaternion();
                        egret3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        egret3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = egret3d.math.Pool.new_vector3();
                        egret3d.math.quatToEulerAngles(lookRot, angle);
                        egret3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        egret3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        egret3d.math.Pool.delete_quaternion(inverRot);
                        egret3d.math.Pool.delete_vector3(angle);
                        egret3d.math.Pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getPosition(), worldRotation);
                    }
                    egret3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    egret3d.math.quatClone(this.transform.gameObject.transform.getRotation(), invTransformRotation);
                    egret3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    egret3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    egret3d.math.Pool.delete_vector3(translation);
                    egret3d.math.Pool.delete_vector3(worldTranslation);
                    egret3d.math.Pool.delete_quaternion(invTransformRotation);
                }
                else {
                    egret3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                egret3d.math.Pool.delete_quaternion(localRotation);
                egret3d.math.Pool.delete_quaternion(worldRotation);
            };
            EffectElement.prototype.isActiveFrame = function (frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            };
            EffectElement.prototype.setActive = function (_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.dispose = function () {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            };
            return EffectElement;
        }());
        framework.EffectElement = EffectElement;
        __reflect(EffectElement.prototype, "egret3d.framework.EffectElement");
        var EffectElementData = (function () {
            function EffectElementData() {
            }
            EffectElementData.prototype.clone = function () {
                var elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.ref = this.ref;
                elementdata.beloop = this.beloop;
                elementdata.actionData = [];
                elementdata.timelineFrame = [];
                if (this.initFrameData) {
                    elementdata.initFrameData = this.initFrameData.clone();
                }
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (var key in this.timelineFrame) {
                    if (this.timelineFrame[key]) {
                        elementdata.timelineFrame[key] = this.timelineFrame[key].clone();
                    }
                }
                for (var key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            };
            EffectElementData.prototype.dispose = function () {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (var key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            };
            return EffectElementData;
        }());
        framework.EffectElementData = EffectElementData;
        __reflect(EffectElementData.prototype, "egret3d.framework.EffectElementData");
        var EffectAttrsData = (function () {
            function EffectAttrsData() {
                this.renderModel = RenderModel.None;
                this.matrix = new egret3d.math.Matrix();
                this.rotationByEuler = new egret3d.math.Quaternion();
                this.localRotation = new egret3d.math.Quaternion();
            }
            EffectAttrsData.prototype.setLerpAttribute = function (attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        break;
                }
            };
            EffectAttrsData.prototype.getAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        return egret3d.math.Pool.clone_vector3(this.pos);
                    case "scale":
                        return egret3d.math.Pool.clone_vector3(this.scale);
                    case "euler":
                        return egret3d.math.Pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return egret3d.math.Pool.clone_vector3(this.color);
                    case "tilling":
                        return egret3d.math.Pool.clone_vector2(this.tilling);
                    case "uv":
                        return egret3d.math.Pool.clone_vector2(this.uv);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return egret3d.math.Pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return egret3d.math.Pool.clone_quaternion(this.localRotation);
                    case "matrix":
                        return egret3d.math.Pool.clone_matrix(this.matrix);
                    case "colorRate":
                        return this.colorRate;
                }
            };
            EffectAttrsData.prototype.initAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new egret3d.math.Vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new egret3d.math.Vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new egret3d.math.Vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new egret3d.math.Vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new egret3d.math.Vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new egret3d.math.Vector2(1, 1);
                        break;
                    case "colorRate":
                        this.colorRate = 1;
                        break;
                    default:
                        console.log("不支持的属性：" + attribute);
                        break;
                }
            };
            EffectAttrsData.prototype.resetMatrix = function () {
                egret3d.math.matrixZero(this.matrix);
            };
            EffectAttrsData.prototype.copyandinit = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = egret3d.math.Pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = egret3d.math.Pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = egret3d.math.Pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = egret3d.math.Pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.uv != undefined)
                    data.uv = egret3d.math.Pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.tilling != undefined)
                    data.tilling = egret3d.math.Pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                else
                    data.initAttribute("colorRate");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = egret3d.math.Pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = egret3d.math.Pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            EffectAttrsData.prototype.clone = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = egret3d.math.Pool.clone_vector3(this.pos);
                if (this.euler != undefined)
                    data.euler = egret3d.math.Pool.clone_vector3(this.euler);
                if (this.color != undefined)
                    data.color = egret3d.math.Pool.clone_vector3(this.color);
                if (this.scale != undefined)
                    data.scale = egret3d.math.Pool.clone_vector3(this.scale);
                if (this.tilling != undefined)
                    data.tilling = egret3d.math.Pool.clone_vector2(this.tilling);
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                if (this.uv != undefined)
                    data.uv = egret3d.math.Pool.clone_vector2(this.uv);
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = egret3d.math.Pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = egret3d.math.Pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            return EffectAttrsData;
        }());
        framework.EffectAttrsData = EffectAttrsData;
        __reflect(EffectAttrsData.prototype, "egret3d.framework.EffectAttrsData");
        var EffectFrameData = (function () {
            function EffectFrameData() {
            }
            EffectFrameData.prototype.clone = function () {
                var framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                framedata.lerpDatas = [];
                for (var key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            };
            EffectFrameData.prototype.dispose = function () {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            };
            return EffectFrameData;
        }());
        framework.EffectFrameData = EffectFrameData;
        __reflect(EffectFrameData.prototype, "egret3d.framework.EffectFrameData");
        var EffectLerpData = (function () {
            function EffectLerpData() {
                this.attrsList = [];
            }
            EffectLerpData.prototype.clone = function () {
                var lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (var key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            };
            return EffectLerpData;
        }());
        framework.EffectLerpData = EffectLerpData;
        __reflect(EffectLerpData.prototype, "egret3d.framework.EffectLerpData");
        var EffectActionData = (function () {
            function EffectActionData() {
            }
            EffectActionData.prototype.clone = function () {
                var actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                actiondata.params = [];
                for (var key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            };
            return EffectActionData;
        }());
        framework.EffectActionData = EffectActionData;
        __reflect(EffectActionData.prototype, "egret3d.framework.EffectActionData");
        var EffectMatData = (function () {
            function EffectMatData() {
            }
            EffectMatData.beEqual = function (data0, data1) {
                return data0.alphaCut == data1.alphaCut && data0.diffuseTexture == data1.diffuseTexture && data0.shader == data1.shader;
            };
            EffectMatData.prototype.clone = function () {
                var data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaCut = this.alphaCut;
                return data;
            };
            return EffectMatData;
        }());
        framework.EffectMatData = EffectMatData;
        __reflect(EffectMatData.prototype, "egret3d.framework.EffectMatData");
        var EffectBatcher = (function () {
            function EffectBatcher(formate) {
                this.beBufferInited = false;
                this.effectElements = [];
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.vertexSize = 0;
                this.vertexSize = egret3d.render.MeshData.calcByteSize(formate) / 4;
            }
            Object.defineProperty(EffectBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EffectBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EffectBatcher.prototype.dispose = function () {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (var key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            };
            return EffectBatcher;
        }());
        framework.EffectBatcher = EffectBatcher;
        __reflect(EffectBatcher.prototype, "egret3d.framework.EffectBatcher");
        var EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        var EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType";
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        var EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear";
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
        var RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        var EmissionData = (function () {
            function EmissionData() {
                this.type = ParticleEmissionType.burst;
            }
            return EmissionData;
        }());
        framework.EmissionData = EmissionData;
        __reflect(EmissionData.prototype, "egret3d.framework.EmissionData");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Emission = (function () {
            function Emission() {
                this.beLoop = false;
                this.paricleLoop = false;
                this.singleMeshLoop = false;
                this.renderModel = framework.RenderModel.None;
                this.particleStartData = new egret3d.framework.ParticleStartData();
            }
            Emission.prototype.getVboData = function (vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            };
            Emission.prototype.clone = function () {
                var emission = new Emission();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                if (this.rootpos != undefined) {
                    emission.rootpos = egret3d.math.Pool.clone_vector3(this.rootpos);
                }
                if (this.rootRotAngle != undefined) {
                    emission.rootRotAngle = egret3d.math.Pool.clone_vector3(this.rootRotAngle);
                }
                if (this.rootScale != undefined) {
                    emission.rootScale = egret3d.math.Pool.clone_vector3(this.rootScale);
                }
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.pos != undefined)
                    emission.pos = this.pos.clone();
                emission.beLoop = this.beLoop;
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeNumberArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorRate != undefined)
                    emission.colorRate = this.colorRate;
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            };
            Emission.prototype.getworldRotation = function () {
            };
            Emission.prototype.cloneParticleNodeArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            Emission.prototype.cloneParticleNodeNumberArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            return Emission;
        }());
        framework.Emission = Emission;
        __reflect(Emission.prototype, "egret3d.framework.Emission");
        var UVSprite = (function () {
            function UVSprite() {
            }
            UVSprite.prototype.clone = function () {
                var sprite = new UVSprite();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            };
            return UVSprite;
        }());
        framework.UVSprite = UVSprite;
        __reflect(UVSprite.prototype, "egret3d.framework.UVSprite");
        var UVRoll = (function () {
            function UVRoll() {
            }
            UVRoll.prototype.clone = function () {
                var roll = new UVRoll();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    var array = new Array();
                    for (var i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            };
            return UVRoll;
        }());
        framework.UVRoll = UVRoll;
        __reflect(UVRoll.prototype, "egret3d.framework.UVRoll");
        var UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ParticleNode = (function () {
            function ParticleNode() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            ParticleNode.prototype.getValue = function () {
                return new egret3d.math.Vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            };
            ParticleNode.prototype.getValueRandom = function () {
                return new egret3d.math.Vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            };
            ParticleNode.prototype.clone = function () {
                var node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return ParticleNode;
        }());
        framework.ParticleNode = ParticleNode;
        __reflect(ParticleNode.prototype, "egret3d.framework.ParticleNode");
        var AlphaNode = (function () {
            function AlphaNode() {
                this.alpha = new framework.ValueData();
            }
            AlphaNode.prototype.getValue = function () {
                return this.alpha.getValue();
            };
            return AlphaNode;
        }());
        framework.AlphaNode = AlphaNode;
        __reflect(AlphaNode.prototype, "egret3d.framework.AlphaNode");
        var UVSpeedNode = (function () {
            function UVSpeedNode() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            UVSpeedNode.prototype.getValue = function () {
                return new egret3d.math.Vector2(this.u.getValue(), this.v.getValue());
            };
            UVSpeedNode.prototype.getValueRandom = function () {
                return new egret3d.math.Vector2(this.u.getValueRandom(), this.v.getValueRandom());
            };
            UVSpeedNode.prototype.clone = function () {
                var node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return UVSpeedNode;
        }());
        framework.UVSpeedNode = UVSpeedNode;
        __reflect(UVSpeedNode.prototype, "egret3d.framework.UVSpeedNode");
        var ParticleNodeVec2 = (function () {
            function ParticleNodeVec2() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            ParticleNodeVec2.prototype.getValue = function () {
                return new egret3d.math.Vector2(this.x.getValue(), this.y.getValue());
            };
            ParticleNodeVec2.prototype.getValueRandom = function () {
                return new egret3d.math.Vector2(this.x.getValueRandom(), this.y.getValueRandom());
            };
            ParticleNodeVec2.prototype.clone = function () {
                var vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            };
            return ParticleNodeVec2;
        }());
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        __reflect(ParticleNodeVec2.prototype, "egret3d.framework.ParticleNodeVec2");
        var ParticleNodeNumber = (function () {
            function ParticleNodeNumber() {
                this.num = new framework.ValueData();
            }
            ParticleNodeNumber.prototype.getValue = function () {
                return this.num.getValue();
            };
            ParticleNodeNumber.prototype.getValueRandom = function () {
                return this.num.getValueRandom();
            };
            ParticleNodeNumber.prototype.clone = function () {
                var num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            };
            return ParticleNodeNumber;
        }());
        framework.ParticleNodeNumber = ParticleNodeNumber;
        __reflect(ParticleNodeNumber.prototype, "egret3d.framework.ParticleNodeNumber");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        var ParticleStartData = (function () {
            function ParticleStartData() {
                this.shapeType = ParticleSystemShape.NORMAL;
                this._position = new egret3d.math.Vector3(0, 0, 0);
                this._direction = new egret3d.math.Vector3(0, 1, 0);
                this._width = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.emitFrom = emitfromenum.base;
            }
            Object.defineProperty(ParticleStartData.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (_pos) {
                    egret3d.math.vec3Clone(_pos, this._position);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (_dir) {
                    egret3d.math.vec3Clone(_dir, this._direction);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (_w) {
                    this._width = _w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (_h) {
                    this._height = _h;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                set: function (_r) {
                    this._radius = _r;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "angle", {
                get: function () {
                    return this._angle;
                },
                set: function (_a) {
                    this._angle = _a;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "randomDirection", {
                get: function () {
                    switch (this.shapeType) {
                        case ParticleSystemShape.BOX:
                            return this.boxDirection;
                        case ParticleSystemShape.SPHERE:
                            return this.sphereDirection;
                        case ParticleSystemShape.HEMISPHERE:
                            return this.hemisphereDirection;
                        case ParticleSystemShape.CONE:
                            return this.coneDirection;
                        case ParticleSystemShape.CIRCLE:
                            return this.circleDirection;
                        case ParticleSystemShape.EDGE:
                            return this.edgeDirection;
                        default:
                            return this.direction;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "boxDirection", {
                get: function () {
                    this.position.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                    this.position.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                    this.position.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                    egret3d.math.vec3Normalize(this.position, this.direction);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "sphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    egret3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "hemisphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI * 0.5;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    egret3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "coneDirection", {
                get: function () {
                    var randomAngle = Math.random() * Math.PI * 2;
                    var randomHeight = Math.random() * this.height;
                    var upradius = randomHeight * Math.tan(this.angle * Math.PI / 180) + this.radius;
                    var radomRadius = Math.random() * upradius;
                    var bottompos = egret3d.math.Pool.new_vector3();
                    bottompos.x = this.radius * Math.cos(randomAngle);
                    bottompos.y = 0;
                    bottompos.z = this.radius * Math.sin(randomAngle);
                    if (this.emitFrom == emitfromenum.base) {
                        egret3d.math.vec3Clone(bottompos, this.position);
                    }
                    else if (this.emitFrom == emitfromenum.volume) {
                        this.position.x = radomRadius * Math.cos(randomAngle);
                        this.position.z = radomRadius * Math.sin(randomAngle);
                        this.position.y = randomHeight;
                    }
                    this.direction.x = Math.cos(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.z = Math.sin(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.y = Math.cos(this.angle * Math.PI / 180);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "circleDirection", {
                get: function () {
                    var _arc = this.angle * (Math.PI / 180);
                    var a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    this.direction.x = _radius * Math.cos(a);
                    this.direction.z = _radius * Math.sin(a);
                    this.direction.y = 0;
                    var length = egret3d.math.vec3Length(this.direction);
                    egret3d.math.vec3Normalize(this.direction, this.direction);
                    framework.EffectUtil.RotateVector3(this.direction, this.direction, this.direction);
                    this.getposition(this.direction, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "edgeDirection", {
                get: function () {
                    var edgePos = new egret3d.math.Vector3(0, 0, 0);
                    edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                    var lenght = egret3d.math.vec3Length(edgePos);
                    framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                    egret3d.math.vec3Clone(this.direction, this.direction);
                    this.getposition(edgePos, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            ParticleStartData.prototype.getposition = function (dir, length) {
                egret3d.math.vec3ScaleByNum(dir, length, dir);
                this.position.x = dir.x;
                this.position.y = dir.y;
                this.position.z = dir.z;
            };
            ParticleStartData.prototype.clone = function () {
                var data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new egret3d.math.Vector3();
                egret3d.math.vec3Clone(this._position, data._position);
                data._direction = new egret3d.math.Vector3();
                egret3d.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data.position = new egret3d.math.Vector3();
                egret3d.math.vec3Clone(this.position, data.position);
                data.direction = new egret3d.math.Vector3();
                egret3d.math.vec3Clone(this.direction, data.direction);
                return data;
            };
            return ParticleStartData;
        }());
        framework.ParticleStartData = ParticleStartData;
        __reflect(ParticleStartData.prototype, "egret3d.framework.ParticleStartData");
        var emitfromenum;
        (function (emitfromenum) {
            emitfromenum[emitfromenum["base"] = 0] = "base";
            emitfromenum[emitfromenum["volume"] = 1] = "volume";
        })(emitfromenum = framework.emitfromenum || (framework.emitfromenum = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var ValueData = (function () {
            function ValueData() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            Object.defineProperty(ValueData.prototype, "value", {
                set: function (_v) {
                    this._value = _v;
                    this.isRandom = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMin", {
                set: function (_v) {
                    this._valueLimitMin = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMax", {
                set: function (_v) {
                    this._valueLimitMax = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            ValueData.prototype.clone = function () {
                var valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            };
            ValueData.prototype.getValue = function () {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            ValueData.prototype.getValueRandom = function () {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            };
            ValueData.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            return ValueData;
        }());
        framework.ValueData = ValueData;
        __reflect(ValueData.prototype, "egret3d.framework.ValueData");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Curve3 = (function () {
            function Curve3(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            Object.defineProperty(Curve3.prototype, "beizerPoints", {
                get: function () {
                    return this._beizerPoints;
                },
                set: function (value) {
                    this._beizerPoints = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Curve3.prototype, "bezierPointNum", {
                get: function () {
                    return this._bezierPointNum;
                },
                set: function (value) {
                    this._bezierPointNum = value;
                },
                enumerable: true,
                configurable: true
            });
            Curve3.CreateLinearBezier = function (start, end, indices) {
                indices = indices > 2 ? indices : 3;
                var bez = new Array();
                var equation = function (t, va10, va11) {
                    var res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (var i = 1; i <= indices; i++) {
                    bez.push(new egret3d.math.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            };
            Curve3.GetLerpBezier = function (nodes) {
                var beizerPoint = new Array();
                for (var n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            };
            Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2) {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new egret3d.math.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new egret3d.math.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.prototype.getPoints = function () {
                return this._beizerPoints;
            };
            return Curve3;
        }());
        framework.Curve3 = Curve3;
        __reflect(Curve3.prototype, "egret3d.framework.Curve3");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var LinearAction = (function () {
            function LinearAction() {
            }
            LinearAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            };
            LinearAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            };
            return LinearAction;
        }());
        framework.LinearAction = LinearAction;
        __reflect(LinearAction.prototype, "egret3d.framework.LinearAction", ["egret3d.framework.IEffectAction"]);
        var DestroyAction = (function () {
            function DestroyAction() {
            }
            DestroyAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            DestroyAction.prototype.update = function (frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            };
            return DestroyAction;
        }());
        framework.DestroyAction = DestroyAction;
        __reflect(DestroyAction.prototype, "egret3d.framework.DestroyAction", ["egret3d.framework.IEffectAction"]);
        var LoopAction = (function () {
            function LoopAction() {
            }
            LoopAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            LoopAction.prototype.update = function (frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.copyandinit();
                }
            };
            return LoopAction;
        }());
        framework.LoopAction = LoopAction;
        __reflect(LoopAction.prototype, "egret3d.framework.LoopAction", ["egret3d.framework.IEffectAction"]);
        var UVRollAction = (function () {
            function UVRollAction() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            UVRollAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            };
            UVRollAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            };
            return UVRollAction;
        }());
        framework.UVRollAction = UVRollAction;
        __reflect(UVRollAction.prototype, "egret3d.framework.UVRollAction", ["egret3d.framework.IEffectAction"]);
        var UVSpriteAnimationAction = (function () {
            function UVSpriteAnimationAction() {
                this.fps = 30;
                this.row = 1;
                this.colum = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
            }
            UVSpriteAnimationAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["fps"] != undefined) {
                    this.fps = this.params["fps"];
                    this.frameInternal = framework.EffectSystem.fps / this.fps;
                }
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
            };
            UVSpriteAnimationAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if ((frameIndex - this.startFrame) % this.frameInternal == 0) {
                    this.spriteIndex = (frameIndex - this.startFrame) / this.frameInternal;
                    this.spriteIndex %= (this.colum * this.row);
                    this.elements.curAttrData.uv.x = (this.spriteIndex % this.colum) / this.colum;
                    this.elements.curAttrData.uv.y = Math.floor((this.spriteIndex / this.colum)) / this.row;
                    this.elements.curAttrData.tilling.x = 1 / this.colum;
                    this.elements.curAttrData.tilling.y = 1 / this.row;
                }
            };
            return UVSpriteAnimationAction;
        }());
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        __reflect(UVSpriteAnimationAction.prototype, "egret3d.framework.UVSpriteAnimationAction", ["egret3d.framework.IEffectAction"]);
        var RotationAction = (function () {
            function RotationAction() {
            }
            RotationAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.EffectSystem.fps;
            };
            RotationAction.prototype.update = function (frameIndex) {
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
            };
            return RotationAction;
        }());
        framework.RotationAction = RotationAction;
        __reflect(RotationAction.prototype, "egret3d.framework.RotationAction", ["egret3d.framework.IEffectAction"]);
        var RoseCurveAction = (function () {
            function RoseCurveAction() {
            }
            RoseCurveAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.EffectSystem.fps;
            };
            RoseCurveAction.prototype.update = function (frameIndex) {
                var initFrameDataPos = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                var radius = this.radius;
                var curFrame = frameIndex % 360;
                var x = this.polar.x.getValue();
                var y = this.polar.y.getValue();
                var z = this.polar.z.getValue();
                var theta = frameIndex * this.speed;
                this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                var deltaTheta = frameIndex * this.speed + 0.001;
                var targetPoint = egret3d.math.Pool.new_vector3();
                targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                var rotation = egret3d.math.Pool.new_quaternion();
                egret3d.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                egret3d.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                egret3d.math.Pool.delete_vector3(targetPoint);
                egret3d.math.Pool.delete_quaternion(rotation);
                egret3d.math.Pool.delete_vector3(initFrameDataPos);
            };
            return RoseCurveAction;
        }());
        framework.RoseCurveAction = RoseCurveAction;
        __reflect(RoseCurveAction.prototype, "egret3d.framework.RoseCurveAction", ["egret3d.framework.IEffectAction"]);
        var TrailAction = (function () {
            function TrailAction() {
                this.offsetTransalte = new egret3d.math.Vector3();
            }
            TrailAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                var mat = new egret3d.framework.Material();
                var shader = new egret3d.framework.Shader();
                var texture = new egret3d.framework.Texture();
                if (this.params["shader"] != undefined)
                    shader = framework.AssetMap.find(this.params["shader"]);
                else
                    shader = framework.DefaultShaders.Diffuse;
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.AssetMap.find(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.EffectSystem.fps;
                this.transform = new egret3d.framework.Transform();
                scene.addChild(this.transform);
                var curAttrData = this.elements.data.initFrameData.attrsData.clone();
                var worldTranslate = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    egret3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                this.transform.setLocalPosition(worldTranslate);
                egret3d.math.Pool.delete_vector3(worldTranslate);
                var trailTransform = new egret3d.framework.Transform();
                this.transform.addChild(trailTransform);
                var x = this.eular.x.getValue();
                var y = this.eular.y.getValue();
                var z = this.eular.z.getValue();
                this.startRotation = new egret3d.math.Quaternion();
                egret3d.math.quatFromEulerAngles(x, y, z, this.startRotation);
                var resultRotation = new egret3d.math.Quaternion();
                egret3d.math.quatMultiply(this.startRotation, curAttrData.localRotation, resultRotation);
                this.transform.setLocalRotation(resultRotation);
                var trailrender = trailTransform.gameObject.addComponent("TrailRender");
                trailrender.color = new egret3d.math.Color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            };
            TrailAction.prototype.update = function (frameIndex) {
                var worldTranslate = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    egret3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                egret3d.math.vec3Add(worldTranslate, this.offsetTransalte, worldTranslate);
                this.transform.setLocalPosition(worldTranslate);
                egret3d.math.Pool.delete_vector3(worldTranslate);
                var resultRotation = egret3d.math.Pool.new_quaternion();
                egret3d.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, resultRotation);
                this.transform.setLocalRotation(resultRotation);
                egret3d.math.Pool.delete_quaternion(resultRotation);
            };
            return TrailAction;
        }());
        framework.TrailAction = TrailAction;
        __reflect(TrailAction.prototype, "egret3d.framework.TrailAction", ["egret3d.framework.IEffectAction"]);
        var BreathAction = (function () {
            function BreathAction() {
            }
            BreathAction.prototype.init = function (scene, _startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            };
            BreathAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex)
                    return;
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            };
            BreathAction.prototype.swap = function () {
                var temp;
                if (this.startvalue instanceof egret3d.math.Vector3) {
                    temp = egret3d.math.Pool.clone_vector3(this.startvalue);
                    this.startvalue = egret3d.math.Pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof egret3d.math.Vector2) {
                    temp = egret3d.math.Pool.clone_vector2(this.startvalue);
                    this.startvalue = egret3d.math.Pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            };
            BreathAction.prototype.getLerpValue = function (frameIndex) {
                var curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                var outVal;
                if (this.startvalue instanceof egret3d.math.Vector3) {
                    outVal = new egret3d.math.Vector3();
                    egret3d.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof egret3d.math.Vector2) {
                    outVal = new egret3d.math.Vector2();
                    egret3d.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = egret3d.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            };
            return BreathAction;
        }());
        framework.BreathAction = BreathAction;
        __reflect(BreathAction.prototype, "egret3d.framework.BreathAction", ["egret3d.framework.IEffectAction"]);
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EffectParser = (function () {
            function EffectParser() {
            }
            EffectParser.prototype.Parse = function (str) {
                if (str == null)
                    return null;
                var effectData = new framework.EffectSystemData();
                var content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["beloop"] != undefined) {
                    effectData.beLoop = content["beloop"];
                }
                if (content["elements"] != undefined) {
                    effectData.elements = [];
                    var elements = content["elements"];
                    for (var i in elements) {
                        var element = new framework.EffectElementData();
                        effectData.elements.push(element);
                        var elementData = elements[i];
                        if (elementData["name"] != undefined)
                            element.name = elementData["name"];
                        if (elementData["ref"] != undefined)
                            element.ref = elementData["ref"];
                        if (elementData["beloop"] != undefined)
                            element.beloop = elementData["beloop"];
                        if (elementData["type"] != undefined) {
                            switch (elementData["type"]) {
                                case "singlemesh":
                                    element.type = framework.EffectElementTypeEnum.SingleMeshType;
                                    break;
                                case "emission":
                                    element.type = framework.EffectElementTypeEnum.EmissionType;
                                    break;
                            }
                        }
                        switch (element.type) {
                            case framework.EffectElementTypeEnum.SingleMeshType:
                                this._parseSingleMeshTypeData(elementData, element);
                                break;
                            case framework.EffectElementTypeEnum.EmissionType:
                                this._parseEmissionTypeData(elementData, element);
                                break;
                        }
                    }
                }
                return effectData;
            };
            EffectParser.prototype._parseSingleMeshTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    var _timelineArray = elementData["timeline"];
                    for (var j in _timelineArray) {
                        var _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("必须要配一个关键帧的索引");
                            continue;
                        }
                        var frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            var _attrs = _timeline["attrs"];
                            for (var key in _attrs) {
                                var val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                                else if (key == "colorRate") {
                                    frame.attrsData.colorRate = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (var x in _timeline["lerp"]) {
                                var lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                var _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    var _attribs = _lerp["attribute"];
                                    for (var key in _attribs) {
                                        lerp.attrsList.push(key);
                                        var val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                        else {
                                            console.error("未支持的插值属性：" + key);
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            var _actions = _timeline["actions"];
                            for (var k in _actions) {
                                var action = new framework.EffectActionData();
                                var _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"];
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    if (elementData["timeline"]["attrs"] != undefined) {
                        var _data = elementData["timeline"]["attrs"];
                        var data = new framework.Emission();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            if (_data["rootpos"] != undefined) {
                                data.rootpos = framework.EffectUtil.parseVector3(_data["rootpos"]);
                            }
                            else {
                                data.rootpos = new egret3d.math.Vector3();
                            }
                            if (_data["rootRotAngle"] != undefined) {
                                data.rootRotAngle = framework.EffectUtil.parseVector3(_data["rootRotAngle"]);
                            }
                            else {
                                data.rootRotAngle = new egret3d.math.Vector3();
                            }
                            if (_data["rootscale"]) {
                                data.rootScale = framework.EffectUtil.parseVector3(_data["rootscale"]);
                            }
                            else {
                                data.rootScale = new egret3d.math.Vector3(1, 1, 1);
                            }
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (var i in _data["eulerNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                var startscale = new framework.ParticleNodeNumber();
                                startscale.num.value = 1;
                                startscale.key = 0;
                                data.scaleNodes.push(startscale);
                                for (var i in _data["scaleNodes"]) {
                                    var node = framework.EffectUtil.parseEffectNumNode(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined) {
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            }
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (var i in _data["alphaNodes"]) {
                                    var node = new framework.ParticleNodeNumber();
                                    var item = _data["alphaNodes"][i];
                                    if (item["key"] != null) {
                                        node.key = item["key"];
                                    }
                                    var alphavalue = item["alpha"];
                                    if (alphavalue != null) {
                                        if (alphavalue instanceof Array) {
                                            node.num.valueLimitMin = alphavalue[0];
                                            node.num.valueLimitMax = alphavalue[1];
                                        }
                                        else {
                                            node.num.value = alphavalue;
                                        }
                                    }
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorRate"] != undefined)
                                data.colorRate = _data["colorRate"];
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (var i in _data["colorNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRoll();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        var _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSprite();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionShape = function (_startdata, element) {
                var startdata = element.emissionData.particleStartData;
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        startdata.shapeType = egret3d.framework.ParticleSystemShape.NORMAL;
                        break;
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    var _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["x"];
                    startdata.direction.y = _startdir["y"];
                    startdata.direction.z = _startdir["z"];
                }
            };
            EffectParser.prototype._parseToObjData = function (attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        var mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = framework.AssetMap.find(content["shader"]);
                            else
                                mat.shader = framework.DefaultShaders.Diffuse;
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = framework.AssetMap.find(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                        }
                        return mat;
                    case "emmision":
                        var emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        var billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        var str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0)
                            return framework.AssetMap.find(content);
                        else
                            return framework.AssetMap.find(content);
                    default:
                        return content;
                }
            };
            EffectParser.prototype._parseToParticleNode = function (content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                var charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    var node = new framework.ParticleNode();
                    for (var i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            };
            EffectParser.prototype._parseToValueData = function (content) {
                var data = new framework.ValueData();
                var array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            };
            EffectParser.prototype._parseToNumberArray = function (content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                var _array = content.split(",");
                var result = [];
                for (var i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            };
            return EffectParser;
        }());
        framework.EffectParser = EffectParser;
        __reflect(EffectParser.prototype, "egret3d.framework.EffectParser");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EffectUtil = (function () {
            function EffectUtil() {
            }
            EffectUtil.lookatbyXAxis = function (pos, xAxis, yAxis, zAxis, targetpos, quat) {
                var dir = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(targetpos, pos, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var crossup = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Cross(dir, xAxis, crossup);
                egret3d.math.vec3Normalize(crossup, crossup);
                var anglerot = egret3d.math.vec3Dot(yAxis, crossup);
                anglerot = Math.acos(anglerot) * 180 / Math.PI;
                var dot = egret3d.math.vec3Dot(zAxis, crossup);
                dot = Math.acos(dot) * 180 / Math.PI;
                if (dot > 90) {
                    anglerot = -anglerot;
                }
                egret3d.math.quatFromAxisAngle(egret3d.math.Pool.vector3_right, anglerot, quat);
                egret3d.math.Pool.delete_vector3(dir);
                egret3d.math.Pool.delete_vector3(crossup);
            };
            EffectUtil.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            EffectUtil.vecMuliNum = function (vec, num) {
                var v = new egret3d.math.Vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            };
            EffectUtil.parseVector3 = function (value) {
                var vector3 = new egret3d.math.Vector3();
                vector3.x = value["x"];
                vector3.y = value["y"];
                vector3.z = value["z"];
                return vector3;
            };
            EffectUtil.parseEffectVec3 = function (value) {
                var node = new framework.ParticleNode();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectVec2 = function (value) {
                var node = new framework.ParticleNodeVec2();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectNum = function (value) {
                var node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            };
            EffectUtil.parseEffectNumNode = function (value) {
                var node = new framework.ParticleNodeNumber();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node.num.value = value[key];
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectValueData = function (value) {
                var val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            };
            EffectUtil.parseEffectUVSpeed = function (value) {
                var node = new framework.UVSpeedNode();
                for (var key in value) {
                    node[key].value = value[key];
                }
                return node;
            };
            EffectUtil.lookat = function (eye, targetpos, out, up) {
                if (up === void 0) { up = egret3d.math.Pool.vector3_up; }
                var dir = new egret3d.math.Vector3();
                egret3d.math.vec3Subtract(targetpos, eye, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var unitprojectedXZ = new egret3d.math.Vector3(dir.x, 0, dir.z);
                egret3d.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                egret3d.math.quatFromAxisAngle(up, yaw, out);
                var right = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Cross(up, dir, right);
                egret3d.math.vec3Normalize(right, right);
                var projectedXZ = new egret3d.math.Vector3(dir.x, 0, dir.z);
                var length = egret3d.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = egret3d.math.Pool.new_quaternion();
                egret3d.math.quatFromAxisAngle(right, pitch, quadRight);
            };
            EffectUtil.RotateVector3 = function (source, direction, out) {
                egret3d.math.vec3Normalize(source, source);
                egret3d.math.vec3Normalize(direction, direction);
                var forward = new egret3d.math.Vector3(0, 0, 1);
                var axis = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Cross(forward, direction, axis);
                egret3d.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                var cos = egret3d.math.vec3Dot(forward, direction);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                var quatertion = egret3d.math.Pool.new_quaternion();
                egret3d.math.quatFromAxisAngle(axis, angle, quatertion);
                egret3d.math.quatTransformVector(quatertion, source, out);
                egret3d.math.Pool.delete_vector3(axis);
                egret3d.math.Pool.delete_quaternion(quatertion);
            };
            EffectUtil.bindAxisBillboard = function (localAxis, out) {
                egret3d.math.vec3Normalize(localAxis, localAxis);
                var yAxis = egret3d.math.Pool.vector3_up;
                var normal = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Cross(yAxis, localAxis, normal);
                egret3d.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                var cos = egret3d.math.vec3Dot(yAxis, localAxis);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                egret3d.math.quatFromAxisAngle(normal, angle, out);
            };
            EffectUtil.lookatVerticalBillboard = function (eye, targetpos, out, up) {
                if (up === void 0) { up = egret3d.math.Pool.vector3_up; }
                var dir = new egret3d.math.Vector3();
                egret3d.math.vec3Subtract(targetpos, eye, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var dirxz = new egret3d.math.Vector3(dir.x, 0, dir.z);
                egret3d.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                egret3d.math.quatFromAxisAngle(up, yaw, out);
            };
            EffectUtil.quatLookatZ = function (eye, targetpos, out, forward) {
                if (forward === void 0) { forward = egret3d.math.Pool.vector3_forward; }
                var dir = new egret3d.math.Vector3();
                egret3d.math.vec3Subtract(targetpos, eye, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var dirxy = new egret3d.math.Vector3(-dir.x, dir.y, 0);
                egret3d.math.vec3Normalize(dirxy, dirxy);
                var roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                egret3d.math.quatFromAxisAngle(forward, roll, out);
            };
            EffectUtil.quatLookatX = function (eye, targetpos, out, right) {
                if (right === void 0) { right = egret3d.math.Pool.vector3_right; }
                var dir = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(targetpos, eye, dir);
                egret3d.math.vec3Normalize(dir, dir);
                var diryz = new egret3d.math.Vector3(0, -dir.y, dir.z);
                egret3d.math.vec3Normalize(diryz, diryz);
                var pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                egret3d.math.quatFromAxisAngle(right, pitch, out);
            };
            return EffectUtil;
        }());
        framework.EffectUtil = EffectUtil;
        __reflect(EffectUtil.prototype, "egret3d.framework.EffectUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EmissionBatcher = (function () {
            function EmissionBatcher(_data, effectSys, emissionElement) {
                this.particles = [];
                this.vertexSize = 0;
                this.formate = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.webgl = emissionElement.webgl;
                this.gameObject = effectSys.gameObject;
                this.effectSys = effectSys;
                this.emissionElement = emissionElement;
                this.data = _data;
                this.formate = effectSys.particleVF;
                this.vertexSize = egret3d.render.MeshData.calcByteSize(this.formate) / 4;
                this.initMesh();
                this.mat = new framework.Material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.AssetMap.find("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
            }
            EmissionBatcher.prototype.initMesh = function () {
                this.mesh = new framework.Mesh();
                this.mesh.data = new egret3d.render.MeshData();
                this.mesh.glMesh = new egret3d.render.GlMesh();
                this.mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = 0;
                sm.line = false;
                this.mesh.submesh.push(sm);
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.effectSys.particleVF, 128, egret3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            };
            EmissionBatcher.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle(this);
                p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emissionElement.perVertexCount;
                this.curIndexCount += this.emissionElement.perIndexxCount;
                this.mesh.glMesh.uploadIndexSubData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emissionElement.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emissionElement.perIndexxCount;
                if (needvercount * this.vertexSize > this.dataForVbo.length) {
                    var length_1 = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length_1 * 2);
                    var vbo = new Float32Array(length_1 * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length_2 = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length_2 * 2);
                    var ebo = new Uint16Array(length_2 * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher.prototype.render = function (context, camera) {
                var mesh = this.mesh;
                mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.mat.draw(context, mesh, mesh.submesh[0], "base");
            };
            EmissionBatcher.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher;
        }());
        framework.EmissionBatcher = EmissionBatcher;
        __reflect(EmissionBatcher.prototype, "egret3d.framework.EmissionBatcher");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Particle = (function () {
            function Particle(batcher) {
                this.renderModel = framework.RenderModel.Mesh;
                this.localMatrix = new egret3d.math.Matrix();
                this.startScale = new egret3d.math.Vector3();
                this.startRotation = new egret3d.math.Quaternion();
                this.rotationByShape = new egret3d.math.Quaternion();
                this.rotationByEuler = new egret3d.math.Quaternion();
                this.localRotation = new egret3d.math.Quaternion();
                this.tilling = new egret3d.math.Vector2(1, 1);
                this.speedDir = new egret3d.math.Vector3(0, 0, 0);
                this.actived = true;
                this.matToBatcher = new egret3d.math.Matrix();
                this.matToworld = new egret3d.math.Matrix();
                this.tex_ST = new egret3d.math.Vector4(1, 1, 0, 0);
                this.gameObject = batcher.effectSys.gameObject;
                this.emisson = batcher.emissionElement;
                this.batcher = batcher;
                this.format = batcher.formate;
                this.data = batcher.data.clone();
                this.vertexSize = egret3d.render.MeshData.calcByteSize(this.format) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.vertexCount = this.emisson.perVertexCount;
                this.dataForVbo = new Float32Array(this.vertexCount * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.format), 0);
                this.sourceVbo = this.data.getVboData(this.format);
                this.initByData();
            }
            Particle.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            };
            Particle.prototype.initByData = function () {
                this.totalLife = this.data.life.getValueRandom();
                this.renderModel = this.data.renderModel;
                this.curLife = 0;
                this.startFrameId = this.batcher.effectSys.frameId;
                var localRandomDirection = this.data.particleStartData.randomDirection;
                this.speedDir = egret3d.math.Pool.clone_vector3(localRandomDirection);
                var localRandomTranslate = this.data.particleStartData.position;
                this.localTranslate = egret3d.math.Pool.clone_vector3(localRandomTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new egret3d.math.Vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.localScale = new egret3d.math.Vector3(1, 1, 1);
                else
                    this.localScale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new egret3d.math.Vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.data.uv == undefined)
                    this.uv = new egret3d.math.Vector2();
                else
                    this.uv = this.data.uv.getValueRandom();
                if (this.data.moveSpeed != undefined) {
                    this.movespeed = this.data.moveSpeed.getValue();
                }
                else {
                    this.movespeed = new egret3d.math.Vector3();
                }
                if (this.data.colorRate == undefined) {
                    this.colorRate = this.data.colorRate;
                }
                else {
                    this.colorRate = 1;
                }
                egret3d.math.vec3Clone(this.localScale, this.startScale);
                egret3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        var localOrgin = egret3d.math.Pool.vector3_zero;
                        egret3d.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        var initRot = egret3d.math.Pool.new_quaternion();
                        egret3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                        egret3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        egret3d.math.quatClone(this.rotationByShape, this.localRotation);
                        egret3d.math.Pool.delete_quaternion(initRot);
                    }
                }
            };
            Particle.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                if (this.curLife >= this.totalLife) {
                    egret3d.math.matrixZero(this.matToBatcher);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle.prototype._updateLocalMatrix = function (delta) {
                egret3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                egret3d.math.matrixMultiply(this.emisson.matToBatcher, this.localMatrix, this.matToBatcher);
            };
            Particle.prototype._updateRotation = function (delta) {
                this._updateElementRotation();
            };
            Particle.prototype._updateElementRotation = function () {
                var scene = this.gameObject.getScene();
                if (!scene)
                    return;
                var cam = scene.mainCamera;
                var cameraTransform = cam.gameObject.transform;
                var translation = egret3d.math.Pool.new_vector3();
                var worldRotation = egret3d.math.Pool.new_quaternion();
                var worldTranslation = egret3d.math.Pool.new_vector3();
                var invTransformRotation = egret3d.math.Pool.new_quaternion();
                egret3d.math.vec3Clone(this.localTranslate, translation);
                egret3d.math.matrixTransformVector3(translation, this.emisson.getmatrixToWorld(), worldTranslation);
                if (this.renderModel != framework.RenderModel.Mesh) {
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        egret3d.math.quatLookat(worldTranslation, cameraTransform.getPosition(), worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = egret3d.math.Pool.new_vector3();
                        egret3d.math.vec3Clone(cameraTransform.getPosition(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        egret3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        egret3d.math.Pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        egret3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        egret3d.math.matrixMultiply(this.emisson.getmatrixToWorld(), this.localMatrix, this.matToworld);
                        var xaxis = egret3d.math.Pool.new_vector3();
                        var yaxis = egret3d.math.Pool.new_vector3();
                        var zaxis = egret3d.math.Pool.new_vector3();
                        egret3d.math.matrixTransformNormal(egret3d.math.Pool.vector3_right, this.matToworld, xaxis);
                        egret3d.math.vec3Normalize(xaxis, xaxis);
                        egret3d.math.matrixTransformNormal(egret3d.math.Pool.vector3_up, this.matToworld, yaxis);
                        egret3d.math.vec3Normalize(yaxis, yaxis);
                        egret3d.math.matrixTransformNormal(egret3d.math.Pool.vector3_forward, this.matToworld, zaxis);
                        egret3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, cameraTransform.getPosition(), worldRotation);
                        egret3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        egret3d.math.Pool.delete_quaternion(worldRotation);
                        egret3d.math.Pool.delete_vector3(translation);
                        egret3d.math.Pool.delete_quaternion(invTransformRotation);
                        egret3d.math.Pool.delete_vector3(xaxis);
                        egret3d.math.Pool.delete_vector3(yaxis);
                        egret3d.math.Pool.delete_vector3(zaxis);
                        return;
                    }
                    egret3d.math.quatClone(this.emisson.getWorldRotation(), invTransformRotation);
                    egret3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    egret3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    egret3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else {
                    egret3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
                egret3d.math.Pool.delete_vector3(translation);
                egret3d.math.Pool.delete_quaternion(worldRotation);
                egret3d.math.Pool.delete_vector3(worldTranslation);
                egret3d.math.Pool.delete_quaternion(invTransformRotation);
            };
            Particle.prototype._updatePos = function (delta) {
                if (this.data.moveSpeed != undefined) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                egret3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            };
            Particle.prototype._updateEuler = function (delta) {
                var index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("eulerNodes & eulerSpeed exist at the same time！");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.totalLife, this.euler);
                    egret3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                    egret3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
            };
            Particle.prototype._updateScale = function (delta) {
                var index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("eulerNodes & eulerSpeed exist at the same time！");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.totalLife, this.localScale, nodeType.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.localScale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.localScale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.localScale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateColor = function (delta) {
                var index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("colorNodes & colorSpeed exist at the same time！");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.totalLife, this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateNode = function (nodes, life, out, nodetype) {
                if (nodetype === void 0) { nodetype = nodeType.none; }
                var index = 0;
                var duration = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                            }
                        }
                    }
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            egret3d.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        if (duration > 0) {
                            if (nodetype == nodeType.alpha) {
                                this.alpha = egret3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                            }
                            else if (nodetype = nodeType.scale) {
                                var targetscale = egret3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                                egret3d.math.vec3ScaleByNum(this.startScale, targetscale, out);
                            }
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            egret3d.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            };
            Particle.prototype._updateAlpha = function (delta) {
                var index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("alphaNodes & alphaSpeed exist at the same time！");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.totalLife, this.alpha, nodeType.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            };
            Particle.prototype._updateUV = function (delta) {
                if (this.uv == undefined)
                    this.uv = new egret3d.math.Vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uvSpeedNodes & uvSpeed exist at the same time！");
                            return;
                        }
                        var index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.totalLife, this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.tex_ST.z += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.tex_ST.w += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        var spriteindex = Math.floor(this.curLife / this.totalLife * this.data.uvSprite.totalCount);
                        egret3d.math.spriteAnimation(this.data.uvSprite.row, this.data.uvSprite.column, spriteindex, this.tex_ST);
                    }
                }
            };
            Particle.prototype._updateVBO = function () {
                var vertexSize = this.vertexSize;
                for (var i = 0; i < this.vertexCount; i++) {
                    var vertex = egret3d.math.Pool.new_vector3();
                    vertex.x = this.sourceVbo[i * vertexSize + 0];
                    vertex.y = this.sourceVbo[i * vertexSize + 1];
                    vertex.z = this.sourceVbo[i * vertexSize + 2];
                    egret3d.math.matrixTransformVector3(vertex, this.matToBatcher, vertex);
                    this.dataForVbo[i * vertexSize + 0] = vertex.x;
                    this.dataForVbo[i * vertexSize + 1] = vertex.y;
                    this.dataForVbo[i * vertexSize + 2] = vertex.z;
                    egret3d.math.Pool.delete_vector3(vertex);
                    var r = egret3d.math.floatClamp(this.sourceVbo[i * vertexSize + 3], 0, 1);
                    var g = egret3d.math.floatClamp(this.sourceVbo[i * vertexSize + 4], 0, 1);
                    var b = egret3d.math.floatClamp(this.sourceVbo[i * vertexSize + 5], 0, 1);
                    var a = egret3d.math.floatClamp(this.sourceVbo[i * vertexSize + 6], 0, 1);
                    if (this.color != undefined) {
                        r = this.color.x;
                        g = this.color.y;
                        b = this.color.z;
                    }
                    if (this.alpha != undefined)
                        a = this.alpha;
                    if (this.colorRate != undefined) {
                        r *= this.colorRate;
                        g *= this.colorRate;
                        b *= this.colorRate;
                        a *= this.colorRate;
                    }
                    r = egret3d.math.floatClamp(r, 0, 3);
                    g = egret3d.math.floatClamp(r, 0, 3);
                    b = egret3d.math.floatClamp(r, 0, 3);
                    a = egret3d.math.floatClamp(r, 0, 3);
                    this.dataForVbo[i * this.vertexSize + 3] = r;
                    this.dataForVbo[i * this.vertexSize + 4] = g;
                    this.dataForVbo[i * this.vertexSize + 5] = b;
                    this.dataForVbo[i * this.vertexSize + 6] = a;
                    this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                    this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                }
            };
            Particle.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.localScale = null;
                this.colorRate = 1;
                this.color = null;
                this.uv = null;
            };
            return Particle;
        }());
        framework.Particle = Particle;
        __reflect(Particle.prototype, "egret3d.framework.Particle");
        var nodeType;
        (function (nodeType) {
            nodeType[nodeType["none"] = 0] = "none";
            nodeType[nodeType["alpha"] = 1] = "alpha";
            nodeType[nodeType["scale"] = 2] = "scale";
        })(nodeType = framework.nodeType || (framework.nodeType = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Particles = (function () {
            function Particles(sys) {
                this.emissionElements = [];
                this.loopFrame = Number.MAX_VALUE;
                this.effectSys = sys;
                this.vf = sys.particleVF;
            }
            Particles.prototype.addEmission = function (_emissionNew) {
                var _emissionElement = new EmissionElement(_emissionNew, this.effectSys);
                this.emissionElements.push(_emissionElement);
            };
            Particles.prototype.update = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            };
            Particles.prototype.render = function (context, camera) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].render(context, camera);
                }
            };
            Particles.prototype.dispose = function () {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
                this.emissionElements.length = 0;
            };
            return Particles;
        }());
        framework.Particles = Particles;
        __reflect(Particles.prototype, "egret3d.framework.Particles");
        var EmissionElement = (function () {
            function EmissionElement(_emission, sys) {
                this.beloop = false;
                this.active = true;
                this.isover = false;
                this.maxVertexCount = 2048;
                this.localtranslate = new egret3d.math.Vector3();
                this.localScale = new egret3d.math.Vector3(1, 1, 1);
                this.localrotate = new egret3d.math.Quaternion();
                this.eluerAngle = new egret3d.math.Quaternion();
                this.worldRotation = new egret3d.math.Quaternion();
                this.matToBatcher = new egret3d.math.Matrix();
                this.matToWorld = new egret3d.math.Matrix();
                this.webgl = egret3d.render.Webglkit.webgl;
                this.effectSys = sys;
                this.vf = sys.particleVF;
                this.gameObject = sys.gameObject;
                this.emission = _emission.emissionData;
                switch (this.emission.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emission.time / (this.emission.emissionCount);
                        break;
                }
                this.curTime = 0;
                this.numcount = 0;
                this.beloop = _emission.beloop;
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.addBatcher();
                this.perVertexCount = this.emission.mesh.data.pos.length;
                this.perIndexxCount = this.emission.mesh.data.trisindex.length;
                egret3d.math.vec3Clone(this.emission.rootpos, this.localtranslate);
                egret3d.math.vec3Clone(this.emission.rootRotAngle, this.eluerAngle);
                egret3d.math.vec3Clone(this.emission.rootScale, this.localScale);
                egret3d.math.quatFromEulerAngles(this.eluerAngle.x, this.eluerAngle.y, this.eluerAngle.z, this.localrotate);
                egret3d.math.matrixMakeTransformRTS(this.localtranslate, this.localScale, this.localrotate, this.matToBatcher);
            }
            EmissionElement.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getRotation();
                egret3d.math.quatMultiply(parRot, this.localrotate, this.worldRotation);
                return this.worldRotation;
            };
            EmissionElement.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                egret3d.math.matrixMultiply(mat, this.matToBatcher, this.matToWorld);
                return this.matToWorld;
            };
            EmissionElement.prototype.update = function (delta) {
                this.curTime += delta;
                this.updateEmission(delta);
                this.updateBatcher(delta);
            };
            EmissionElement.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EmissionElement.prototype.updateEmission = function (delta) {
                if (this.isover)
                    return;
                if (this.emission.emissionType == framework.ParticleEmissionType.continue) {
                    if (this.numcount == 0) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (this.curTime > this._continueSpaceTime) {
                        if (this.numcount < this.emission.emissionCount) {
                            this.addParticle();
                            this.curTime = 0;
                            this.numcount++;
                        }
                        else {
                            if (this.beloop) {
                                this.curTime = 0;
                                this.numcount = 0;
                                this.isover = false;
                            }
                            else {
                                this.isover = true;
                            }
                        }
                    }
                }
                else if (this.emission.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emission.time) {
                        this.addParticle(this.emission.emissionCount);
                        if (this.beloop) {
                            this.curTime = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
            };
            EmissionElement.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EmissionElement.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher(this.emission, this.effectSys, this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            EmissionElement.prototype.render = function (context, camera) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, camera);
                }
            };
            EmissionElement.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EmissionElement.prototype.isOver = function () {
                return this.isover;
            };
            return EmissionElement;
        }());
        framework.EmissionElement = EmissionElement;
        __reflect(EmissionElement.prototype, "egret3d.framework.EmissionElement");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var GameObject = (function () {
            function GameObject() {
                this.layer = 0;
                this.hideFlags = framework.HideFlags.None;
                this.components = [];
                this.componentsInit = [];
                this.rendererDirty = false;
                this._visible = true;
            }
            GameObject.prototype.getScene = function () {
                return this.transform.scene;
            };
            Object.defineProperty(GameObject.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible && obj.transform.parent) {
                        obj = obj.transform.parent.gameObject;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GameObject.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                    }
                },
                enumerable: true,
                configurable: true
            });
            GameObject.prototype.getName = function () {
                return this.transform.name;
            };
            GameObject.prototype.init = function () {
                if (this.componentsInit.length > 0) {
                    for (var i = 0; i < this.componentsInit.length; i++) {
                        this.componentsInit[i].comp.start();
                        this.componentsInit[i].init = true;
                    }
                    this.componentsInit.length = 0;
                }
            };
            GameObject.prototype.update = function (delta) {
                if (this.components.length == 0)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.update(delta);
                }
            };
            GameObject.prototype.addComponentDirect = function (comp) {
                this.transform.markHaveComponent();
                if (comp.gameObject != null) {
                    throw new Error("try to add a component which has added to another game object!");
                }
                comp.gameObject = this;
                var add = true;
                if (egret3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                        var scene = this.getScene();
                        if (scene) {
                            scene.renderList.addRenderer(this.renderer);
                        }
                    }
                    else {
                        console.warn("cannot add more than one render component");
                        add = false;
                    }
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    if (this.camera == null) {
                        this.camera = comp;
                    }
                    else {
                        console.warn("cannot add more than one camera component");
                        add = false;
                    }
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    if (this.light == null) {
                        this.light = comp;
                    }
                    else {
                        console.warn("cannot add more than one light component");
                        add = false;
                    }
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "spherecollider") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        console.warn("cannot add more than one collider component");
                        add = false;
                    }
                }
                if (add) {
                    var nodeObj = new framework.NodeComponent(comp, false);
                    this.components.push(nodeObj);
                    this.componentsInit.push(nodeObj);
                    if (egret3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    }
                    if (egret3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    }
                }
                return comp;
            };
            GameObject.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = egret3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            GameObject.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            GameObject.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            };
            GameObject.prototype._getComponentsInChildren = function (type, obj, array) {
                for (var i = 0; i < obj.components.length; i++) {
                    var cname = egret3d.reflect.getClassName(obj.components[i].comp["__proto__"]);
                    if (cname == type) {
                        array.push(obj.components[i].comp);
                    }
                }
                if (obj.transform.children != undefined) {
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        var _obj = obj.transform.children[i].gameObject;
                        this._getComponentsInChildren(type, _obj, array);
                    }
                }
            };
            GameObject.prototype.getComponentInParent = function (type) {
                var result = null;
                var _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            };
            GameObject.prototype.addComponent = function (type) {
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("try to add a " + type + " component but already has one!");
                    }
                }
                var pp = egret3d.reflect.getPrototype(type);
                var comp = egret3d.reflect.createInstance(pp, { "nodecomp": "1" });
                return this.addComponentDirect(comp);
            };
            GameObject.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this._removeComponentReference(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            GameObject.prototype._removeComponentReference = function (comp) {
                if (egret3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    var scene = this.getScene();
                    if (scene && this.renderer) {
                        scene.renderList.removeRenderer(this.renderer);
                    }
                    this.renderer = null;
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    this.camera = null;
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    this.light = null;
                }
                if (egret3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || egret3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    this.collider = null;
                }
            };
            GameObject.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (egret3d.reflect.getClassName(this.components[i].comp) == type) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this._removeComponentReference(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            GameObject.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    {
                        this.components[i].comp.remove();
                    }
                    this._removeComponentReference(this.components[i].comp);
                }
                this.components.length = 0;
            };
            GameObject.prototype.dispose = function () {
                this.removeAllComponents();
            };
            __decorate([
                egret3d.reflect.Field("number"),
                egret3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], GameObject.prototype, "layer", void 0);
            __decorate([
                egret3d.reflect.Field("NodeComponent[]"),
                __metadata("design:type", Array)
            ], GameObject.prototype, "components", void 0);
            GameObject = __decorate([
                egret3d.reflect.SerializeType
            ], GameObject);
            return GameObject;
        }());
        framework.GameObject = GameObject;
        __reflect(GameObject.prototype, "egret3d.framework.GameObject");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var HideFlags;
        (function (HideFlags) {
            HideFlags[HideFlags["None"] = 0] = "None";
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var RenderLayerEnum;
        (function (RenderLayerEnum) {
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            RenderLayerEnum[RenderLayerEnum["UI"] = 2] = "UI";
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 3] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var NodeComponent = (function () {
            function NodeComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.init = init;
                this.comp = comp;
            }
            __decorate([
                egret3d.reflect.Field("INodeComponent"),
                __metadata("design:type", Object)
            ], NodeComponent.prototype, "comp", void 0);
            NodeComponent = __decorate([
                egret3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], NodeComponent);
            return NodeComponent;
        }());
        framework.NodeComponent = NodeComponent;
        __reflect(NodeComponent.prototype, "egret3d.framework.NodeComponent");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var RenderContext = (function () {
            function RenderContext(webgl) {
                this.version = 0;
                this.viewPortPixel = new egret3d.math.Rect(0, 0, 0, 0);
                this.eyePos = new egret3d.math.Vector4();
                this.matrixView = new egret3d.math.Matrix();
                this.matrixProject = new egret3d.math.Matrix();
                this.matrixModel = new egret3d.math.Matrix();
                this.matrixModelViewProject = new egret3d.math.Matrix;
                this.matrixModelView = new egret3d.math.Matrix;
                this.matrixViewProject = new egret3d.math.Matrix;
                this.floatTimer = 0;
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmapUV = 1;
                this.lightmapOffset = new egret3d.math.Vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            RenderContext.prototype.updateLightmap = function (texture, uv, offset) {
                this.lightmap = texture;
                this.lightmapUV = uv;
                this.lightmapOffset = offset;
                this.version++;
            };
            RenderContext.prototype.updateCamera = function (app, camera) {
                camera.calcViewPortPixel(app, this.viewPortPixel);
                var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                camera.calcViewMatrix(this.matrixView);
                camera.calcProjectMatrix(asp, this.matrixProject);
                egret3d.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getPosition();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
                this.version++;
            };
            RenderContext.prototype.updateLights = function (lights) {
                this.intLightCount = lights.length;
                var dirt = egret3d.math.Pool.new_vector3();
                for (var i = 0; i < lights.length; i++) {
                    var pos = lights[i].gameObject.transform.getPosition();
                    this.vec4LightPos[i * 4 + 0] = pos.x;
                    this.vec4LightPos[i * 4 + 1] = pos.y;
                    this.vec4LightPos[i * 4 + 2] = pos.z;
                    this.vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                    lights[i].gameObject.transform.getForward(dirt);
                    this.vec4LightDir[i * 4 + 0] = dirt.x;
                    this.vec4LightDir[i * 4 + 1] = dirt.y;
                    this.vec4LightDir[i * 4 + 2] = dirt.z;
                    this.vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                    this.floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                }
                egret3d.math.Pool.delete_vector3(dirt);
                this.version++;
            };
            RenderContext.prototype.updateOverlay = function () {
                egret3d.math.matrixMakeIdentity(this.matrixModelViewProject);
                this.version++;
            };
            RenderContext.prototype.updateModel = function (model) {
                egret3d.math.matrixClone(model.getWorldMatrix(), this.matrixModel);
                egret3d.math.matrixMultiply(this.matrixView, this.matrixModel, this.matrixModelView);
                egret3d.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
                this.version++;
            };
            RenderContext.prototype.updateModeTrail = function () {
                egret3d.math.matrixClone(this.matrixView, this.matrixModelView);
                egret3d.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
                this.version++;
            };
            RenderContext.prototype.updateBones = function (data) {
                this.boneData = data;
                this.version++;
            };
            return RenderContext;
        }());
        framework.RenderContext = RenderContext;
        __reflect(RenderContext.prototype, "egret3d.framework.RenderContext");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var RenderLayer = (function () {
            function RenderLayer(_sort) {
                if (_sort === void 0) { _sort = false; }
                this.needSort = false;
                this.list = [];
                this.needSort = _sort;
            }
            return RenderLayer;
        }());
        framework.RenderLayer = RenderLayer;
        __reflect(RenderLayer.prototype, "egret3d.framework.RenderLayer");
        var RenderList = (function () {
            function RenderList() {
                this.renderLayers = [];
                var common = new RenderLayer();
                var transparent = new RenderLayer(true);
                var ui = new RenderLayer(true);
                var overlay = new RenderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(ui);
                this.renderLayers.push(overlay);
            }
            RenderList.prototype.clear = function () {
                for (var i = 0; i < this.renderLayers.length; i++) {
                    this.renderLayers[i].list.length = 0;
                }
            };
            RenderList.prototype.addRenderer = function (renderer) {
                var list;
                if (renderer.layer == framework.RenderLayerEnum.Common) {
                    list = this.renderLayers[0].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.Transparent) {
                    list = this.renderLayers[1].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.UI) {
                    list = this.renderLayers[2].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.Overlay) {
                    list = this.renderLayers[3].list;
                }
                list.push(renderer);
            };
            RenderList.prototype.removeRenderer = function (renderer) {
                var list;
                if (renderer.layer == framework.RenderLayerEnum.Common) {
                    list = this.renderLayers[0].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.Transparent) {
                    list = this.renderLayers[1].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.UI) {
                    list = this.renderLayers[2].list;
                }
                else if (renderer.layer == framework.RenderLayerEnum.Overlay) {
                    list = this.renderLayers[3].list;
                }
                for (var i = 0; i < list.length; i++) {
                    if (list[i] == renderer) {
                        list.splice(i, 1);
                    }
                }
            };
            return RenderList;
        }());
        framework.RenderList = RenderList;
        __reflect(RenderList.prototype, "egret3d.framework.RenderList");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Scene = (function () {
            function Scene(app) {
                this.renderCameras = [];
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = [];
                this.lightmaps = [];
                this.app = app;
                this.webgl = app.webgl;
                this.rootNode = new framework.Transform();
                this.rootNode._scene = this;
                this.renderList = new framework.RenderList();
            }
            Object.defineProperty(Scene.prototype, "mainCamera", {
                get: function () {
                    if (this._mainCamera == null) {
                        this._mainCamera = this.renderCameras[0];
                    }
                    return this._mainCamera;
                },
                set: function (_camera) {
                    for (var i in this.renderCameras) {
                        if (this.renderCameras[i] == _camera) {
                            this._mainCamera = _camera;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Scene.prototype.update = function (delta) {
                this.renderCameras.length = 0;
                this.renderLights.length = 0;
                this.updateGameObject(this.rootNode, delta, !this.app.bePlay);
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }
                var sceneRendered = false;
                for (var i = 0; i < this.renderCameras.length; i++) {
                    sceneRendered = this._renderCamera(i) || sceneRendered;
                }
                if (!sceneRendered) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                }
            };
            Scene.prototype._renderScene = function (cam, context) {
                context.updateCamera(this.app, cam);
                context.updateLights(this.renderLights);
                cam.renderScene(this, context);
            };
            Scene.prototype._renderOverLay = function (cam, context) {
                var overLays = cam.getOverLays();
                for (var i = 0; i < overLays.length; i++) {
                    if (cam.CullingMask & framework.CullingMask.UI) {
                        overLays[i].render(context, cam);
                    }
                }
            };
            Scene.prototype._renderCamera = function (camindex) {
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                var cameraName = cam.gameObject.transform.name.toLowerCase();
                var sceneRendered = false;
                if (this.app.bePlay && cameraName.indexOf("editor") < 0) {
                    this._renderScene(cam, context);
                    sceneRendered = true;
                    this._renderOverLay(cam, context);
                }
                else if (!this.app.bePlay && cameraName.indexOf("editor") >= 0) {
                    this._renderScene(cam, context);
                    sceneRendered = true;
                    if (this.app.be2dstate) {
                        this._renderOverLay(cam, context);
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        this._renderOverLay(cam, context);
                    }
                }
                return sceneRendered;
            };
            Scene.prototype.updateGameObject = function (node, delta, forEditor) {
                if (forEditor === void 0) { forEditor = false; }
                if (!node.hasComponent && !node.hasComponentChild) {
                    return;
                }
                node.gameObject.init();
                if (node.gameObject.components.length > 0) {
                    if (forEditor) {
                        var renderer = node.gameObject.renderer;
                        if (renderer != null) {
                            renderer.update(delta);
                        }
                        var camera = node.gameObject.camera;
                        if (camera != null) {
                            camera.update(delta);
                        }
                    }
                    else {
                        node.gameObject.update(delta);
                    }
                    this.collectCameraAndLight(node);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.updateGameObject(node.children[i], delta, forEditor);
                    }
                }
            };
            Scene.prototype.collectCameraAndLight = function (node) {
                var camera = node.gameObject.camera;
                if (camera != null) {
                    this.renderCameras.push(camera);
                }
                while (this.renderContext.length < this.renderCameras.length) {
                    this.renderContext.push(new framework.RenderContext(this.webgl));
                }
                var light = node.gameObject.light;
                if (light != null) {
                    this.renderLights.push(light);
                }
            };
            Scene.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            Scene.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            Scene.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            Scene.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            Scene.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            Scene.prototype.getChildByName = function (name) {
                var res = this.rootNode.find(name);
                return res;
            };
            Scene.prototype.getRoot = function () {
                return this.rootNode;
            };
            Scene.prototype.pickAll = function (ray, isPickMesh) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                var picked = this.doPick(ray, true, isPickMesh);
                if (picked == null)
                    return null;
                return picked;
            };
            Scene.prototype.pick = function (ray, isPickMesh) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                var pickinfo = this.doPick(ray, false, isPickMesh);
                if (pickinfo == null)
                    return null;
                return pickinfo;
            };
            Scene.prototype.doPick = function (ray, pickall, isPickMesh) {
                if (pickall === void 0) { pickall = false; }
                if (isPickMesh === void 0) { isPickMesh = false; }
                var pickedList = new Array();
                if (isPickMesh) {
                    this.pickMesh(ray, this.getRoot(), pickedList);
                }
                else {
                    this.pickCollider(ray, this.getRoot(), pickedList);
                }
                if (pickedList.length == 0)
                    return null;
                if (pickall) {
                    return pickedList;
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    return pickedList[index];
                }
            };
            Scene.prototype.pickMesh = function (ray, tran, pickedList) {
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    var meshFilter = tran.gameObject.getComponent("MeshFilter");
                    if (meshFilter != null) {
                        var mesh = meshFilter.getMeshOutput();
                        var pickinfo = mesh.intersects(ray, tran.getWorldMatrix());
                        if (pickinfo) {
                            pickedList.push(pickinfo);
                            pickinfo.pickedtran = tran;
                        }
                    }
                    else {
                        var skinmesh = tran.gameObject.getComponent("SkinnedMeshRenderer");
                        if (skinmesh != null) {
                            var pickinfo = skinmesh.intersects(ray);
                            if (pickinfo) {
                                pickedList.push(pickinfo);
                                pickinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickMesh(ray, tran.children[i], pickedList);
                    }
                }
            };
            Scene.prototype.pickCollider = function (ray, tran, pickedList) {
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    if (tran.gameObject.collider != null) {
                        var pickinfo = ray.intersectCollider(tran);
                        if (pickinfo) {
                            pickedList.push(pickinfo);
                            pickinfo.pickedtran = tran;
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickCollider(ray, tran.children[i], pickedList);
                    }
                }
            };
            return Scene;
        }());
        framework.Scene = Scene;
        __reflect(Scene.prototype, "egret3d.framework.Scene");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var tmpVecA = new egret3d.math.Vector3();
        var tmpVecB = new egret3d.math.Vector3();
        var tmpVecC = new egret3d.math.Vector3();
        var tmpVecD = new egret3d.math.Vector3();
        var tmpVecE = new egret3d.math.Vector3();
        var Aabb = (function () {
            function Aabb(_minimum, _maximum) {
                this.minimum = new egret3d.math.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this.maximum = new egret3d.math.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                this._dirtyCenter = true;
                this._dirtyRadius = true;
                this.srcmin = new egret3d.math.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this.srcmax = new egret3d.math.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                this._center = new egret3d.math.Vector3();
                if (_minimum) {
                    egret3d.math.vec3Clone(_minimum, this.srcmin);
                    egret3d.math.vec3Clone(_minimum, this.minimum);
                }
                if (_maximum) {
                    egret3d.math.vec3Clone(_maximum, this.srcmax);
                    egret3d.math.vec3Clone(_maximum, this.maximum);
                }
            }
            Aabb.prototype.update = function (worldmatrix) {
                egret3d.math.matrixGetTranslation(worldmatrix, tmpVecA);
                egret3d.math.matrixGetTranslation(worldmatrix, tmpVecB);
                if (worldmatrix.rawData[0] > 0) {
                    tmpVecA.x += worldmatrix.rawData[0] * this.srcmin.x;
                    tmpVecB.x += worldmatrix.rawData[0] * this.srcmax.x;
                }
                else {
                    tmpVecA.x += worldmatrix.rawData[0] * this.srcmax.x;
                    tmpVecB.x += worldmatrix.rawData[0] * this.srcmin.x;
                }
                if (worldmatrix.rawData[1] > 0) {
                    tmpVecA.y += worldmatrix.rawData[1] * this.srcmin.y;
                    tmpVecB.y += worldmatrix.rawData[1] * this.srcmax.y;
                }
                else {
                    tmpVecA.y += worldmatrix.rawData[1] * this.srcmax.y;
                    tmpVecB.y += worldmatrix.rawData[1] * this.srcmin.y;
                }
                if (worldmatrix.rawData[2] > 0) {
                    tmpVecA.z += worldmatrix.rawData[2] * this.srcmin.z;
                    tmpVecB.z += worldmatrix.rawData[2] * this.srcmax.z;
                }
                else {
                    tmpVecA.z += worldmatrix.rawData[2] * this.srcmax.z;
                    tmpVecB.z += worldmatrix.rawData[2] * this.srcmin.z;
                }
                if (worldmatrix.rawData[4] > 0) {
                    tmpVecA.x += worldmatrix.rawData[4] * this.srcmin.x;
                    tmpVecB.x += worldmatrix.rawData[4] * this.srcmax.x;
                }
                else {
                    tmpVecA.x += worldmatrix.rawData[4] * this.srcmax.x;
                    tmpVecB.x += worldmatrix.rawData[4] * this.srcmin.x;
                }
                if (worldmatrix.rawData[5] > 0) {
                    tmpVecA.y += worldmatrix.rawData[5] * this.srcmin.y;
                    tmpVecB.y += worldmatrix.rawData[5] * this.srcmax.y;
                }
                else {
                    tmpVecA.y += worldmatrix.rawData[5] * this.srcmax.y;
                    tmpVecB.y += worldmatrix.rawData[5] * this.srcmin.y;
                }
                if (worldmatrix.rawData[6] > 0) {
                    tmpVecA.z += worldmatrix.rawData[6] * this.srcmin.z;
                    tmpVecB.z += worldmatrix.rawData[6] * this.srcmax.z;
                }
                else {
                    tmpVecA.z += worldmatrix.rawData[6] * this.srcmax.z;
                    tmpVecB.z += worldmatrix.rawData[6] * this.srcmin.z;
                }
                if (worldmatrix.rawData[8] > 0) {
                    tmpVecA.x += worldmatrix.rawData[8] * this.srcmin.x;
                    tmpVecB.x += worldmatrix.rawData[8] * this.srcmax.x;
                }
                else {
                    tmpVecA.x += worldmatrix.rawData[8] * this.srcmax.x;
                    tmpVecB.x += worldmatrix.rawData[8] * this.srcmin.x;
                }
                if (worldmatrix.rawData[9] > 0) {
                    tmpVecA.y += worldmatrix.rawData[9] * this.srcmin.y;
                    tmpVecB.y += worldmatrix.rawData[9] * this.srcmax.y;
                }
                else {
                    tmpVecA.y += worldmatrix.rawData[9] * this.srcmax.y;
                    tmpVecB.y += worldmatrix.rawData[9] * this.srcmin.y;
                }
                if (worldmatrix.rawData[10] > 0) {
                    tmpVecA.z += worldmatrix.rawData[10] * this.srcmin.z;
                    tmpVecB.z += worldmatrix.rawData[10] * this.srcmax.z;
                }
                else {
                    tmpVecA.z += worldmatrix.rawData[10] * this.srcmax.z;
                    tmpVecB.z += worldmatrix.rawData[10] * this.srcmin.z;
                }
                egret3d.math.vec3Clone(tmpVecA, this.minimum);
                egret3d.math.vec3Clone(tmpVecB, this.maximum);
                this._dirtyCenter = true;
                this._dirtyRadius = true;
            };
            Aabb.prototype.addVector3 = function (vec) {
                egret3d.math.vec3Max(this.maximum, vec, this.maximum);
                egret3d.math.vec3Min(this.minimum, vec, this.minimum);
                this._dirtyCenter = true;
                this._dirtyRadius = true;
            };
            Aabb.prototype.containsVector3 = function (vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            };
            Aabb.prototype.intersectAABB = function (aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            };
            Aabb.prototype.intersectPlane = function (v0, v1, v2) {
                var subV0 = tmpVecA;
                var subV1 = tmpVecB;
                var cross = tmpVecC;
                var hitPoint = tmpVecD;
                var distVec = tmpVecE;
                var center = this.center;
                egret3d.math.vec3Subtract(v1, v0, subV0);
                egret3d.math.vec3Subtract(v2, v1, subV1);
                egret3d.math.vec3Cross(subV0, subV1, cross);
                egret3d.math.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
                egret3d.math.vec3Subtract(hitPoint, center, distVec);
                var val = egret3d.math.vec3Dot(cross, distVec);
                if (val <= 0) {
                    return true;
                }
                var dist = egret3d.math.vec3Distance(center, hitPoint);
                if (dist < this.radius) {
                    return true;
                }
                return false;
            };
            Aabb.prototype.addAABB = function (aabb) {
                if (aabb != null) {
                    egret3d.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    egret3d.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                    this._dirtyCenter = true;
                    this._dirtyRadius = true;
                }
            };
            Object.defineProperty(Aabb.prototype, "center", {
                get: function () {
                    if (this._dirtyCenter) {
                        egret3d.math.vec3Add(this.maximum, this.minimum, this._center);
                        egret3d.math.vec3ScaleByNum(this._center, 0.5, this._center);
                        this._dirtyCenter = false;
                    }
                    return this._center;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Aabb.prototype, "radius", {
                get: function () {
                    if (this._dirtyRadius) {
                        egret3d.math.vec3Subtract(this.maximum, this.minimum, tmpVecA);
                        egret3d.math.vec3ScaleByNum(tmpVecA, 0.5, tmpVecA);
                        this._dirtyRadius = false;
                    }
                    return egret3d.math.vec3Length(tmpVecA);
                },
                enumerable: true,
                configurable: true
            });
            Aabb.prototype.clear = function () {
                egret3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                egret3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
                this._dirtyCenter = true;
                this._dirtyRadius = true;
            };
            Aabb.prototype.clone = function () {
                var aabb = new egret3d.framework.Aabb(this.minimum, this.maximum);
                return aabb;
            };
            Aabb.prototype.copy = function (aabb) {
                egret3d.math.vec3Clone(aabb.minimum, this.minimum);
                egret3d.math.vec3Clone(aabb.maximum, this.maximum);
                this._dirtyCenter = true;
                this._dirtyRadius = true;
                return this;
            };
            Aabb.prototype.getVec3 = function (vecs) {
                vecs[0] = egret3d.math.Pool.clone_vector3(this.minimum);
                vecs[1] = egret3d.math.Pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = egret3d.math.Pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = egret3d.math.Pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = egret3d.math.Pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = egret3d.math.Pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = egret3d.math.Pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = egret3d.math.Pool.clone_vector3(this.maximum);
            };
            return Aabb;
        }());
        framework.Aabb = Aabb;
        __reflect(Aabb.prototype, "egret3d.framework.Aabb");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Obb = (function () {
            function Obb() {
                this.vectors = new Array();
            }
            Obb.prototype.buildByMaxMin = function (minimum, maximum) {
                this.vectors[0] = egret3d.math.Pool.clone_vector3(minimum);
                this.vectors[1] = egret3d.math.Pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = egret3d.math.Pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = egret3d.math.Pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = egret3d.math.Pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = egret3d.math.Pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = egret3d.math.Pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = egret3d.math.Pool.clone_vector3(maximum);
                this.center = new egret3d.math.Vector3();
                egret3d.math.vec3Add(maximum, minimum, this.center);
                egret3d.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new egret3d.math.Vector3();
                egret3d.math.vec3Subtract(maximum, minimum, this.halfsize);
                egret3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this.directions = [new egret3d.math.Vector3(), new egret3d.math.Vector3(), new egret3d.math.Vector3()];
            };
            Obb.prototype.buildByCenterSize = function (center, size) {
                this.center = egret3d.math.Pool.clone_vector3(center);
                this.halfsize = egret3d.math.Pool.clone_vector3(size);
                egret3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                var hsx = this.halfsize.x;
                var hsy = this.halfsize.y;
                var hsz = this.halfsize.z;
                var cenx = this.center.x;
                var ceny = this.center.y;
                var cenz = this.center.z;
                this.vectors[0] = new egret3d.math.Vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new egret3d.math.Vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new egret3d.math.Vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new egret3d.math.Vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new egret3d.math.Vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new egret3d.math.Vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new egret3d.math.Vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new egret3d.math.Vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this.directions = [new egret3d.math.Vector3(), new egret3d.math.Vector3(), new egret3d.math.Vector3()];
            };
            Obb.prototype.update = function (worldmatrix) {
                egret3d.math.matrixGetTranslation(worldmatrix, this.center);
                egret3d.math.matrixGetVector3ByOffset(worldmatrix, 0, this.directions[0]);
                egret3d.math.matrixGetVector3ByOffset(worldmatrix, 4, this.directions[1]);
                egret3d.math.matrixGetVector3ByOffset(worldmatrix, 8, this.directions[2]);
            };
            Obb.prototype.caclWorldVecs = function (vecs, worldmatrix) {
                for (var index = 0; index < this.vectors.length; index++) {
                    vecs[index] = new egret3d.math.Vector3();
                    egret3d.math.matrixTransformVector3(this.vectors[index], worldmatrix, vecs[index]);
                }
            };
            Obb.prototype.intersects = function (obb) {
                if (obb == null)
                    return false;
                var box0 = this;
                var box1 = obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[2], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[2], box0, box1))
                    return false;
                var crossresult = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Cross(box0.directions[0], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[0], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[0], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[1], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[1], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[1], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[2], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[2], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                egret3d.math.vec3Cross(box0.directions[2], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                return true;
            };
            Obb.prototype.computeBoxExtents = function (axis, box) {
                var p = egret3d.math.vec3Dot(box.center, axis);
                var r0 = Math.abs(egret3d.math.vec3Dot(box.directions[0], axis)) * box.halfsize.x;
                var r1 = Math.abs(egret3d.math.vec3Dot(box.directions[1], axis)) * box.halfsize.y;
                var r2 = Math.abs(egret3d.math.vec3Dot(box.directions[2], axis)) * box.halfsize.z;
                var r = r0 + r1 + r2;
                var result = egret3d.math.Pool.new_vector3();
                result.x = p - r;
                result.y = p + r;
                return result;
            };
            Obb.prototype.axisOverlap = function (axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            };
            Obb.prototype.extentsOverlap = function (min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            };
            Obb.prototype.clone = function () {
                var _obb = new Obb();
                _obb.center = egret3d.math.Pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (var key in this.directions) {
                    _obb.directions[key] = egret3d.math.Pool.clone_vector3(this.directions[key]);
                }
                return _obb;
            };
            Obb.prototype.dispose = function () {
                this.vectors.length = 0;
                this.directions.length = 0;
            };
            return Obb;
        }());
        framework.Obb = Obb;
        __reflect(Obb.prototype, "egret3d.framework.Obb");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Pickinfo = (function () {
            function Pickinfo(_bu, _bv, _distance) {
                this.hitposition = new egret3d.math.Vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            return Pickinfo;
        }());
        framework.Pickinfo = Pickinfo;
        __reflect(Pickinfo.prototype, "egret3d.framework.Pickinfo");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var Ray = (function () {
            function Ray(origin, dir) {
                this.origin = egret3d.math.Pool.clone_vector3(origin);
                this.direction = egret3d.math.Pool.clone_vector3(dir);
            }
            Ray.prototype.intersectAABB = function (aabb) {
                return this.intersectBoxMinMax(aabb.minimum, aabb.maximum);
            };
            Ray.prototype.intersectPlaneTransform = function (tran) {
                var pickinfo = null;
                var panelpoint = tran.getPosition();
                var forward = egret3d.math.Pool.new_vector3();
                tran.getForward(forward);
                var hitposition = this.intersectPlane(panelpoint, forward);
                if (hitposition) {
                    pickinfo = new egret3d.framework.Pickinfo(0, 0, 0);
                    pickinfo.hitposition = hitposition;
                    pickinfo.distance = egret3d.math.vec3Distance(pickinfo.hitposition, this.origin);
                }
                egret3d.math.Pool.delete_vector3(forward);
                return pickinfo;
            };
            Ray.prototype.intersectPlane = function (planePoint, planeNormal) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return null;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    return new egret3d.math.Vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
                }
            };
            Ray.prototype.intersectCollider = function (tran) {
                var _collider = tran.gameObject.collider;
                var pickinfo = null;
                if (_collider instanceof framework.BoxCollider) {
                    var obb = _collider.getBound();
                    if (!obb)
                        return null;
                    var vecs = [];
                    obb.caclWorldVecs(vecs, _collider.gameObject.transform.getWorldMatrix());
                    var data = egret3d.render.MeshData.genBoxByArray(vecs);
                    for (var index = 0; index < data.pos.length; index += 3) {
                        var p0 = data.pos[data.trisindex[index]];
                        var p1 = data.pos[data.trisindex[index + 1]];
                        var p2 = data.pos[data.trisindex[index + 2]];
                        var result = this.intersectsTriangle(p0, p1, p2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                var tdir = egret3d.math.Pool.new_vector3();
                                egret3d.math.vec3ScaleByNum(this.direction, result.distance, tdir);
                                egret3d.math.vec3Add(this.origin, tdir, pickinfo.hitposition);
                                egret3d.math.Pool.delete_vector3(tdir);
                            }
                        }
                    }
                }
                else if (_collider instanceof framework.MeshCollider) {
                    var mesh = _collider.getBound();
                    if (mesh != null) {
                        pickinfo = mesh.intersects(this, tran.getWorldMatrix());
                    }
                }
                else if (_collider instanceof framework.CanvasRenderer) {
                    pickinfo = this.intersectPlaneTransform(tran);
                }
                return pickinfo;
            };
            Ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            };
            Ray.prototype.intersectsSphere = function (center, radius) {
                var center_ori = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = egret3d.math.vec3Dot(this.direction, center_ori);
                if (raydist < 0)
                    return false;
                var orilen2 = egret3d.math.vec3SqrLength(center_ori);
                egret3d.math.Pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                if (orilen2 < rad2)
                    return true;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            };
            Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
                var _edge1 = egret3d.math.Pool.new_vector3();
                var _edge2 = egret3d.math.Pool.new_vector3();
                var _pvec = egret3d.math.Pool.new_vector3();
                var _tvec = egret3d.math.Pool.new_vector3();
                var _qvec = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(vertex1, vertex0, _edge1);
                egret3d.math.vec3Subtract(vertex2, vertex0, _edge2);
                egret3d.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = egret3d.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return null;
                }
                var invdet = 1 / det;
                egret3d.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = egret3d.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return null;
                }
                egret3d.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = egret3d.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return null;
                }
                var distance = egret3d.math.vec3Dot(_edge2, _qvec) * invdet;
                egret3d.math.Pool.delete_vector3(_edge1);
                egret3d.math.Pool.delete_vector3(_edge2);
                egret3d.math.Pool.delete_vector3(_pvec);
                egret3d.math.Pool.delete_vector3(_tvec);
                egret3d.math.Pool.delete_vector3(_qvec);
                return new framework.Pickinfo(bu, bv, distance);
            };
            return Ray;
        }());
        framework.Ray = Ray;
        __reflect(Ray.prototype, "egret3d.framework.Ray");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var InsID = (function () {
            function InsID() {
                this._id = InsID.idAll++;
            }
            InsID.prototype.getInsID = function () {
                return this._id;
            };
            InsID.idAll = 1;
            return InsID;
        }());
        framework.InsID = InsID;
        __reflect(InsID.prototype, "egret3d.framework.InsID");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var helpVec3 = new egret3d.math.Vector3();
        var helpVec3_2 = new egret3d.math.Vector3();
        var helpMat4 = new egret3d.math.Matrix();
        var helpQuat4 = new egret3d.math.Quaternion();
        var helpQuat4_2 = new egret3d.math.Quaternion();
        var helpVector = new egret3d.math.Vector3();
        var helpRotation = new egret3d.math.Quaternion();
        var helpUp = new egret3d.math.Vector3(0, 1, 0);
        var helpRight = new egret3d.math.Vector3(1, 0, 0);
        var helpFoward = new egret3d.math.Vector3(0, 0, 1);
        var Transform = (function () {
            function Transform() {
                this.insId = new framework.InsID();
                this.name = "NoName";
                this.children = [];
                this._beDispose = false;
                this._dirtyAABB = true;
                this._dirtyLocal = true;
                this.localMatrix = new egret3d.math.Matrix();
                this._dirtyWorld = true;
                this.worldMatrix = new egret3d.math.Matrix();
                this.localPosition = new egret3d.math.Vector3();
                this.localScale = new egret3d.math.Vector3(1, 1, 1);
                this.localRotation = new egret3d.math.Quaternion();
                this.localEulerAngles = new egret3d.math.Vector3();
                this.position = new egret3d.math.Vector3();
                this.scale = new egret3d.math.Vector3(1, 1, 1);
                this.rotation = new egret3d.math.Quaternion();
                this.eulerAngles = new egret3d.math.Vector3();
                this.hasComponent = false;
                this.hasComponentChild = false;
            }
            Transform_1 = Transform;
            Object.defineProperty(Transform.prototype, "gameObject", {
                get: function () {
                    if (this._gameObject == null) {
                        this._gameObject = new framework.GameObject();
                        this._gameObject.transform = this;
                    }
                    return this._gameObject;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "scene", {
                get: function () {
                    return this._scene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });
            Transform.prototype.$setScene = function (scene) {
                var renderer = this.gameObject.renderer;
                if (scene == null) {
                    if (this._scene && renderer) {
                        this._scene.renderList.removeRenderer(renderer);
                    }
                }
                else {
                    if (renderer) {
                        scene.renderList.addRenderer(renderer);
                    }
                }
                this._scene = scene;
                var i = this.children.length;
                while (i--) {
                    this.children[i].$setScene(scene);
                }
            };
            Transform.prototype.addChild = function (node) {
                if (node._parent != null) {
                    node._parent.removeChild(node);
                }
                this.children.push(node);
                node._parent = this;
                node.$setScene(this._scene);
                node._dirtify();
                if (node.hasComponent || node.hasComponentChild) {
                    this.markHaveComponent();
                }
            };
            Transform.prototype.addChildAt = function (node, index) {
                if (index < 0) {
                    return;
                }
                if (node._parent != null) {
                    node._parent.removeChild(node);
                }
                this.children.splice(index, 0, node);
                node._parent = this;
                node.$setScene(this._scene);
                node._dirtify();
                if (node.hasComponent || node.hasComponentChild) {
                    this.markHaveComponent();
                }
            };
            Transform.prototype.removeAllChild = function () {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            Transform.prototype.removeChild = function (node) {
                if (node._parent != this) {
                    return;
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    node._parent = null;
                    node.$setScene(null);
                    node._dirtify();
                }
            };
            Transform.prototype.find = function (name) {
                if (this.name == name) {
                    return this;
                }
                else {
                    for (var i in this.children) {
                        var res = this.children[i].find(name);
                        if (res != null) {
                            return res;
                        }
                    }
                }
                return null;
            };
            Transform.prototype.checkImpactTran = function (tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            };
            Transform.prototype.checkImpact = function () {
                var trans = new Array();
                this._doImpact(this.scene.getRoot(), trans);
                return trans;
            };
            Transform.prototype._doImpact = function (tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                for (var i = 0; i < tran.children.length; i++) {
                    this._doImpact(tran.children[i], impacted);
                }
            };
            Transform.prototype.clone = function () {
                return egret3d.io.cloneObj(this);
            };
            Object.defineProperty(Transform.prototype, "beDispose", {
                get: function () {
                    return this._beDispose;
                },
                enumerable: true,
                configurable: true
            });
            Transform.prototype.dispose = function () {
                if (this._beDispose)
                    return;
                for (var k in this.children) {
                    this.children[k].dispose();
                }
                this.removeAllChild();
                this._gameObject.dispose();
                this._beDispose = true;
            };
            Object.defineProperty(Transform.prototype, "aabb", {
                get: function () {
                    if (!this._aabb) {
                        this._aabb = this._buildAABB();
                    }
                    if (this._dirtyAABB) {
                        this._aabb.update(this.getWorldMatrix());
                        this._dirtyAABB = false;
                    }
                    return this._aabb;
                },
                enumerable: true,
                configurable: true
            });
            Transform.prototype._buildAABB = function () {
                var minimum = new egret3d.math.Vector3();
                var maximum = new egret3d.math.Vector3();
                var filter = this.gameObject.getComponent("MeshFilter");
                if (filter != null && filter.mesh != null) {
                    var meshdata = filter.mesh.data;
                    egret3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    egret3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        egret3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        egret3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                    }
                }
                else {
                    var skinmesh = this.gameObject.getComponent("SkinnedMeshRenderer");
                    if (skinmesh != null) {
                        var skinmeshdata = skinmesh.mesh.data;
                        egret3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        egret3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < skinmeshdata.pos.length; i++) {
                            egret3d.math.vec3Max(skinmeshdata.pos[i], maximum, maximum);
                            egret3d.math.vec3Min(skinmeshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                }
                var _aabb = new framework.Aabb(minimum, maximum);
                return _aabb;
            };
            Transform.prototype.getLocalMatrix = function () {
                if (this._dirtyLocal) {
                    egret3d.math.matrixMakeTransformRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                    this._dirtyLocal = false;
                }
                return this.localMatrix;
            };
            Transform.prototype.getWorldMatrix = function () {
                if (!this._dirtyLocal && !this._dirtyWorld) {
                    return this.worldMatrix;
                }
                if (this._parent) {
                    this._parent.getWorldMatrix();
                }
                this._sync();
                return this.worldMatrix;
            };
            Transform.prototype._sync = function () {
                if (this._dirtyLocal) {
                    egret3d.math.matrixMakeTransformRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                    this._dirtyLocal = false;
                }
                if (this._dirtyWorld) {
                    if (!this._parent) {
                        egret3d.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        egret3d.math.matrixMultiply(this._parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this._dirtyWorld = false;
                }
            };
            Transform.prototype._dirtify = function (local) {
                if (local === void 0) { local = false; }
                if ((!local || (local && this._dirtyLocal)) && this._dirtyWorld) {
                    return;
                }
                if (local) {
                    this._dirtyLocal = true;
                }
                if (!this._dirtyWorld) {
                    this._dirtyWorld = true;
                    var i = this.children.length;
                    while (i--) {
                        if (this.children[i]._dirtyWorld) {
                            continue;
                        }
                        this.children[i]._dirtify();
                    }
                }
                this._dirtyAABB = true;
            };
            Transform.prototype.getLocalPosition = function () {
                return this.localPosition;
            };
            Transform.prototype.setLocalPosition = function (p1, p2, p3) {
                if (p1 instanceof egret3d.math.Vector3) {
                    egret3d.math.vec3Clone(p1, this.localPosition);
                }
                else {
                    this.localPosition.x = p1;
                    this.localPosition.y = p2 || 0;
                    this.localPosition.z = p3 || 0;
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getLocalScale = function () {
                return this.localScale;
            };
            Transform.prototype.setLocalScale = function (p1, p2, p3) {
                if (p1 instanceof egret3d.math.Vector3) {
                    egret3d.math.vec3Clone(p1, this.localScale);
                }
                else {
                    this.localScale.x = p1;
                    this.localScale.y = p2 || 1;
                    this.localScale.z = p3 || 1;
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getLocalRotation = function () {
                return this.localRotation;
            };
            Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
                if (p1 instanceof egret3d.math.Quaternion) {
                    egret3d.math.vec3Clone(p1, this.localRotation);
                }
                else {
                    this.localRotation.x = p1;
                    this.localRotation.y = p2 || 0;
                    this.localRotation.z = p3 || 0;
                    this.localRotation.w = p4 || 1;
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getLocalEulerAngles = function () {
                egret3d.math.quatToEulerAngles(this.localRotation, this.localEulerAngles);
                return this.localEulerAngles;
            };
            Transform.prototype.setLocalEulerAngles = function (p1, p2, p3) {
                if (p1 instanceof egret3d.math.Vector3) {
                    egret3d.math.quatFromEulerAngles(p1.x, p1.y, p1.z, this.localRotation);
                }
                else {
                    egret3d.math.quatFromEulerAngles(p1, p2, p3, this.localRotation);
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getPosition = function () {
                egret3d.math.matrixGetTranslation(this.getWorldMatrix(), this.position);
                return this.position;
            };
            Transform.prototype.setPosition = function (p1, p2, p3) {
                if (p1 instanceof egret3d.math.Vector3) {
                    egret3d.math.vec3Clone(p1, helpVec3);
                }
                else {
                    helpVec3.x = p1;
                    helpVec3.y = p2 || 0;
                    helpVec3.z = p3 || 0;
                }
                if (!this._parent) {
                    egret3d.math.vec3Clone(helpVec3, this.localPosition);
                }
                else {
                    egret3d.math.matrixInverse(this._parent.getWorldMatrix(), helpMat4);
                    egret3d.math.matrixTransformNormal(helpVec3, helpMat4, this.localPosition);
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getScale = function () {
                egret3d.math.matrixGetScale(this.getWorldMatrix(), this.scale);
                return this.scale;
            };
            Transform.prototype.setScale = function (p1, p2, p3) {
                if (p1 instanceof egret3d.math.Vector3) {
                    egret3d.math.vec3Clone(p1, helpVec3);
                }
                else {
                    helpVec3.x = p1;
                    helpVec3.y = p2 || 1;
                    helpVec3.z = p3 || 1;
                }
                if (!this._parent) {
                    egret3d.math.vec3Clone(helpVec3, this.localScale);
                }
                else {
                    egret3d.math.matrixInverse(this._parent.getWorldMatrix(), helpMat4);
                    egret3d.math.matrixTransformVector3(helpVec3, helpMat4, this.localScale);
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getRotation = function () {
                egret3d.math.setQuatFromMat4(this.getWorldMatrix(), this.rotation);
                return this.rotation;
            };
            Transform.prototype.setRotation = function (q1, q2, q3, q4) {
                if (q1 instanceof egret3d.math.Quaternion) {
                    egret3d.math.quatClone(q1, helpQuat4);
                }
                else {
                    helpQuat4.x = q1;
                    helpQuat4.y = q2 || 0;
                    helpQuat4.z = q3 || 0;
                    helpQuat4.w = q4 || 1;
                }
                if (!this._parent) {
                    egret3d.math.quatClone(helpQuat4, this.localRotation);
                }
                else {
                    var parentRot = this._parent.getRotation();
                    egret3d.math.quatInverse(parentRot, helpQuat4_2);
                    egret3d.math.quatMultiply(helpQuat4_2, helpQuat4, this.localRotation);
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.getEulerAngles = function () {
                egret3d.math.setEulerAnglesFromMat4(this.getWorldMatrix(), this.eulerAngles);
                return this.eulerAngles;
            };
            Transform.prototype.setEulerAngles = function (q1, q2, q3) {
                if (q1 instanceof egret3d.math.Vector3) {
                    egret3d.math.quatFromEulerAngles(q1.x, q1.y, q1.z, helpQuat4);
                }
                else {
                    egret3d.math.quatFromEulerAngles(q1, q2 || 0, q3 || 0, helpQuat4);
                }
                if (!this._parent) {
                    egret3d.math.quatClone(helpQuat4, this.localRotation);
                }
                else {
                    var parentRot = this._parent.getRotation();
                    egret3d.math.quatInverse(parentRot, helpQuat4_2);
                    egret3d.math.quatMultiply(helpQuat4_2, helpQuat4, this.localRotation);
                }
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            };
            Transform.prototype.lookAt = function (target) {
                if (target instanceof Transform_1) {
                    egret3d.math.vec3Clone(target.getPosition(), helpVector);
                }
                else {
                    egret3d.math.vec3Clone(target, helpVector);
                }
                egret3d.math.quatLookat(this.getPosition(), helpVector, helpRotation);
                this.setRotation(helpRotation);
            };
            Transform.prototype.getForward = function (out) {
                egret3d.math.matrixTransformNormal(helpFoward, this.getWorldMatrix(), out);
                egret3d.math.vec3Normalize(out, out);
            };
            Transform.prototype.getRight = function (out) {
                egret3d.math.matrixTransformNormal(helpRight, this.getWorldMatrix(), out);
                egret3d.math.vec3Normalize(out, out);
            };
            Transform.prototype.getUp = function (out) {
                egret3d.math.matrixTransformNormal(helpUp, this.getWorldMatrix(), out);
                egret3d.math.vec3Normalize(out, out);
            };
            Transform.prototype.markHaveComponent = function () {
                this.hasComponent = true;
                var p = this.parent;
                while (p != null) {
                    p.hasComponentChild = true;
                    p = p.parent;
                }
            };
            __decorate([
                egret3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], Transform.prototype, "name", void 0);
            __decorate([
                egret3d.reflect.Field("GameObject"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [])
            ], Transform.prototype, "gameObject", null);
            __decorate([
                egret3d.reflect.Field("Transform[]"),
                __metadata("design:type", Array)
            ], Transform.prototype, "children", void 0);
            __decorate([
                egret3d.reflect.Field("Vector3", new egret3d.math.Vector3(0, 0, 0)),
                __metadata("design:type", egret3d.math.Vector3)
            ], Transform.prototype, "localPosition", void 0);
            __decorate([
                egret3d.reflect.Field("vector3", new egret3d.math.Vector3(1, 1, 1)),
                __metadata("design:type", egret3d.math.Vector3)
            ], Transform.prototype, "localScale", void 0);
            __decorate([
                egret3d.reflect.Field("Quaternion"),
                __metadata("design:type", egret3d.math.Quaternion)
            ], Transform.prototype, "localRotation", void 0);
            Transform = Transform_1 = __decorate([
                egret3d.reflect.SerializeType
            ], Transform);
            return Transform;
            var Transform_1;
        }());
        framework.Transform = Transform;
        __reflect(Transform.prototype, "egret3d.framework.Transform");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var EnumUtil = (function () {
            function EnumUtil() {
            }
            EnumUtil.getEnumObjByType = function (enumType) {
                var index = enumType.indexOf("egret3d.framework.");
                if (index == 0) {
                    enumType = enumType.substr(15);
                }
                return eval("{result:" + enumType + "}");
            };
            return EnumUtil;
        }());
        framework.EnumUtil = EnumUtil;
        __reflect(EnumUtil.prototype, "egret3d.framework.EnumUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var NumberUtil = (function () {
            function NumberUtil() {
            }
            NumberUtil.KEY_A = 65;
            NumberUtil.KEY_D = 68;
            NumberUtil.KEY_E = 69;
            NumberUtil.KEY_Q = 81;
            NumberUtil.KEY_R = 82;
            NumberUtil.KEY_S = 83;
            NumberUtil.KEY_W = 87;
            return NumberUtil;
        }());
        framework.NumberUtil = NumberUtil;
        __reflect(NumberUtil.prototype, "egret3d.framework.NumberUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var RegexpUtil = (function () {
            function RegexpUtil() {
            }
            RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
            RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
            return RegexpUtil;
        }());
        framework.RegexpUtil = RegexpUtil;
        __reflect(RegexpUtil.prototype, "egret3d.framework.RegexpUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var StringUtil = (function () {
            function StringUtil() {
            }
            StringUtil.replaceAll = function (srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            };
            StringUtil.trimAll = function (str) {
                str += "";
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            };
            StringUtil.firstCharToLowerCase = function (str) {
                var firstChar = str.substr(0, 1).toLowerCase();
                var other = str.substr(1);
                return firstChar + other;
            };
            StringUtil.COMPONENT_CAMERA = "Camera";
            StringUtil.COMPONENT_BOXCOLLIDER = "BoxCollider";
            StringUtil.COMPONENT_LIGHT = "Light";
            StringUtil.COMPONENT_MESHFILTER = "MeshFilter";
            StringUtil.COMPONENT_MESHRENDER = "MeshRenderer";
            StringUtil.COMPONENT_EFFECTSYSTEM = "EffectSystem";
            StringUtil.COMPONENT_SKINMESHRENDER = "SkinnedMeshRenderer";
            StringUtil.COMPONENT_CAMERACONTROLLER = "CameraController";
            StringUtil.COMPONENT_CANVASRENDER = "CanvasRenderer";
            StringUtil.COMPONENT_LABEL = "Label";
            StringUtil.COMPONENT_IMAGE = "Image2D";
            StringUtil.COMPONENT_RAWIMAGE = "RawImage2D";
            StringUtil.COMPONENT_BUTTON = "button";
            StringUtil.UIStyle_RangeFloat = "rangeFloat";
            StringUtil.UIStyle_Enum = "enum";
            StringUtil.RESOURCES_MESH_CUBE = "cube";
            return StringUtil;
        }());
        framework.StringUtil = StringUtil;
        __reflect(StringUtil.prototype, "egret3d.framework.StringUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        var Primitive2DType;
        (function (Primitive2DType) {
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        var TransformUtil = (function () {
            function TransformUtil() {
            }
            TransformUtil.CreatePrimitive = function (type, app) {
                var objName = PrimitiveType[type];
                var trans = new framework.Transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("MeshFilter");
                var smesh = framework.AssetMap.find(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("MeshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.Material());
                renderer.materials[0].setShader(framework.DefaultShaders.Diffuse);
                return trans;
            };
            TransformUtil.Create2DPrimitive = function (type, app) {
                var objName = Primitive2DType[type];
                var componentName = framework.StringUtil.firstCharToLowerCase(objName);
                var t2d = new framework.Transform2D();
                t2d.name = objName;
                var i2dComp = t2d.addComponent(componentName);
                t2d.pivot.x = 0;
                t2d.pivot.y = 0;
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        TransformUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        TransformUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        TransformUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        TransformUtil.create2D_button(i2dComp, app);
                        break;
                }
                return t2d;
            };
            TransformUtil.create2D_rawImage = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = framework.DefaultTextures.White;
            };
            TransformUtil.create2D_image2D = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.setTexture(framework.DefaultTextures.White);
            };
            TransformUtil.create2D_label = function (label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 25;
                label.color = new egret3d.math.Color(1, 0, 0, 1);
            };
            TransformUtil.create2D_button = function (btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                var img = btn.transform.addComponent("Image2D");
                img.setTexture(framework.DefaultTextures.White);
                img.imageType = egret3d.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = egret3d.framework.TransitionType.ColorTint;
                var lab = new egret3d.framework.Transform2D();
                lab.name = "label";
                lab.width = 150;
                lab.height = 50;
                lab.pivot.x = 0;
                lab.pivot.y = 0;
                lab.localTranslate.y = -10;
                var label = lab.addComponent("Label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new egret3d.math.Color(1, 0, 0, 1);
                btn.transform.addChild(lab);
            };
            return TransformUtil;
        }());
        framework.TransformUtil = TransformUtil;
        __reflect(TransformUtil.prototype, "egret3d.framework.TransformUtil");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var math;
    (function (math) {
        var Pool = (function () {
            function Pool() {
            }
            Pool.collect_all = function () {
                Pool.collect_vector4();
                Pool.collect_vector3();
                Pool.collect_vector2();
                Pool.collect_matrix();
                Pool.collect_quaternion();
                Pool.collect_color();
            };
            Object.defineProperty(Pool, "vector4_one", {
                get: function () {
                    if (Pool._vector4_one == null) {
                        Pool._vector4_one = new math.Vector4(1, 1, 1, 1);
                    }
                    return Pool._vector4_one;
                },
                enumerable: true,
                configurable: true
            });
            Pool.new_vector4 = function () {
                if (Pool.unused_vector4.length > 0) {
                    return Pool.unused_vector4.pop();
                }
                else {
                    return new math.Vector4();
                }
            };
            Pool.clone_vector4 = function (src) {
                if (Pool.unused_vector4.length > 0) {
                    var v = Pool.unused_vector4.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else {
                    return new math.Vector4(src.x, src.y, src.z);
                }
            };
            Pool.delete_vector4 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    Pool.unused_vector4.push(v);
                }
                else {
                    console.error("this is not a vector4 type!");
                }
            };
            Pool.collect_vector4 = function () {
                Pool.unused_vector4.length = 0;
            };
            Object.defineProperty(Pool, "color_one", {
                get: function () {
                    if (Pool._color_one == null) {
                        Pool._color_one = new math.Color(1, 1, 1, 1);
                    }
                    return Pool._color_one;
                },
                enumerable: true,
                configurable: true
            });
            Pool.new_color = function () {
                if (Pool.unused_color.length > 0) {
                    return Pool.unused_color.pop();
                }
                else {
                    return new math.Color();
                }
            };
            Pool.delete_color = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    Pool.unused_color.push(v);
                }
                else {
                    console.error("this is not a color type!");
                }
            };
            Pool.collect_color = function () {
                Pool.unused_color.length = 0;
            };
            Object.defineProperty(Pool, "vector3_up", {
                get: function () {
                    if (Pool._vector3_up == null) {
                        Pool._vector3_up = new math.Vector3(0, 1, 0);
                    }
                    return Pool._vector3_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pool, "vector3_right", {
                get: function () {
                    if (Pool._vector3_right == null) {
                        Pool._vector3_right = new math.Vector3(1, 0, 0);
                    }
                    return Pool._vector3_right;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pool, "vector3_forward", {
                get: function () {
                    if (Pool._vector3_forward == null) {
                        Pool._vector3_forward = new math.Vector3(0, 0, 1);
                    }
                    return Pool._vector3_forward;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pool, "vector3_zero", {
                get: function () {
                    if (Pool._vector3_zero == null) {
                        Pool._vector3_zero = new math.Vector3(0, 0, 0);
                    }
                    return Pool._vector3_zero;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pool, "vector3_one", {
                get: function () {
                    if (Pool._vector3_one == null) {
                        Pool._vector3_one = new math.Vector3(1, 1, 1);
                    }
                    return Pool._vector3_one;
                },
                enumerable: true,
                configurable: true
            });
            Pool.new_vector3 = function () {
                if (Pool.unused_vector3.length > 0) {
                    var v = Pool.unused_vector3.pop();
                    return v;
                }
                else {
                    return new math.Vector3();
                }
            };
            Pool.clone_vector3 = function (src) {
                if (Pool.unused_vector3.length > 0) {
                    var v = Pool.unused_vector3.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    return v;
                }
                else {
                    return new math.Vector3(src.x, src.y, src.z);
                }
            };
            Pool.delete_vector3 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Vector3) {
                    v.x = v.y = v.z = 0;
                    Pool.unused_vector3.push(v);
                }
                else {
                    console.error("this is not a vector3 type!");
                }
            };
            Pool.collect_vector3 = function () {
                Pool.unused_vector3.length = 0;
            };
            Object.defineProperty(Pool, "vector2_up", {
                get: function () {
                    if (Pool._vector2_up == null) {
                        Pool._vector2_up = new math.Vector2(0, 1);
                    }
                    return Pool._vector2_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pool, "vector2_right", {
                get: function () {
                    if (Pool._vector2_right == null) {
                        Pool._vector2_right = new math.Vector2(1, 0);
                    }
                    return Pool._vector2_right;
                },
                enumerable: true,
                configurable: true
            });
            Pool.new_vector2 = function () {
                if (Pool.unused_vector2.length > 0) {
                    return Pool.unused_vector2.pop();
                }
                else {
                    return new math.Vector2();
                }
            };
            Pool.clone_vector2 = function (src) {
                if (Pool.unused_vector2.length > 0) {
                    var v = Pool.unused_vector2.pop();
                    v.x = src.x;
                    v.y = src.y;
                    return v;
                }
                else {
                    return new math.Vector2(src.x, src.y);
                }
            };
            Pool.delete_vector2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Vector2) {
                    v.x = v.y = 0;
                    Pool.unused_vector2.push(v);
                }
                else {
                    console.error("this is not a vector2 type!");
                }
            };
            Pool.delete_vector2Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        vs[i].x = vs[i].y = 0;
                        Pool.unused_vector2.push(vs[i]);
                    }
                }
                vs.length = 0;
            };
            Pool.collect_vector2 = function () {
                Pool.unused_vector2.length = 0;
            };
            Pool.new_matrix3x2 = function () {
                if (Pool.unused_matrix3x2.length > 0) {
                    return Pool.unused_matrix3x2.pop();
                }
                else {
                    return new math.Matrix3x2();
                }
            };
            Pool.clone_matrix3x2 = function (src) {
                var v = Pool.new_matrix();
                for (var i = 0; i < 6; i++) {
                    v.rawData[i] = src.rawData[i];
                }
                return v;
            };
            Pool.delete_matrix3x2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 1;
                    v.rawData[5] = 0;
                    Pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("this is not a Matrix3x2 type!");
                }
            };
            Pool.collect_matrix3x2 = function () {
                Pool.unused_matrix3x2.length = 0;
            };
            Pool.new_matrix = function () {
                if (Pool.unused_matrix.length > 0) {
                    return Pool.unused_matrix.pop();
                }
                else {
                    return new math.Matrix();
                }
            };
            Pool.clone_matrix = function (src) {
                var v = Pool.new_matrix();
                for (var i = 0; i < 16; i++) {
                    v.rawData[i] = src.rawData[i];
                }
                return v;
            };
            Pool.delete_matrix = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    Pool.unused_matrix.push(v);
                }
                else {
                    console.error("this is not a Matrix type!");
                }
            };
            Pool.collect_matrix = function () {
                Pool.unused_matrix.length = 0;
            };
            Pool.new_quaternion = function () {
                if (Pool.unused_quaternion.length > 0) {
                    return Pool.unused_quaternion.pop();
                }
                else {
                    return new math.Quaternion();
                }
            };
            Pool.clone_quaternion = function (src) {
                if (Pool.unused_quaternion.length > 0) {
                    var v = Pool.unused_quaternion.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else {
                    return new math.Quaternion(src.x, src.y, src.z, src.w);
                }
            };
            Pool.delete_quaternion = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.Quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    Pool.unused_quaternion.push(v);
                }
                else {
                    console.error("this is not a quaternion type!");
                }
            };
            Pool.collect_quaternion = function () {
                Pool.unused_quaternion.length = 0;
            };
            Pool.unused_vector4 = [];
            Pool.unused_color = [];
            Pool.unused_vector3 = [];
            Pool.unused_vector2 = [];
            Pool.unused_matrix3x2 = [];
            Pool.unused_matrix = [];
            Pool.unused_quaternion = [];
            return Pool;
        }());
        math.Pool = Pool;
        __reflect(Pool.prototype, "egret3d.math.Pool");
    })(math = egret3d.math || (egret3d.math = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        function getExtension(gl, name) {
            var browserPrefixes = [
                "",
                "MOZ_",
                "OP_",
                "WEBKIT_"
            ];
            for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                var prefixedName = browserPrefixes[ii] + name;
                var ext = gl.getExtension(prefixedName);
                if (ext) {
                    return ext;
                }
            }
            return null;
        }
        var Caps = (function () {
            function Caps() {
            }
            Caps.prototype.initialize = function (gl) {
                this.standardDerivatives = getExtension(gl, 'OES_standard_derivatives');
                this.pvrtcExtension = getExtension(gl, 'WEBGL_compressed_texture_pvrtc');
            };
            return Caps;
        }());
        render.Caps = Caps;
        __reflect(Caps.prototype, "egret3d.render.Caps");
        var Webglkit = (function () {
            function Webglkit() {
            }
            Webglkit.SetMaxVertexAttribArray = function (webgl, count) {
                for (var i = count; i < Webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                Webglkit._maxVertexAttribArray = count;
            };
            Webglkit.activeTexture = function (index) {
                if (this._activeTextureIndex != index) {
                    this.webgl.activeTexture(Webglkit._texNumber[index]);
                    this._activeTextureIndex = index;
                }
            };
            Webglkit.showFace = function (value) {
                if (this._showFace != value) {
                    var webgl = this.webgl;
                    if (value == render.ShowFaceStateEnum.ALL) {
                        webgl.disable(webgl.CULL_FACE);
                    }
                    else {
                        if (value == render.ShowFaceStateEnum.CCW) {
                            webgl.frontFace(webgl.CCW);
                        }
                        else {
                            webgl.frontFace(webgl.CW);
                        }
                        webgl.cullFace(webgl.BACK);
                        webgl.enable(webgl.CULL_FACE);
                    }
                    this._showFace = value;
                }
            };
            Webglkit.zWrite = function (value) {
                if (this._zWrite !== value) {
                    this.webgl.depthMask(value);
                    this._zWrite = value;
                }
            };
            Webglkit.zTest = function (value) {
                if (this._zTest !== value) {
                    var webgl = this.webgl;
                    if (value) {
                        webgl.enable(webgl.DEPTH_TEST);
                    }
                    else {
                        webgl.disable(webgl.DEPTH_TEST);
                    }
                    this._zTest = value;
                }
            };
            Webglkit.zTestMethod = function (value) {
                if (this._zTestMethod !== value) {
                    this.webgl.depthFunc(value);
                    this._zTestMethod = value;
                }
            };
            Webglkit.blend = function (value, equation, srcRGB, destRGB, srcAlpha, destAlpha) {
                var webgl = this.webgl;
                if (this._blend !== value) {
                    value ? webgl.enable(webgl.BLEND) : webgl.disable(webgl.BLEND);
                    this._blend = value;
                }
                if (value) {
                    webgl.blendEquation(equation);
                    webgl.blendFuncSeparate(srcRGB, destRGB, srcAlpha, destAlpha);
                }
            };
            Webglkit.useProgram = function (program) {
                if (this._program != program) {
                    this._program = program;
                    this.webgl.useProgram(program);
                    return true;
                }
                return false;
            };
            Webglkit.drawArrayTris = function (webgl, start, count) {
                render.DrawInfo.ins.triCount += count / 3;
                render.DrawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.TRIANGLES, start, count);
            };
            Webglkit.drawArrayLines = function (webgl, start, count) {
                render.DrawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.LINES, start, count);
            };
            Webglkit.drawElementTris = function (webgl, start, count) {
                render.DrawInfo.ins.triCount += count / 3;
                render.DrawInfo.ins.renderCount++;
                webgl.drawElements(webgl.TRIANGLES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            Webglkit.drawElementLines = function (webgl, start, count) {
                render.DrawInfo.ins.renderCount++;
                webgl.drawElements(webgl.LINES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            Webglkit.resetState = function () {
                this._activeTextureIndex = -1;
                this._showFace = undefined;
                this._zWrite = undefined;
                this._zTest = undefined;
                this._zTestMethod = undefined;
                this._blend = undefined;
                this._program = undefined;
            };
            Webglkit.initConst = function (webgl) {
                if (Webglkit._texNumber == null) {
                    this.webgl = webgl;
                    Webglkit._texNumber = [];
                    Webglkit._texNumber.push(webgl.TEXTURE0);
                    Webglkit._texNumber.push(webgl.TEXTURE1);
                    Webglkit._texNumber.push(webgl.TEXTURE2);
                    Webglkit._texNumber.push(webgl.TEXTURE3);
                    Webglkit._texNumber.push(webgl.TEXTURE4);
                    Webglkit._texNumber.push(webgl.TEXTURE5);
                    Webglkit._texNumber.push(webgl.TEXTURE6);
                    Webglkit._texNumber.push(webgl.TEXTURE7);
                    Webglkit._texNumber.push(webgl.TEXTURE8);
                    Webglkit._texNumber.push(webgl.TEXTURE9);
                    Webglkit.LEQUAL = webgl.LEQUAL;
                    Webglkit.NEVER = webgl.NEVER;
                    Webglkit.EQUAL = webgl.EQUAL;
                    Webglkit.GEQUAL = webgl.GEQUAL;
                    Webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    Webglkit.LESS = webgl.LESS;
                    Webglkit.GREATER = webgl.GREATER;
                    Webglkit.ALWAYS = webgl.ALWAYS;
                    Webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    Webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    Webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    Webglkit.ONE = webgl.ONE;
                    Webglkit.ZERO = webgl.ZERO;
                    Webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    Webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    Webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    Webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    Webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    Webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    this.caps.initialize(webgl);
                }
            };
            Webglkit._maxVertexAttribArray = 0;
            Webglkit._texNumber = null;
            Webglkit._activeTextureIndex = -1;
            Webglkit.caps = new Caps();
            return Webglkit;
        }());
        render.Webglkit = Webglkit;
        __reflect(Webglkit.prototype, "egret3d.render.Webglkit");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        var DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        var BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        var GlDrawPass = (function () {
            function GlDrawPass(vShaderInfo, fShaderInfo) {
                this.uniforms = {};
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.Webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
                this.vShaderInfo = vShaderInfo;
                this.fShaderInfo = fShaderInfo;
                for (var key in vShaderInfo.uniforms) {
                    this.uniforms[key] = vShaderInfo.uniforms[key];
                }
                for (var key in fShaderInfo.uniforms) {
                    this.uniforms[key] = fShaderInfo.uniforms[key];
                }
            }
            Object.defineProperty(GlDrawPass.prototype, "program", {
                get: function () {
                    if (!this._program) {
                        this._program = render.GlProgram.get(this.vShaderInfo, this.fShaderInfo);
                    }
                    return this._program;
                },
                enumerable: true,
                configurable: true
            });
            GlDrawPass.prototype.setAlphaBlend = function (mode) {
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_blendEquation = render.Webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.Webglkit.ONE;
                    this.state_blendSrcAlpha = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.Webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.Webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.Webglkit.ONE;
                    this.state_blendDestRGB = render.Webglkit.ONE;
                    this.state_blendSrcAlpha = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.Webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.Webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.Webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.Webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.Webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.Webglkit.ONE;
                    this.state_blendDestRGB = render.Webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.Webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.Webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            };
            GlDrawPass.prototype.use = function (webgl) {
                render.Webglkit.showFace(this.state_showface);
                render.Webglkit.zWrite(this.state_zwrite);
                render.Webglkit.zTest(this.state_ztest);
                render.Webglkit.blend(this.state_blend, this.state_blendEquation, this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                if (this.state_ztest) {
                    render.Webglkit.zTestMethod(this.state_ztest_method);
                }
                return render.Webglkit.useProgram(this.program.program);
            };
            return GlDrawPass;
        }());
        render.GlDrawPass = GlDrawPass;
        __reflect(GlDrawPass.prototype, "egret3d.render.GlDrawPass");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        var Number4 = (function () {
            function Number4() {
            }
            return Number4;
        }());
        render.Number4 = Number4;
        __reflect(Number4.prototype, "egret3d.render.Number4");
        var MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        var DrawInfo = (function () {
            function DrawInfo() {
            }
            Object.defineProperty(DrawInfo, "ins", {
                get: function () {
                    if (DrawInfo._ins == null)
                        DrawInfo._ins = new DrawInfo();
                    return DrawInfo._ins;
                },
                enumerable: true,
                configurable: true
            });
            return DrawInfo;
        }());
        render.DrawInfo = DrawInfo;
        __reflect(DrawInfo.prototype, "egret3d.render.DrawInfo");
        var GlMesh = (function () {
            function GlMesh() {
                this.vertexFormat = VertexFormatMask.Position;
                this.version = 0;
            }
            GlMesh.prototype.initBuffer = function (webgl, vf, vertexCount, mode) {
                if (mode === void 0) { mode = MeshTypeEnum.Static; }
                if (this.vbo != null) {
                    throw new Error("you can only initbuffer once.");
                }
                if (mode == MeshTypeEnum.Static) {
                    this.mode = webgl.STATIC_DRAW;
                }
                else if (mode == MeshTypeEnum.Dynamic) {
                    this.mode = webgl.DYNAMIC_DRAW;
                }
                else if (mode == MeshTypeEnum.Stream) {
                    this.mode = webgl.STREAM_DRAW;
                }
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.MeshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                this.indexCounts = [];
                this.ebos = [];
                this.version++;
            };
            GlMesh.prototype.addIndex = function (webgl, indexcount) {
                var index = this.ebos.length;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.ebos.push(_ebo);
                this.indexCounts.push(indexcount);
                this.version++;
                return index;
            };
            GlMesh.prototype.resetVboSize = function (webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                this.version++;
            };
            GlMesh.prototype.resetEboSize = function (webgl, eboindex, indexcount) {
                this.indexCounts[eboindex] = indexcount;
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.version++;
            };
            GlMesh.prototype.dispose = function (webgl) {
                webgl.deleteBuffer(this.vbo);
                this.vbo = null;
                if (this.ebos) {
                    for (var i = 0; i < this.ebos.length; i++)
                        webgl.deleteBuffer(this.ebos[i]);
                    this.ebos.length = 0;
                }
                this.version++;
            };
            GlMesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.vertexByteSize * this.vertexCount;
                for (var k in this.indexCounts) {
                    total += this.indexCounts[k] * 2;
                }
                return total;
            };
            GlMesh.prototype.uploadVertexSubData = function (webgl, letray, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, letray);
                this.version++;
            };
            GlMesh.prototype.uploadIndexSubData = function (webgl, eboindex, data, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
                this.version++;
            };
            return GlMesh;
        }());
        render.GlMesh = GlMesh;
        __reflect(GlMesh.prototype, "egret3d.render.GlMesh");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var MeshData = (function () {
            function MeshData() {
            }
            MeshData.addQuadPos = function (data, quad) {
                var istart = data.pos.length;
                MeshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            };
            MeshData.addQuadPos_Quad = function (data, quad) {
                var istart = data.pos.length;
                MeshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            };
            MeshData.addQuadVec3ByValue = function (array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = egret3d.math.Pool.clone_vector3(value);
                    array.push(v);
                }
            };
            MeshData.addQuadVec3 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            MeshData.addQuadVec2 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            MeshData.genQuad = function (size) {
                var half = size * 0.5;
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, half, 0),
                    new egret3d.math.Vector3(-half, -half, 0),
                    new egret3d.math.Vector3(half, half, 0),
                    new egret3d.math.Vector3(half, -half, 0)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1)
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                return data;
            };
            MeshData.genQuad_forparticle = function (size) {
                var half = size * 0.5;
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(0, half, 0),
                    new egret3d.math.Vector3(0, -half, 0),
                    new egret3d.math.Vector3(2 * half, half, 0),
                    new egret3d.math.Vector3(2 * half, -half, 0)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1)
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                return data;
            };
            MeshData.genPlaneCCW = function (size) {
                var half = size * 0.5;
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 1, 0));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, 0, half),
                    new egret3d.math.Vector3(-half, 0, -half),
                    new egret3d.math.Vector3(half, 0, half),
                    new egret3d.math.Vector3(half, 0, -half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1)
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                return data;
            };
            MeshData.genCylinderCCW = function (height, radius, segment) {
                if (segment === void 0) { segment = 20; }
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new egret3d.math.Vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new egret3d.math.Vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new egret3d.math.Vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new egret3d.math.Vector3(x, 0, z);
                        data.pos.push(new egret3d.math.Vector3(x * radius, y, z * radius));
                        var vn = egret3d.math.Pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new egret3d.math.Vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new egret3d.math.Vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new egret3d.math.Vector3(0, 0.5 * height, 0));
                data.normal.push(new egret3d.math.Vector3(0, 1, 0));
                data.uv.push(new egret3d.math.Vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new egret3d.math.Vector3(0, -0.5 * height, 0));
                data.normal.push(new egret3d.math.Vector3(0, -1, 0));
                data.uv.push(new egret3d.math.Vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            };
            MeshData.genPyramid = function (height, halfsize) {
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new egret3d.math.Vector3();
                var vec2 = new egret3d.math.Vector3();
                var vec3 = new egret3d.math.Vector3();
                var vec4 = new egret3d.math.Vector3();
                var vec5 = new egret3d.math.Vector3(0, -1, 0);
                var uvxx = new egret3d.math.Vector2(0.5, 0.5);
                var uv00 = new egret3d.math.Vector2(0, 0);
                var uv01 = new egret3d.math.Vector2(0, 1);
                var uv10 = new egret3d.math.Vector2(1, 0);
                var uv11 = new egret3d.math.Vector2(1, 1);
                var ipos = 0;
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new egret3d.math.Vector3(0, height * 0.5, 0));
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, -halfsize));
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new egret3d.math.Vector3(0, height * 0.5, 0));
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, halfsize));
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new egret3d.math.Vector3(0, height * 0.5, 0));
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new egret3d.math.Vector3(0, height * 0.5, 0));
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, -halfsize));
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new egret3d.math.Vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new egret3d.math.Vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            };
            MeshData.genSphereCCW = function (radius, widthSegments, heightSegments) {
                if (radius === void 0) { radius = 1; }
                if (widthSegments === void 0) { widthSegments = 24; }
                if (heightSegments === void 0) { heightSegments = 12; }
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new egret3d.math.Vector3();
                var normal = new egret3d.math.Vector3();
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(egret3d.math.Pool.clone_vector3(vertex));
                        normal = egret3d.math.Pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        var uv = new egret3d.math.Vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            };
            MeshData.genBoxCCW = function (size) {
                var half = size * 0.5;
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, -1, 0));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, -half, -half),
                    new egret3d.math.Vector3(-half, -half, half),
                    new egret3d.math.Vector3(half, -half, -half),
                    new egret3d.math.Vector3(half, -half, half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 1, 0));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, half, half),
                    new egret3d.math.Vector3(-half, half, -half),
                    new egret3d.math.Vector3(half, half, half),
                    new egret3d.math.Vector3(half, half, -half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, -half, half),
                    new egret3d.math.Vector3(-half, half, half),
                    new egret3d.math.Vector3(half, -half, half),
                    new egret3d.math.Vector3(half, half, half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(1, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(0, 0),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, -1));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, half, -half),
                    new egret3d.math.Vector3(-half, -half, -half),
                    new egret3d.math.Vector3(half, half, -half),
                    new egret3d.math.Vector3(half, -half, -half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 0),
                    new egret3d.math.Vector2(1, 1),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(half, -half, -half),
                    new egret3d.math.Vector3(half, -half, half),
                    new egret3d.math.Vector3(half, half, -half),
                    new egret3d.math.Vector3(half, half, half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 1),
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(1, 0),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadPos(data, [
                    new egret3d.math.Vector3(-half, -half, half),
                    new egret3d.math.Vector3(-half, -half, -half),
                    new egret3d.math.Vector3(-half, half, half),
                    new egret3d.math.Vector3(-half, half, -half)
                ]);
                MeshData.addQuadVec2(data.uv, [
                    new egret3d.math.Vector2(0, 1),
                    new egret3d.math.Vector2(1, 1),
                    new egret3d.math.Vector2(0, 0),
                    new egret3d.math.Vector2(1, 0),
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, -1));
                return data;
            };
            MeshData.genBoxByArray = function (array) {
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, -1, 0));
                MeshData.addQuadPos(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 1, 0));
                MeshData.addQuadPos(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadPos(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, -1));
                MeshData.addQuadPos(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadPos(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, -1));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadPos(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, 1));
                return data;
            };
            MeshData.genBoxByArray_Quad = function (array) {
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, -1, 0));
                MeshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 1, 0));
                MeshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, 1));
                MeshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(0, 0, -1));
                MeshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(1, 0, 0));
                MeshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, -1));
                MeshData.addQuadVec3ByValue(data.normal, new egret3d.math.Vector3(-1, 0, 0));
                MeshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                MeshData.addQuadVec3ByValue(data.tangent, new egret3d.math.Vector3(0, 0, 1));
                return data;
            };
            MeshData.genCircleLineCCW = function (radius, segment, wide) {
                if (segment === void 0) { segment = 64; }
                if (wide === void 0) { wide = 0.05; }
                var data = new MeshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    MeshData.addQuadPos(data, [
                        new egret3d.math.Vector3(x2, wide, z2),
                        new egret3d.math.Vector3(x1, wide, z1),
                        new egret3d.math.Vector3(x2, -wide, z2),
                        new egret3d.math.Vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            };
            MeshData.prototype.caclByteLength = function () {
                var len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            };
            MeshData.calcByteSize = function (vf) {
                var total = 0;
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            };
            MeshData.prototype.genVertexDataArray = function (vf) {
                var vertexCount = this.pos.length;
                var total = MeshData.calcByteSize(vf) / 4;
                var letray = new Float32Array(total * vertexCount);
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    letray[i * total + nseek] = this.pos[i].x;
                    nseek++;
                    letray[i * total + nseek] = this.pos[i].y;
                    nseek++;
                    letray[i * total + nseek] = this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (this.normal == undefined || this.normal.length == 0) {
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.normal[i].x;
                            nseek++;
                            letray[i * total + nseek] = this.normal[i].y;
                            nseek++;
                            letray[i * total + nseek] = this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (this.tangent == undefined || this.tangent.length == 0) {
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.tangent[i].x;
                            nseek++;
                            letray[i * total + nseek] = this.tangent[i].y;
                            nseek++;
                            letray[i * total + nseek] = this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (this.color == undefined || this.color.length == 0) {
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.color[i].r;
                            nseek++;
                            letray[i * total + nseek] = this.color[i].g;
                            nseek++;
                            letray[i * total + nseek] = this.color[i].b;
                            nseek++;
                            letray[i * total + nseek] = this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (this.uv == undefined || this.uv.length == 0) {
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.uv[i].x;
                            nseek++;
                            letray[i * total + nseek] = this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (this.uv2 == undefined || this.uv2.length == 0) {
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.uv2[i].x;
                            nseek++;
                            letray[i * total + nseek] = this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (this.blendIndex == undefined || this.blendIndex.length == 0) {
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.blendIndex[i].v0;
                            nseek++;
                            letray[i * total + nseek] = this.blendIndex[i].v1;
                            nseek++;
                            letray[i * total + nseek] = this.blendIndex[i].v2;
                            nseek++;
                            letray[i * total + nseek] = this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (this.blendWeight == undefined || this.blendWeight.length == 0) {
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                            letray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.blendWeight[i].v0;
                            nseek++;
                            letray[i * total + nseek] = this.blendWeight[i].v1;
                            nseek++;
                            letray[i * total + nseek] = this.blendWeight[i].v2;
                            nseek++;
                            letray[i * total + nseek] = this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (this.colorex == undefined || this.colorex.length == 0) {
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                            letray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            letray[i * total + nseek] = this.colorex[i].r;
                            nseek++;
                            letray[i * total + nseek] = this.colorex[i].g;
                            nseek++;
                            letray[i * total + nseek] = this.colorex[i].b;
                            nseek++;
                            letray[i * total + nseek] = this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                return letray;
            };
            MeshData.prototype.genIndexDataArray = function () {
                return new Uint16Array(this.trisindex);
            };
            MeshData.prototype.genIndexDataArrayTri2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                return new Uint16Array(line);
            };
            MeshData.prototype.genIndexDataArrayQuad2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                return new Uint16Array(line);
            };
            return MeshData;
        }());
        render.MeshData = MeshData;
        __reflect(MeshData.prototype, "egret3d.render.MeshData");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var StaticMeshRenderer = (function () {
            function StaticMeshRenderer() {
                this.eboIndex = 0;
                this.drawMode = render.DrawModeEnum.EboTri;
                this.drawbegin = 0;
                this.drawcount = -1;
            }
            StaticMeshRenderer.prototype.draw = function (webgl) {
                var force = this.material.use(webgl);
                this.material.program.bindAttributes(this.mesh, this.eboIndex, force);
                if (this.drawMode == render.DrawModeEnum.VboTri) {
                    render.Webglkit.drawArrayTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    render.Webglkit.drawArrayLines(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    render.Webglkit.drawElementTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboLine) {
                    render.Webglkit.drawElementLines(webgl, this.drawbegin, this.drawcount);
                }
            };
            return StaticMeshRenderer;
        }());
        render.StaticMeshRenderer = StaticMeshRenderer;
        __reflect(StaticMeshRenderer.prototype, "egret3d.render.StaticMeshRenderer");
        var BatchRenderer = (function () {
            function BatchRenderer() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            BatchRenderer.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new render.GlMesh();
                this.mesh.initBuffer(webgl, vf, 128, render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == render.DrawModeEnum.EboLine || drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            BatchRenderer.prototype.begin = function (webgl, mat) {
                if (this.vboCount > 0) {
                    this.end(webgl);
                }
                this.curmaterial = mat;
            };
            BatchRenderer.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048 || (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == render.DrawModeEnum.VboLine || this.drawMode == render.DrawModeEnum.VboTri) {
                    return;
                }
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            BatchRenderer.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexSubData(webgl, this.dataForVbo.slice(0, this.vboCount), 0);
                if (this.eboCount > 0)
                    this.mesh.uploadIndexSubData(webgl, 0, this.dataForEbo.slice(0, this.eboCount), 0);
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                var force = this.curmaterial.use(webgl);
                this.curmaterial.program.bindAttributes(this.mesh, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1, force);
                if (this.drawMode == render.DrawModeEnum.EboLine) {
                    render.Webglkit.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    render.Webglkit.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    render.Webglkit.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboTri) {
                    render.Webglkit.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return BatchRenderer;
        }());
        render.BatchRenderer = BatchRenderer;
        __reflect(BatchRenderer.prototype, "egret3d.render.BatchRenderer");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var GlWindow = (function () {
            function GlWindow() {
                this.clearop_Color = false;
                this.backColor = new egret3d.math.Color(1, 0, 1, 1);
                this.clearop_Depth = false;
                this.clearop_Stencil = false;
                this.viewport = new egret3d.math.Rect(0, 0, 1, 1);
            }
            GlWindow.prototype.use = function (webgl) {
                if (this.renderTarget != null) {
                    this.renderTarget.use(webgl);
                }
                else {
                    egret3d.render.GlRenderTarget.useNull(webgl);
                }
                if (this.backColor != null) {
                    webgl.clearColor(this.backColor.r, this.backColor.g, this.backColor.b, this.backColor.a);
                }
                var n = 0;
                if (this.clearop_Color)
                    n |= webgl.COLOR_BUFFER_BIT;
                if (this.clearop_Depth)
                    n |= webgl.DEPTH_BUFFER_BIT;
                if (this.clearop_Stencil)
                    n |= webgl.STENCIL_BUFFER_BIT;
                webgl.clear(n);
                if (this.renderTarget != null) {
                    webgl.viewport(this.renderTarget.width * this.viewport.x, this.renderTarget.height * this.viewport.y, this.renderTarget.width * this.viewport.w, this.renderTarget.height * this.viewport.h);
                }
                else {
                    webgl.viewport(webgl.canvas.width * this.viewport.x, webgl.canvas.height * this.viewport.y, webgl.canvas.width * this.viewport.w, webgl.canvas.height * this.viewport.h);
                }
            };
            return GlWindow;
        }());
        render.GlWindow = GlWindow;
        __reflect(GlWindow.prototype, "egret3d.render.GlWindow");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        var _vsShaderMap = {};
        var _fsShaderMap = {};
        function getWebGLShader(type, gl, info) {
            if (type == gl.VERTEX_SHADER && _vsShaderMap[info.name]) {
                return _vsShaderMap[info.name];
            }
            if (type == gl.FRAGMENT_SHADER && _fsShaderMap[info.name]) {
                return _fsShaderMap[info.name];
            }
            var shader = gl.createShader(type);
            gl.shaderSource(shader, info.src);
            gl.compileShader(shader);
            var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!parameter) {
                if (confirm("shader compile:" + info.name + " " + type + " error! ->" + gl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                    gl.deleteShader(shader);
                    alert(info.src);
                }
                return null;
            }
            if (type == gl.VERTEX_SHADER) {
                _vsShaderMap[info.name] = shader;
            }
            else {
                _fsShaderMap[info.name] = shader;
            }
            return shader;
        }
        function getWebGLProgram(gl, vs, fs) {
            var program = gl.createProgram();
            gl.attachShader(program, getWebGLShader(gl.VERTEX_SHADER, gl, vs));
            gl.attachShader(program, getWebGLShader(gl.FRAGMENT_SHADER, gl, fs));
            gl.linkProgram(program);
            var parameter = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!parameter) {
                alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        var GlProgram = (function () {
            function GlProgram(gl, vShaderInfo, fShaderInfo) {
                this.uniforms = {};
                this._cacheContextVer = -1;
                this._cacheMeshVer = -1;
                this._cacheMeshEbo = -1;
                this._cacheMaterialVer = -1;
                this._textureLocations = {};
                this._cacheTextureUniforms = [];
                var program = getWebGLProgram(gl, vShaderInfo, fShaderInfo);
                this.program = program;
                this.gl = gl;
                function getAttribLocation(key) {
                    return gl.getAttribLocation(program, key);
                }
                this._vertexAttributeFormat = [
                    { name: "_glesVertex", mask: render.VertexFormatMask.Position, location: getAttribLocation("_glesVertex"), size: 3, type: gl.FLOAT, normalized: false },
                    { name: "_glesNormal", mask: render.VertexFormatMask.Normal, location: getAttribLocation("_glesNormal"), size: 3, type: gl.FLOAT, normalized: true },
                    { name: "_glesTangent", mask: render.VertexFormatMask.Tangent, location: getAttribLocation("_glesTangent"), size: 3, type: gl.FLOAT, normalized: true },
                    { name: "_glesColor", mask: render.VertexFormatMask.Color, location: getAttribLocation("_glesColor"), size: 4, type: gl.FLOAT, normalized: false },
                    { name: "_glesMultiTexCoord0", mask: render.VertexFormatMask.UV0, location: getAttribLocation("_glesMultiTexCoord0"), size: 2, type: gl.FLOAT, normalized: false },
                    { name: "_glesMultiTexCoord1", mask: render.VertexFormatMask.UV1, location: getAttribLocation("_glesMultiTexCoord1"), size: 2, type: gl.FLOAT, normalized: false },
                    { name: "_glesBlendIndex4", mask: render.VertexFormatMask.BlendIndex4, location: getAttribLocation("_glesBlendIndex4"), size: 4, type: gl.FLOAT, normalized: false },
                    { name: "_glesBlendWeight4", mask: render.VertexFormatMask.BlendWeight4, location: getAttribLocation("_glesBlendWeight4"), size: 4, type: gl.FLOAT, normalized: false },
                    { name: "_glesColorEx", mask: render.VertexFormatMask.ColorEX, location: getAttribLocation("_glesColorEx"), size: 4, type: gl.FLOAT, normalized: false }
                ];
                for (var key in vShaderInfo.uniforms) {
                    this.uniforms[key] = {
                        type: vShaderInfo.uniforms[key],
                        location: gl.getUniformLocation(program, key),
                        value: null
                    };
                }
                for (var key in fShaderInfo.uniforms) {
                    this.uniforms[key] = {
                        type: fShaderInfo.uniforms[key],
                        location: gl.getUniformLocation(program, key),
                        value: null
                    };
                }
                var location = 0;
                for (var key in this.uniforms) {
                    if (this.uniforms[key].type == UniformTypeEnum.Texture) {
                        this._textureLocations[key] = location;
                        location++;
                    }
                }
            }
            GlProgram.get = function (vShaderInfo, fShaderInfo) {
                var name = vShaderInfo.name + "_" + fShaderInfo.name;
                if (!this._programMap[name]) {
                    var gl = render.Webglkit.webgl;
                    this._programMap[name] = new GlProgram(gl, vShaderInfo, fShaderInfo);
                }
                return this._programMap[name];
            };
            GlProgram.prototype.bindAttributes = function (mesh, bindEbo, forceUpdate) {
                if (bindEbo === void 0) { bindEbo = 0; }
                if (forceUpdate === void 0) { forceUpdate = false; }
                if (!forceUpdate && this._cacheMesh == mesh && this._cacheMeshVer == mesh.version && this._cacheMeshEbo == bindEbo) {
                    return;
                }
                this._cacheMesh = mesh;
                this._cacheMeshVer = mesh.version;
                this._cacheMeshEbo = bindEbo;
                var webgl = this.gl;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, mesh.vbo);
                if (bindEbo >= 0) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, mesh.ebos[bindEbo]);
                }
                var total = mesh.vertexByteSize;
                var seek = 0;
                var channel = 0;
                for (var i = 0, l = this._vertexAttributeFormat.length; i < l; i++) {
                    var info = this._vertexAttributeFormat[i];
                    if ((info.mask & mesh.vertexFormat) || info.mask == render.VertexFormatMask.Position) {
                        if (info.location >= 0) {
                            webgl.enableVertexAttribArray(info.location);
                            webgl.vertexAttribPointer(info.location, info.size, info.type, info.normalized, total, seek);
                            channel++;
                        }
                        seek += info.size * 4;
                    }
                    else if (info.location >= 0) {
                        webgl.disableVertexAttribArray(info.location);
                        channel++;
                    }
                }
                render.Webglkit.SetMaxVertexAttribArray(webgl, channel);
            };
            GlProgram.prototype._updateRenderContextUniforms = function (context) {
                for (var key in this.uniforms) {
                    switch (key) {
                        case "glstate_matrix_model":
                            this.setMatrix(key, context.matrixModel);
                            break;
                        case "glstate_matrix_view":
                            this.setMatrix(key, context.matrixView);
                            break;
                        case "glstate_matrix_project":
                            this.setMatrix(key, context.matrixProject);
                            break;
                        case "glstate_matrix_modelview":
                            this.setMatrix(key, context.matrixModelView);
                            break;
                        case "glstate_matrix_viewproject":
                            this.setMatrix(key, context.matrixViewProject);
                            break;
                        case "glstate_matrix_mvp":
                            this.setMatrix(key, context.matrixModelViewProject);
                            break;
                        case "glstate_timer":
                            this.setFloat(key, context.floatTimer);
                            break;
                        case "glstate_lightcount":
                            this.setFloat(key, context.intLightCount);
                            break;
                        case "glstate_vec4_lightposs":
                            if (context.vec4LightPos.length > 0) {
                                this.setVector4v(key, context.vec4LightPos);
                            }
                            break;
                        case "glstate_vec4_lightdirs":
                            if (context.vec4LightDir.length > 0) {
                                this.setVector4v(key, context.vec4LightDir);
                            }
                            break;
                        case "glstate_float_spotangelcoss":
                            if (context.floatLightSpotAngleCos.length > 0) {
                                this.setFloatv(key, context.floatLightSpotAngleCos);
                            }
                            break;
                        case "glstate_eyepos":
                            this.setVector4(key, context.eyePos);
                            break;
                        case "_LightmapTex":
                            this.setTexture(key, context.lightmap);
                            break;
                        case "glstate_lightmapOffset":
                            this.setVector4(key, context.lightmapOffset);
                            break;
                        case "glstate_lightmapUV":
                            this.setFloat(key, context.lightmapUV);
                            break;
                        case "glstate_vec4_bones":
                            this.setVector4v(key, context.boneData);
                            break;
                        case "glstate_matrix_bones":
                            this.setVector4v(key, context.boneData);
                            break;
                    }
                }
            };
            GlProgram.prototype.setMatrix = function (key, value) {
                var uniform = this.uniforms[key];
                uniform.value = value.rawData;
                this.gl.uniformMatrix4fv(uniform.location, false, uniform.value);
            };
            GlProgram.prototype.setVector4v = function (key, value) {
                var uniform = this.uniforms[key];
                uniform.value = value;
                this.gl.uniform4fv(uniform.location, uniform.value);
            };
            GlProgram.prototype.setFloat = function (key, value) {
                if (this.uniforms[key].value != value) {
                    var uniform = this.uniforms[key];
                    uniform.value = value;
                    this.gl.uniform1f(uniform.location, uniform.value);
                }
            };
            GlProgram.prototype.setFloatv = function (key, value) {
                var uniform = this.uniforms[key];
                uniform.value = value;
                this.gl.uniform1fv(uniform.location, uniform.value);
            };
            GlProgram.prototype.setVector4 = function (key, value) {
                var uniform = this.uniforms[key];
                var letray = uniform.value;
                if (!letray) {
                    uniform.value = [value.x, value.y, value.z, value.w];
                    this.gl.uniform4fv(uniform.location, uniform.value);
                }
                else {
                    if (letray[0] != value.x || letray[1] != value.y || letray[2] != value.z || letray[3] != value.w) {
                        letray[0] = value.x;
                        letray[1] = value.y;
                        letray[2] = value.z;
                        letray[3] = value.w;
                        this.gl.uniform4fv(uniform.location, uniform.value);
                    }
                }
            };
            GlProgram.prototype.setTexture = function (key, value) {
                var uniform = this.uniforms[key];
                uniform.value = value ? value.glTexture : null;
                var index = this._textureLocations[key];
                var tex = uniform.value != null ? uniform.value.texture : null;
                if (!this._cacheTextureUniforms[index]) {
                    this.gl.uniform1i(uniform.location, index);
                    this._cacheTextureUniforms[index] = { dirty: true, texture: tex };
                }
                else {
                    this._cacheTextureUniforms[index].texture = tex;
                    this._cacheTextureUniforms[index].dirty = true;
                }
            };
            GlProgram.prototype._updateUniforms = function (unifroms) {
                for (var key in unifroms) {
                    var type = unifroms[key].type;
                    var value = (unifroms[key].value == undefined) ? unifroms[key].defaultValue : unifroms[key].value;
                    var target = this.uniforms[key];
                    if (target == null) {
                        continue;
                    }
                    switch (type) {
                        case render.UniformTypeEnum.Float:
                            this.setFloat(key, value);
                            break;
                        case render.UniformTypeEnum.Floatv:
                            this.setFloatv(key, value);
                            break;
                        case render.UniformTypeEnum.Float4:
                            this.setVector4(key, value);
                            break;
                        case render.UniformTypeEnum.Float4v:
                            this.setVector4v(key, value);
                            break;
                        case render.UniformTypeEnum.Float4x4:
                            this.setMatrix(key, value);
                            break;
                        case render.UniformTypeEnum.Float4x4v:
                            this.setMatrix(key, value);
                            break;
                        case render.UniformTypeEnum.Texture:
                            this.setTexture(key, value);
                            break;
                    }
                }
            };
            GlProgram.prototype.uploadUniforms = function (material, context, forceUpdate) {
                if (forceUpdate === void 0) { forceUpdate = false; }
                var materialChange = this._cacheMaterial !== material || this._cacheMaterialVer !== material.version;
                if (materialChange) {
                    this._updateUniforms(material.mapUniform);
                    this._updateUniforms(material.mapUniformTemp);
                    this._cacheMaterial = material;
                    this._cacheMaterialVer = material.version;
                }
                var contextChange = this._cacheContext != context || this._cacheContextVer != context.version;
                if (contextChange) {
                    this._updateRenderContextUniforms(context);
                    this._cacheContext = context;
                    this._cacheContextVer = context.version;
                }
                if (forceUpdate) {
                    for (var i = 0; i < this._cacheTextureUniforms.length; i++) {
                        var info = this._cacheTextureUniforms[i];
                        if (info) {
                            render.Webglkit.activeTexture(i);
                            this.gl.bindTexture(this.gl.TEXTURE_2D, info.texture);
                        }
                    }
                }
                else if (materialChange || contextChange) {
                    for (var i = 0; i < this._cacheTextureUniforms.length; i++) {
                        var info = this._cacheTextureUniforms[i];
                        if (info && info.dirty) {
                            render.Webglkit.activeTexture(i);
                            this.gl.bindTexture(this.gl.TEXTURE_2D, info.texture);
                        }
                    }
                }
                else {
                }
            };
            GlProgram._programMap = {};
            return GlProgram;
        }());
        render.GlProgram = GlProgram;
        __reflect(GlProgram.prototype, "egret3d.render.GlProgram");
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var render;
    (function (render) {
        var TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        var TextureReader = (function () {
            function TextureReader(webgl, texRGBA, width, height, gray) {
                if (gray === void 0) { gray = true; }
                this.gray = gray;
                this.width = width;
                this.height = height;
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                var readData = new Uint8Array(this.width * this.height * 4);
                readData[0] = 2;
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
                if (gray) {
                    this.data = new Uint8Array(this.width * this.height);
                    for (var i = 0; i < width * height; i++) {
                        this.data[i] = readData[i * 4];
                    }
                }
                else {
                    this.data = readData;
                }
            }
            TextureReader.prototype.getPixel = function (u, v) {
                var x = (u * this.width) | 0;
                var y = (v * this.height) | 0;
                if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                    return 0;
                if (this.gray) {
                    return this.data[y * this.width + x];
                }
                else {
                    var i = (y * this.width + x) * 4;
                    return new egret3d.math.Color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
                }
            };
            return TextureReader;
        }());
        render.TextureReader = TextureReader;
        __reflect(TextureReader.prototype, "egret3d.render.TextureReader");
        var GlRenderTarget = (function () {
            function GlRenderTarget(webgl, width, height, depth, stencil) {
                if (depth === void 0) { depth = false; }
                if (stencil === void 0) { stencil = false; }
                this.width = width;
                this.height = height;
                this.fbo = webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            }
            GlRenderTarget.prototype.use = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            };
            GlRenderTarget.useNull = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            };
            GlRenderTarget.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            GlRenderTarget.prototype.caclByteLength = function () {
                return this.width * this.height * 4;
            };
            GlRenderTarget.prototype.isFrameBuffer = function () {
                return true;
            };
            return GlRenderTarget;
        }());
        render.GlRenderTarget = GlRenderTarget;
        __reflect(GlRenderTarget.prototype, "egret3d.render.GlRenderTarget", ["egret3d.render.ITexture"]);
        var GlTexture2D = (function () {
            function GlTexture2D(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.texture = webgl.createTexture();
            }
            GlTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB) {
                    formatGL = this.webgl.RGB;
                }
                else if (this.format == TextureFormatEnum.Gray) {
                    formatGL = this.webgl.LUMINANCE;
                }
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            GlTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB) {
                    formatGL = this.webgl.RGB;
                }
                else if (this.format == TextureFormatEnum.Gray) {
                    formatGL = this.webgl.LUMINANCE;
                }
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            GlTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            GlTexture2D.prototype.getReader = function (redOnly) {
                if (redOnly === void 0) { redOnly = false; }
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new TextureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            };
            GlTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            GlTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            GlTexture2D.formGrayArray = function (webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new GlTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            };
            GlTexture2D.staticTexture = function (webgl, name) {
                var t = GlTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new GlTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(4);
                var width = 1;
                var height = 1;
                data[0] = 128;
                data[1] = 0;
                data[2] = 128;
                data[3] = 255;
                if (name == "gray") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 128;
                    data[3] = 255;
                }
                else if (name == "white") {
                    data[0] = 255;
                    data[1] = 255;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "black") {
                    data[0] = 0;
                    data[1] = 0;
                    data[2] = 0;
                    data[3] = 255;
                }
                else if (name == "grid") {
                    width = 256;
                    height = 256;
                    data = new Uint8Array(width * width * 4);
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            var seek = (y * width + x) * 4;
                            if (((x - width * 0.5) * (y - height * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, width, height, data);
                GlTexture2D.mapTexture[name] = t;
                return t;
            };
            GlTexture2D.mapTexture = {};
            return GlTexture2D;
        }());
        render.GlTexture2D = GlTexture2D;
        __reflect(GlTexture2D.prototype, "egret3d.render.GlTexture2D", ["egret3d.render.ITexture"]);
        var WriteableTexture2D = (function () {
            function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.premultiply = true;
                this.repeat = false;
                this.mirroredU = false;
                this.mirroredV = false;
                this.width = 0;
                this.height = 0;
                this.webgl = webgl;
                this.texture = webgl.createTexture();
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.format = format;
                this.formatGL = this.webgl.RGBA;
                if (format == TextureFormatEnum.RGB) {
                    this.formatGL = this.webgl.RGB;
                }
                else if (format == TextureFormatEnum.Gray) {
                    this.formatGL = this.webgl.LUMINANCE;
                }
                var data = null;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            WriteableTexture2D.prototype.updateRect = function (data, x, y, width, height) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.updateRectImg = function (data, x, y) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            WriteableTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            WriteableTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                return len;
            };
            return WriteableTexture2D;
        }());
        render.WriteableTexture2D = WriteableTexture2D;
        __reflect(WriteableTexture2D.prototype, "egret3d.render.WriteableTexture2D", ["egret3d.render.ITexture"]);
    })(render = egret3d.render || (egret3d.render = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var framework;
    (function (framework) {
        var TrailRender = (function () {
            function TrailRender() {
                this.frustumTest = false;
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.Default;
                this.queue = 0;
                this.vertexcount = 24;
                this.active = false;
                this.reInit = false;
                this.extenedOneSide = true;
                this.speed = 0.5;
                this.width = 1.0;
                this.lookAtCamera = false;
            }
            TrailRender.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = egret3d.render.Webglkit.webgl;
                this.initmesh();
            };
            TrailRender.prototype.update = function (delta) {
                if (!this.active)
                    return;
                if (this.reInit) {
                    this.intidata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getPosition();
                if (this.lookAtCamera) {
                    this.camerapositon = this.app.getScene().mainCamera.gameObject.transform.getPosition();
                    var camdir = egret3d.math.Pool.new_vector3();
                    egret3d.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    egret3d.math.vec3Normalize(camdir, camdir);
                    var direction = egret3d.math.Pool.new_vector3();
                    egret3d.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    egret3d.math.vec3Normalize(direction, direction);
                    egret3d.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    egret3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    egret3d.math.Pool.delete_vector3(direction);
                }
                egret3d.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    egret3d.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = egret3d.math.Pool.new_vector3();
                        egret3d.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        egret3d.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = egret3d.math.Pool.new_vector3();
                        egret3d.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        egret3d.math.vec3Normalize(movedir, movedir);
                        egret3d.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        egret3d.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        egret3d.math.Pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUp(this.sticks[0].updir);
                    egret3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        egret3d.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            };
            Object.defineProperty(TrailRender.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new egret3d.framework.Material();
                        mat.setShader(framework.DefaultShaders.Diffuse);
                        this.material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this.material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrailRender.prototype, "color", {
                get: function () {
                    if (this._color == undefined) {
                        this._color = new egret3d.math.Color(1, 1, 1, 1);
                    }
                    return this._color;
                },
                set: function (color) {
                    this._color = color;
                },
                enumerable: true,
                configurable: true
            });
            TrailRender.prototype.setspeed = function (upspeed) {
                this.speed = upspeed;
            };
            TrailRender.prototype.setWidth = function (Width) {
                this.width = Width;
            };
            TrailRender.prototype.play = function () {
                this.reInit = true;
                this.active = true;
            };
            TrailRender.prototype.stop = function () {
                this.active = false;
            };
            TrailRender.prototype.initmesh = function () {
                this.mesh = new egret3d.framework.Mesh();
                this.mesh.data = new egret3d.render.MeshData();
                this.mesh.glMesh = new egret3d.render.GlMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = egret3d.render.VertexFormatMask.Position | egret3d.render.VertexFormatMask.Color | egret3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, egret3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                var sm = new framework.SubMeshInfo();
                sm.matIndex = 0;
                sm.useVertexIndex = 0;
                sm.start = 0;
                sm.size = this.dataForEbo.length;
                sm.line = false;
                this.mesh.submesh.push(sm);
            };
            TrailRender.prototype.intidata = function () {
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new TrailStick();
                    this.sticks.push(ts);
                    ts.location = new egret3d.math.Vector3();
                    egret3d.math.vec3Clone(this.gameObject.transform.getPosition(), ts.location);
                    ts.updir = new egret3d.math.Vector3();
                    this.gameObject.transform.getUp(ts.updir);
                    egret3d.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                var updir = egret3d.math.Pool.new_vector3();
                this.gameObject.transform.getUp(updir);
                egret3d.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Clone(this.gameObject.transform.getPosition(), pos);
                var uppos = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Add(pos, updir, uppos);
                var downpos = egret3d.math.Pool.new_vector3();
                egret3d.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexSubData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexSubData(this.webgl, 0, this.dataForEbo);
                egret3d.math.Pool.delete_vector3(updir);
                egret3d.math.Pool.delete_vector3(pos);
                egret3d.math.Pool.delete_vector3(uppos);
                egret3d.math.Pool.delete_vector3(downpos);
            };
            TrailRender.prototype.updateTrailData = function () {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            };
            TrailRender.prototype.render = function (context, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
            };
            TrailRender.prototype.clone = function () {
            };
            TrailRender.prototype.remove = function () {
            };
            TrailRender = __decorate([
                egret3d.reflect.nodeRender,
                egret3d.reflect.nodeComponent
            ], TrailRender);
            return TrailRender;
        }());
        framework.TrailRender = TrailRender;
        __reflect(TrailRender.prototype, "egret3d.framework.TrailRender", ["egret3d.framework.IRenderer", "egret3d.framework.INodeComponent"]);
        var TrailStick = (function () {
            function TrailStick() {
            }
            return TrailStick;
        }());
        __reflect(TrailStick.prototype, "TrailStick");
    })(framework = egret3d.framework || (egret3d.framework = {}));
})(egret3d || (egret3d = {}));
